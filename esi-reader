#!/usr/bin/perl
=begin license

	#    ESI Reader - get market data in a very good maner from EVE Online
	#    Copyright (C) 2018 Author: https://github.com/DomAsProgrammer
	#
	#    This program is free software: you can redistribute it and/or modify
	#    it under the terms of the GNU Affero General Public License as
	#    published by the Free Software Foundation, either version 3 of the
	#    License, or (at your option) any later version.
	#
	#    This program is distributed in the hope that it will be useful,
	#    but WITHOUT ANY WARRANTY; without even the implied warranty of
	#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	#    GNU Affero General Public License for more details.
	#
	#    You should have received a copy of the GNU Affero General Public License
	#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

=end license
=cut

=begin Version_history

	v1.0
	System running with most functions as expected

	v1.1
	Resolved issue to be unable to enter negative numbers in
	security field. Resolved bugs, which can kill agents
	(especially downloader() and access_DB()).

	v1.2
	Optimized database: hauls table now is faster than
	orders_sells tables (Former it was FAR slower as the
	orders_* tables!)

	v1.3
	Added jumps calculation and security route selection

	v1.4
	Built hauls view in Perl, because database was after
	engine update no longer able to calculate within 60
	seconds. (No idea how loong it needs now to calculate
	the view now, but the longest I waited was more than
	2 HOURS...)

	v1.5
	The init system now runs only on first run and all
	missing data will be pulled on request via agent. Only
	exclusion: Regions may be pulled on start, if a unknown
	region appears. (Market updates on start are untouched
	and will run after an hour turned off!)

	v1.6
	Perl's hauls view gets very slow on many
	records - rebuild a database view same way as I built
	the Perl hauls view -> this is much faster in SQL as the
	Perl variant AND faster as the former SQL hauls view,
	but still MUST NOT handle any WHERE clauses directly!

	v1.7
	Corrected output for hauls table:
	Bought elements wouldn't remove sale/buy orders anymore,
	but subtract the quantity amount of them - and leave
	them open for use, if this still fits for other
	opportunities.

	v1.7.1
	Added jumps and issus columns to purchased table

	v1.8 
	Implemented version check

	v1.8.1 WORK
	Repaired err_msg() to show proper error message

=end Version_history
=cut

use strict;
use warnings;

### Libraries
use DBI;
use File::Basename;
use File::Path qw(make_path remove_tree);
use File::Copy qw(cp move);
use Cwd qw(realpath);
use Getopt::Long qw(:config no_ignore_case bundling);
use Tk qw(:eventtypes);
use Tk::ProgressBar;			# Really needed?	YES
use Tk::Optionmenu;			# Really needed?	YES
use Tk::BrowseEntry;			# Really needed?	YES
use Tk::Labelframe;
use Tk::HList;				# Really needed?	YES
use List::Util qw(shuffle);
use JSON;
use MIME::Base64;
use Time::HiRes;
use POSIX qw(:sys_wait_h floor ceil);
use IPC::Shareable;
use REST::Client;
use Env;
use version;
use utf8;

### Output handle for Non-shell application
print STDERR "WARNING: Any further output will be written to /tmp/esi-reader.out and /tmp/esi-reader.err\n";
close(STDOUT);
close(STDIN);
close(STDERR);
open(STDOUT, ">", "/tmp/esi-reader.out") or die "Can't write STDOUT file!\n";
open(STDERR, ">", "/tmp/esi-reader.err") or die "Can't write STDERR file!\n";

### Declaration
## EVE connections
## GUI links and textes
my $app_name		= "ESI Reader";
my $app_version		= "v1.8";
my $MainTitle		= "$app_name $app_version - ";
my $url_dev_apps	= "https://developers.eveonline.com/";
my $lsburl		= "https://login.eveonline.com";	# login server base url
my $dlburl		= "https://esi.evetech.net/latest";
my $callback_url	= "http://localhost/oauth-callback";
my @scopes		= (
	"esi-universe.read_structures.v1",
	"esi-markets.structure_markets.v1",
	);
chomp(my $cURL		= qx(which curl 2> /dev/null));
chomp(my $pgrep		= qx(which pgrep 2> /dev/null));
my $cURL_options	= "-ss -f --connect-timeout 30 -m 120";
my $dev_url		= "https://developers.eveonline.com/applications";
my @argv_backup		= @ARGV;
my $tick_exec_after	= 0;	# tick for choosing if the main app should be startet after finishing the setup

## Database
my $database		= "$ENV{HOME}/.local/share/esi-reader/eve-esi.db";
my $dsn			= "DBI:SQLite:dbname=";
my $user_id		= "";
my $password		= "";

## Forking
my $ppid		= $$;
my @childs		= ();
my $max_forks		= 10;
my $_CPU_count		= undef;

# Inter-Process Communication
my $transID		= &gen_random(4);
my $main_knot		= tie(my %transport, 'IPC::Shareable', $transID, {
	create		=> 1,
	mode		=> 0600,
	destroy		=> 1,
	size		=> IPC::Shareable::SHM_BUFSIZ(),
	});
$main_knot->shlock;
%transport		= (		# fill AFTER tieing
	CharacterID	=> 0,
	CharacterName	=> "",
	run_update	=> "",		# all, markets, start
	progress_percent => 0.00,	# Mainwindow progress bar
	progress_text	=> "",		# Mainwindow progress bar text
	perma_text	=> "",		# Mainwindow progress bar text (from permanent agents)
	db_locked	=> 0,		# use for exclusive database access
	pt_locked	=> 0,		# use for exclusive database access but priority against db_locked
	dl_locked	=> 0,		# use for exclusive download access
	jumps_reset	=> 0,		# set if a security status of a system changed
	jumps_done	=> 0,		# set if the last block was loaded
	jumps_reads	=> 0,		# used to verify every agent read from database, before we insert (and change the source table)
	ticket		=> 0,		# number for the next ticket
	rqn		=> 0,		# request number - decides, which ticket number is next
	);
$main_knot->shunlock;

# Signal handling
$SIG{INT}		= \&pprop_exit;
$SIG{HUP}		= \&pprop_exit;
$SIG{CHLD}		= "IGNORE";

=begin annoying1

$SIG{CHLD}		= sub {
	local($!, $?);
	while ( ( my $pid = waitpid(-1, WNOHANG) ) > 0 ) {
		if ( WIFEXITED($?) ) {
			&debug_out("main(): Child $pid exited with return code: " . WEXITSTATUS($?));
			}
		}
	};

=end annoying1
=cut

## GUI config
my $setup_finished	= 0;
my %Colors		= (
	red			=> "#df0000",
	green			=> "#00e300",
	dark_blue		=> "#264a63",
	blue			=> "#37ffff",
	bright_grey		=> "#c0c0c0",	# default font
	bright_yellow		=> "#c4a251",	# ORE frigate painting
	warning_yellow		=> "#fab400",	# CCP Buy buttons

	security		=> {
		1.0		=> "#32fafa",
		0.9		=> "#4bfbc9",
		0.8		=> "#00fd4b",
		0.7		=> "#00ff00",
		0.6		=> "#99fe33",
		0.5		=> "#fdfd00",
		0.4		=> "#e57f00",
		0.3		=> "#fd6500",
		0.2		=> "#ef4700",
		0.1		=> "#e53300",
		0.0		=> "#fd0000",
		# -0		=> 0.0
		},
	);
my %Signs		= (
	tick		=> "✔",
	cross		=> "×",
	ball		=> "•",
	circle		=> "◦",
	junction	=> "├",
	branch		=> "╴",
	turnoff		=> "└",
	cord		=> "│",
	);
my $def_bg_hex		= "#020202";		# background
my $def_sep_hex		= "#222222";		# seperator
my $def_fg_hex		= "#c0c0c0";		# Font color (foreground)
my $def_abg_hex		= $def_bg_hex;
my $def_afg_hex		= $def_fg_hex;
my $def_rel		= "solid";
my %def_lab		= (	# Label
	-background	=> $def_bg_hex,
	-foreground	=> $def_fg_hex,
	);
my %def_labelframe	= (
	-borderwidth	=> 0.5,
	-background	=> $def_bg_hex,
	-foreground	=> $def_fg_hex,
	-relief		=> "groove",
	);
my %def_lab_pack	= (
	-anchor		=> "nw",
	#-expand		=> 0,
	#-fill		=> "none",
	);
my %def_btn		= (
	-relief			=> $def_rel,
	-takefocus		=> 0,
	-background		=> "#1a1a1a",
	-disabledforeground	=> "#0d0d0d",
	-foreground		=> "#afafaf",
	-activebackground	=> "#464646",
	-activeforeground	=> "#ffffff",
	-highlightbackground	=> "#2c2c2c",
	-borderwidth		=> 0,
	#-font			=> "Arial",
	);
my %def_cbtn		= (	# Checkbutton
	#-relief			=> "flat",
	-relief			=> $def_rel,
	#-offrelief		=> "flat",
	#-overrelief		=> "flat",
	-borderwidth		=> 0.5,
	-takefocus		=> 0,
	-background		=> $def_bg_hex,
	-foreground		=> $def_fg_hex,
	-activebackground	=> $def_bg_hex,
	-activeforeground	=> $def_fg_hex,
	-highlightbackground	=> $def_bg_hex,
	#-troughcolor		=> "#0a1c25",
	-selectcolor		=> $Colors{blue},
	-padx			=> 10,
	-pady			=> 10,
	-justify		=> "left",
	);
my %def_rdbtn		= (	# Radiation button
	-relief			=> $def_rel,
	-borderwidth		=> 0,	# 0.5,
	#-indicatoron		=> 1,
	-takefocus		=> 0,
	-background		=> $def_bg_hex,
	-foreground		=> $def_fg_hex,
	-activebackground	=> $Colors{blue},
	-activeforeground	=> $def_bg_hex,
	-highlightbackground	=> $def_bg_hex,
	-selectcolor		=> $Colors{blue},
	);
my %def_scr		= (
	-activebackground	=> "#2f2f2f",
	-activerelief		=> "ridge",
	-background		=> "#171717",
	-borderwidth		=> 0,
	-highlightbackground	=> "#212121",
	-elementborderwidth	=> 0,
	-relief			=> $def_rel,
	-takefocus		=> 0,
	-troughcolor		=> "#0d0c0c",
	);
my %def_txt		= (
	-background		=> "#151515",
	-borderwidth		=> 0,
	-foreground		=> "#b4b4b4",
	-takefocus		=> 0,
	-padx			=> 3,
	-pady			=> 3,
	-highlightbackground	=> "#222222",
	-selectbackground	=> "#505050",
	-selectborderwidth	=> 0,
	-selectforeground	=> "#c6c6c6",
	-relief			=> $def_rel,
	#-width			=> 90,
	);
my %def_ety		= (
	-background		=> "#1a1a1a",
	-borderwidth		=> 0,
	-foreground		=> "#bababa",
	-takefocus		=> 0,		# TEST
	-insertbackground	=> "#c7c7c7",
	-insertwidth		=> 1,
	-highlightcolor		=> "#828282",
	-highlightbackground	=> "#222222",
	-selectbackground	=> "#565656",
	-selectborderwidth	=> 0,
	-selectforeground	=> "#cccccc",
	-relief			=> $def_rel,
	);
my %def_mb		= (	# MenuButton
	-relief			=> $def_btn{-relief},
	-takefocus		=> 0,
	-background		=> $def_btn{-background},
	-disabledforeground	=> $def_btn{-disabledforeground},
	-foreground		=> $def_btn{-foreground},
	-activebackground	=> $def_btn{-activebackground},
	-activeforeground	=> $def_btn{-activeforeground},
	-highlightbackground	=> $def_btn{-highlightbackground},
	-borderwidth		=> $def_btn{-borderwidth},
	);
my %def_menu		= (	# CascadeMenu
	-tearoff		=> 0,
	-background		=> $def_btn{-background},
	-foreground		=> $def_btn{-foreground},
	-activebackground	=> $def_btn{-activebackground},
	-activeforeground	=> $def_btn{-activeforeground},
	#-selectcolor		=> $def_cbtn{-selectcolor},
	);
my %def_buttonmenu	= (		# CascadeMenu
	-background		=> $def_btn{-background},
	-foreground		=> $def_btn{-foreground},
	-activebackground	=> $def_btn{-activebackground},
	-activeforeground	=> $def_btn{-activeforeground},
	-hidemargin		=> 1,
	);
my %def_menu_cbtn	= (
	%def_buttonmenu,
	-selectcolor		=> $def_cbtn{-selectcolor},
	);
my %def_pgB		= (	# ProgressBar
	-anchor			=> "w",
	-troughcolor		=> "#0a1c25",
	-colors			=> [ 0, "#37ffff" ],
	#-colors		=> [ 0, "#2cdbff" ],
	#-from			=> 0,
	-gap			=> 0,
	#-length			=> ,
	-resolution		=> -1,	# -1 is no rounding
	-width			=> 20,
	);
my %def_OptMenu		= (
	-foreground		=> $def_fg_hex,
	-background		=> $def_bg_hex,
	-takefocus		=> 0,
	-borderwidth		=> 0,
	-activebackground	=> $def_sep_hex,
	-activeforeground	=> $def_fg_hex,
	);
my %def_BE		= (	# BrowseEntry
	#-arrowimage
	#-choices
	#-colorstate
	#-disabledbackground
	#-disabledforeground
	#-exportselection
	#-font
	#-readonlybackground 
	-autolistwidth		=> 0,
	#-justify 		=> "left",
	-autolimitheight	=> 1,
	-listwidth		=> 500,
	-listheight		=> 800,
	-buttontakefocus	=> 0,
	-options 		=> [],
	#-bg			=> "red", #$def_ety{-background},	# same as background
	-background		=> $def_ety{-background},
	#-show			=> 0,	??
	-borderwidth		=> $def_ety{-borderwidth},
	#-fg 			=> "red", #$def_ety{-foreground},	# same as foreground
	-foreground		=> $def_ety{-foreground},
	-takefocus		=> $def_ety{-takefocus},
	-insertbackground	=> $def_ety{-insertbackground},
	-insertwidth		=> $def_ety{-insertwidth},
	-highlightcolor		=> $def_ety{-highlightcolor},
	-highlightbackground	=> $def_ety{-highlightbackground},
	#-highlightthickness 	=> 1,
	-insertbackground	=> $def_ety{-foreground},
	#-insertborderwidth
	#-insertofftime
	#-insertontime
	#-insertwidth 
	-selectbackground	=> $def_ety{-selectbackground},
	-selectborderwidth	=> $def_ety{-selectborderwidth},
	-selectforeground	=> $def_ety{-selectforeground},
	-relief			=> $def_ety{-relief},
	);
my %def_HL		= (	# List
#-fg -font -12 -gap -header -height -highlightbackground -highlightcolor -highlightthickness -indent -indicator -indicatorcmd -itemtype -padx -pady -relief -selectbackground -selectborderwidth -selectforeground -selectmode -separator -sizecmd -takefocus -wideselection -width -xscrollcommand -yscrollcommand
	-highlightthickness	=> 0,	# No border showing when entering the table
	-header			=> 1,	# Shows main headers
	-selectmode		=> "single",
	-relief			=> $def_rel,
	-borderwidth		=> 0,
	-selectforeground	=> "#c9c9c9",
	-selectbackground	=> "#2b2b2b",
	-foreground		=> $def_fg_hex,
	-background		=> $def_bg_hex,
	);
my %def_Header		= (	# HList header
	-headerbackground	=> $def_bg_hex,
	-relief			=> "ridge", 
	);
my %def_TL		= (	# Toplevel widgets
	-background		=> $def_bg_hex,
	-title			=> $app_name,
	);

## Misc
#my $debug_file		= (fileparse($0))[1] . "esiR_debug.log";
my $debug_file		= "/tmp/esiR_debug.log";
my $debug_mode		=  0;
my $finite_counter	=  0;
my $help		=  0;
my $max_age_all		= 0.125;	# days		# checked on startup (4 h)
my $min_age_all		= 20;		# minutes	# for button release
my $max_age_markets	= 60;		# minutes	# checked on startup
my $min_age_markets	=  5;		# minutes	# for button release
my $max_age_add_to_del	= 13;		# days; $max_age_all + $max_age_add_to_del → delete entries
my $profile		=  0;
my $speedup		=  0;
my $run_setup		=  0;		# to add another user


### Initalize
GetOptions(
	'd|debug'	=> \$debug_mode,
	#'two|speedup'	=> \$speedup,
	'D|database=s'	=> \$database,
	'p|profiles'	=> \$profile,
	'h|help'	=> \$help,
	) or die qq{Try "$0 --help"!\n};

# Help & debug
# First debugging information
if ( $debug_mode ) {
	print STDERR "Debug log file: \"$debug_file\"\n";
	&debug_out("main():\n",
		"Debug log file		=: \"$debug_file\"",
		"Login server base url		=: \"$lsburl\"",
		"Scopes			=: \"@scopes\"",
		"cURL path			=: \"$cURL\"",
		"Database path			=: \"$database\"",
		);
	}
&helper();

## Start program
# If started and set up there must be the database

if ( !$cURL ) {
	&err_msg(
		0,
		$MainTitle,
		"Can't find curl in \$PATH!",
		);
	}
elsif ( !$pgrep ) {
	&err_msg(
		0,
		$MainTitle,
		"Can't find pgrep in \$PATH!",
		);
	}
# If database exists, but is not writable
elsif ( -s $database && !-W $database ) {
	&err_msg(
		1,
		$MainTitle,
		"Database \"$database\" is write protected.",
		);
	}
# If database not exists, and target directory is not writable
elsif ( !-s $database && -d (fileparse($database))[1] && !-w (fileparse($database))[1] ) {
	&err_msg(
		2,
		$MainTitle,
		"Containing folder \"" . (fileparse($database))[1] . "\" is write protected.",
		);
	}
# If containing directory is not even readable
elsif ( -d (fileparse($database))[1] && ( !-R (fileparse($database))[1] || !-X (fileparse($database))[1] ) ) {
	&err_msg(
		3,
		$MainTitle,
		"Can't access \"" . (fileparse($database))[1] . "\"",
		);
	}
## Start program

# Start with table view if database exists
elsif ( -s $database ) {
	# Complete DSN
	$dsn			.= $database;

	&check_version() or exit(50);

	# Update agent
	my $update_agent	= fork;
	# Parent
	if ( defined($update_agent) && $update_agent ) {
		push(@childs, $update_agent);
		&debug_out("main(): Started update agent $update_agent");
		}
	# Child
	elsif ( defined($update_agent) ) {
		srand();

		# Connection to main program (%transport) IPC
		my $ac_knot		= tie(my %agent_carrier, 'IPC::Shareable', $transID);

		## Main update agent
		my @agency	= ();	# Agents (forks)
		my $perc_count	=  0;
		my $started_as	= "";
		my $old_st_as	= "";
		my $token_fc	=  0;
		my $recID	= &gen_random(4);	# IPC key as $transID, but only visible for childs of the update agent
		# Separate transfer array for agents (sub-forks of fork)
		my $char_id	=  0;
		my $update_knot	= tie(my @receiver, 'IPC::Shareable', $recID, {
			create	=> 1,
			mode	=> 0600,
			destroy	=> 1,
			size	=> IPC::Shareable::SHM_BUFSIZ(),
			#size	=> 131072 * 2,
			});

		## Markets update agents (mua) (for run_update == perm)
		# (Re-)initializing
		my $mua_init			=  1;
		my $mua_all_ran			=  0;
		my $mua_circle_primary		=  0;
		my $mua_circle_not_primary	=  0;
		my $mua_circle_structures	=  0;
		my $mua_started_something	=  0;
		my %time			= (
			primary			=> time,
			non_primary		=> time,
			structures		=> time,
			);

		# Static lists from database
		my @mua_static_primary		= ();
		my @mua_static_not_primary	= ();
		my @mua_static_structures	= ();

		# Working lists
		my @mua_primary			= ();
		my @mua_not_primary		= ();
		my @mua_structures		= ();

		# Known locations (and types)
		my %mua_known_stations		= ();
		my %mua_known_structures	= ();
		my %mua_known_systems		= ();
		my %mua_known_constellations	= ();
		my %mua_known_types		= ();

		# Special agents lists (forking)
		my %mua_p_agents		= ();
		my %mua_np_agents		= ();
		my %mua_s_agents		= ();

		# Process handling
		my $_sub_cprop_exit	= sub {

			# Inform children
			foreach my $child ( @agency ) {
				&debug_out("_sub_cprop_exit(): Ask $child to hang up");
				# Ask if child is still living
				if ( kill(0 => $child) ) {
					kill(INT => $child);
					}
				}

			&wait_children(0, \@agency, 60);

			&cprop_exit();
			};

		local $SIG{INT}		= $_sub_cprop_exit;
		local $SIG{HUP}		= $_sub_cprop_exit;

		# Array to store what was transfered through @receiver, because IPC-tied arrays are very small (round about 300 elements only)
		my @storage	= ();
		# Transfer child elements to @storage
		my $_sub_gatherer	= sub {
			my $allowed_childs	= shift;
			if ( &wait_children($allowed_childs, \@agency) ) {
				my $knot	= tie(my @cleaner, 'IPC::Shareable', $recID);
				$knot->shlock;
				push(@storage, @cleaner);
				@cleaner	= ();
				$knot->shunlock;
				return(1);
				}
			return(0);
			};

		my $_sub_percent_base	= sub {
			my $helper	= "";
			if ( $old_st_as	eq "" ) {
				$old_st_as	= $started_as;
				$helper		= $started_as;
				}
			else {
				$helper		= $old_st_as;
				}

			if ( $helper eq "markets" ) {
				return(270);		# 270p
				}
			elsif ( $helper eq "all" ) {
				return(570);		# 300p + 270p
				}
			elsif ( $helper eq "start+all" ) {
				return(600);		# 30p + 300p + 270p
				}
			elsif ( $helper eq "start+markets" ) {
				return(300);		# 30p + 270p
				}
			else {	# start
				return(30);		# 30p
				}
			};

		# Make array of JSON strings to one proper JSON string
		my $_sub_merge_json	= sub {
			my @list	= @_;
			my $string	= "";

			# List is array
			if ( $list[0] =~ m/^\[/ && $list[-1] =~ m/\]$/ ) {
				$string	= join("", @list);
				$string	=~ s/\[\s*\]//g;
				$string	=~ s/\]\[/,/g;
				}
			# List is hash
			elsif ( $list[0] =~ m/^\{/ && $list[-1] =~ m/\}$/ ) {
				$string = "[" . join(",", @list) . "]";
				}
			else {
				&debug_out("_sub_merge_json(): Can't destungish JSON data");
				return("");
				}

			return($string);
			};

		## Update access token if needed
		my($_sub_update_access_token);		# Needed for nesting
		$_sub_update_access_token		= sub {
			my $current_time		= time;
			$ac_knot->shlock;
			my $CharID			= $agent_carrier{CharacterID};	# spearate variable really needed? yes, because of forking and changing at the very beginning
			$ac_knot->shunlock;
			my $char_details		= [ &access_DB(
				"SELECT app_client_id, app_secret_key, token_refresh, token_access, token_acc_duration, token_acc_time\n" .
				"  FROM characters\n" .
				"  WHERE id == " . &quote_DB($CharID) . ";",
				) ];

			# Make sure qx() is working properly
			local $SIG{CHLD}	= "DEFAULT";
			local $SIG{CLD}		= "DEFAULT";

			# If now is later as five minutes before the access token expires request a new one
			if ( scalar(@{$char_details}) == 1 && ref($char_details->[0]) && $current_time > ( $char_details->[0]->{token_acc_duration} - 60 * 5 + $char_details->[0]->{token_acc_time} ) ) {
				$char_details		= $char_details->[0];
				my $cmd			= "$cURL " .
					"$cURL_options " .
					"-XPOST " .
					"-H \"Content-Type:application/json\" " .
					"-H \"Authorization:Basic " .
					encode_base64("$char_details->{app_client_id}:$char_details->{app_secret_key}", '') . "\" " .
					"-d '{\"grant_type\":\"refresh_token\", " .
					"\"refresh_token\":\"$char_details->{token_refresh}\"}' " .
					"${lsburl}/oauth/token";
				&debug_out(
					"_sub_update_access_token(): Refreshing access token...",
					$cmd,
					);
				chomp(my $current_data	= qx($cmd));
				my $return_code		= ( $? >> 8 );

				&debug_out(
					"_sub_update_access_token(): cURL exited with $return_code",
					"_sub_update_access_token(): Got data: $current_data",
					);

				if ( $return_code ) {
					&debug_out("_sub_update_access_token(): WARNING: cURL failed, update canceled!");
					$ac_knot->shlock;
					$agent_carrier{run_update}	= "";
					$ac_knot->shunlock;
					$token_fc	= 0;
					return(0);
					}

				$current_data	= &test_json($current_data);

				if ( !$current_data ) {
					if ( $token_fc++ <= 100 ) {
						&debug_out("_sub_update_access_token(): Can't download data, restarting...");
						sleep(0.6);
						return(&{$_sub_update_access_token}());
						}
					else {
						$token_fc	= 0;
						&debug_out("_sub_update_access_token(): Download failed");
						return(0);
						}
					}
				else {
					&access_DB(
						"UPDATE characters\n" .
						"SET " .
						"  token_access = " . &quote_DB($current_data->{access_token}) . ", " .
						"  token_acc_duration = " . &quote_DB($current_data->{expires_in}) . ", " .
						"  token_refresh = " . &quote_DB($current_data->{refresh_token}) . ", " .
						"  token_acc_time = " . &quote_DB($current_time) . "\n" .
						"WHERE id == " . &quote_DB($CharID) . ";",
						);
					$token_fc	= 0;
					return(1);
					}
				}
			elsif ( ! ref($char_details->[0]) ) {
				if ( $token_fc++ <= 100 ) {
					&debug_out("_sub_update_access_token(): Can't distungish database data, restarting...");
					sleep(0.6);
					return(&{$_sub_update_access_token}());
					}
				else {
					$token_fc	= 0;
					&debug_out("_sub_update_access_token(): Failed to gain database data within 60 seconds");
					return(0);
					}
				}
			else {
				$token_fc	= 0;
				return(1);
				}
			};

		my $_sub_build_locations_tree_upwards	= sub {
			my $system_id		= shift;

			if ( ! exists($mua_known_systems{$system_id}) ) {
				my @system_matches	= &access_DB(qq{SELECT id FROM locations_systems WHERE id == } . &quote_DB($system_id) . qq{ ;});

				if ( ! @system_matches ) {
					my %system_data	= &downloader(0, "/universe/systems/$system_id");

					if ( ! exists($mua_known_constellations{$system_data{constellation_id}}) ) {
						my @const_matches	= &access_DB(qq{SELECT id FROM locations_constellations WHERE id == } . &quote_DB($system_data{constellation_id}) . qq{ ;});

						if ( ! @const_matches ) {
							my %constellation_data	= &downloader(0, "/universe/constellations/$system_data{constellation_id}/");

							if ( defined($constellation_data{constellation_id}) && $constellation_data{constellation_id}
							 && defined($constellation_data{name}) && $constellation_data{name} ) {
								&access_DB("REPLACE INTO locations_constellations ( id, name, region_id ) VALUES ( " .
									&quote_DB($constellation_data{constellation_id}) . " , " .
									&quote_DB($constellation_data{name}) . " , " .
									&quote_DB($constellation_data{region_id}) .
									" );");
								}
							}
						$mua_known_constellations{$system_data{constellation_id}}	= undef;
						}

					if ( defined($system_data{system_id}) && $system_data{system_id} && defined($system_data{name}) && $system_data{name} ) {
						&access_DB("REPLACE INTO locations_systems ( id, name, security_status, security_class, constellation_id ) VALUES ( " .
							&quote_DB($system_data{system_id}) . " , " .
							&quote_DB($system_data{name}) . " , " .
							&quote_DB($system_data{security_status}) . " , " .
							&quote_DB($system_data{security_class}) . " , " .
							&quote_DB($system_data{constellation_id}) .
							" );");
						}

					if ( defined($system_data{stargates}) && ref($system_data{stargates}) ) {
						my $added		= 0;

						foreach my $stargate_id ( @{$system_data{stargates}} ) {
							my %stargate_data	= &downloader(0, "/universe/stargates/$stargate_id/");

							if ( defined($stargate_data{stargate_id}) && $stargate_data{stargate_id} && defined($stargate_data{name}) && $stargate_data{name} ) {
								$added		= 1;
								&access_DB("REPLACE INTO locations_stargates ( id, system_id, neighbour_id ) VALUES ( " .
									&quote_DB($stargate_data{stargate_id}) . " , " .
									&quote_DB($stargate_data{system_id}) . " , " .
									&quote_DB($stargate_data{destination}->{system_id}) .
									" );");
									}
							}

						if ( $added ) {
							&access_DB(qq{UPDATE characters SET done_jumps = } . &quote_DB(0) . qq{ ;});	# For ALL characters!
							}
						}
					}

				$mua_known_systems{$system_id}	= undef;
				}
			return(1);
			};

		my $_sub_clarify_missing_locations	= sub {
			my @orders			= @_;
			my @missing_types		= ();
			my @missing_stations		= ();
			my @missing_structures		= ();

			foreach my $row ( @orders ) {
				if ( ! exists($mua_known_types{$row->{type_id}}) ) {
					push(@missing_types, $row->{type_id});
					}

				if ( &is_ccp_station($row->{location_id}) ) {
					if ( ! exists($mua_known_stations{$row->{location_id}}) ) {
						push(@missing_stations, $row->{location_id});
						}
					}
				else {
					if ( ! exists($mua_known_structures{$row->{location_id}}) ) {
						push(@missing_structures, $row->{location_id});
						}
					}
				}

			@missing_structures	= &make_unique(@missing_structures);
			foreach my $id ( @missing_structures ) {
				my @matches	= &access_DB(qq{SELECT id           FROM locations_structures WHERE           id == } . &quote_DB($id) . qq{ AND character_id == } . &quote_DB($char_id) . " ;");
				my @denies	= &access_DB(qq{SELECT structure_id FROM denied_structures    WHERE structure_id == } . &quote_DB($id) . qq{ AND character_id == } . &quote_DB($char_id) . " ;");

				# If not added to known structures list
				if ( @matches ) {
					$mua_known_structures{$id}	= undef;
					}
				# And not in denied structures list
				elsif ( ! @denies ) {
					# We need to download it
					my %structure_data	= &downloader(1, "/universe/structures/$id/");

					if ( defined($structure_data{name}) && $structure_data{name} ) {

						&{$_sub_build_locations_tree_upwards}($structure_data{solar_system_id});

						&access_DB("REPLACE INTO locations_structures ( id, name, solar_system_id, character_id ) VALUES ( " .
							&quote_DB($id) . " , " .
							&quote_DB($structure_data{name}) . " , " .
							&quote_DB($structure_data{solar_system_id}) . " , " .
							&quote_DB($char_id) .
							" );");

						# Was added to database
						$mua_known_structures{$id}	= undef;
						}
					elsif ( $structure_data{fail} == 403 ) {
						&access_DB("REPLACE INTO denied_structures ( structure_id, character_id ) VALUES ( " .
							&quote_DB($id) . " , " .
							&quote_DB($char_id) .
							" );");
						}
					}

				}
			@missing_structures	= ();

			@missing_stations	= &make_unique(@missing_stations);
			foreach my $id ( @missing_stations ) {
				my @matches	= &access_DB(qq{SELECT id FROM locations_stations WHERE id == } . &quote_DB($id) . qq{ ;});

				# If not added to database already
				if ( ! @matches ) {
					my %station_data = &downloader(0, "/universe/stations/$id/");

					if ( defined($station_data{station_id}) && $station_data{station_id} && defined($station_data{name}) && $station_data{name} ) {

						&{$_sub_build_locations_tree_upwards}($station_data{system_id});

						&access_DB("REPLACE INTO locations_stations ( id, name, system_id ) VALUES ( " .
							&quote_DB($station_data{station_id}) . " , " .
							&quote_DB($station_data{name}) . " , " .
							&quote_DB($station_data{system_id}) .
							" );");
						}
					}

				$mua_known_stations{$id}	= undef;
				}
			@missing_stations	= ();

			@missing_types		= &make_unique(@missing_types);
			foreach my $id ( @missing_types ) {
				my @matches	= &access_DB(qq{SELECT id FROM types WHERE id == } . &quote_DB($id) . qq{ ;});

				# If not added to database already
				if ( ! @matches ) {
					my %type_data	= &downloader(0, "/universe/types/$id");

					if ( defined($type_data{type_id}) && $type_data{type_id} && defined($type_data{name}) && $type_data{name} ) {
						&access_DB("REPLACE INTO types (id, name, volume, packaged_volume, capacity, mass) VALUES ( " .
							&quote_DB($type_data{type_id}) . " , " .
							&quote_DB($type_data{name}) . " , " .
							&quote_DB($type_data{volume}) . " , " .
							&quote_DB($type_data{packaged_volume}) . " , " .
							&quote_DB($type_data{capacity}) . " , " .
							&quote_DB($type_data{mass}) .
							" );");
						}
					}

				$mua_known_types{$id}	= undef;
				}
			@missing_types		= ();

			return(1);
			};

		update_agent:
		while ( kill(0 => $ppid) ) {	# Live as long as the parent does...

			$ac_knot->shlock;
			if ( $agent_carrier{run_update} eq "perm" ) {
				$char_id		= $agent_carrier{CharacterID};
				$ac_knot->shunlock;

				if ( $mua_init || $mua_all_ran ) {
					$mua_init	= 0;

					# Fill mua_static arrays
					@mua_static_primary		= &access_DB("SELECT id FROM locations_regions WHERE name     IN ( 'The Forge' , 'Domain' , 'Sinq Laison' , 'Metropolis' ) ORDER BY id ;");
					@mua_static_not_primary		= &access_DB("SELECT id FROM locations_regions WHERE name NOT IN ( 'The Forge' , 'Domain' , 'Sinq Laison' , 'Metropolis' ) ORDER BY id ;");
					@mua_static_structures		= &access_DB("SELECT id FROM locations_structures ls WHERE character_id == " . &quote_DB($char_id) . " AND id NOT IN ( SELECT structure_id FROM denied_structures_markets WHERE character_id == " . &quote_DB($char_id) . " ) ORDER BY ls.id ;");

					# Make arrays easier accessable
					foreach my $record ( @mua_static_primary, @mua_static_not_primary, @mua_static_structures ) {
						if ( !ref($record) ) {
							$mua_init	= 1;
							redo(update_agent);
							}
						$record		= $record->{id};
						}
					}

				# Checklists for location_id
				&debug_out("permanent_update_manager(): Building check lists");
				%mua_known_stations		= ();
				%mua_known_structures		= ();
				%mua_known_systems		= ();
				%mua_known_constellations	= ();
				%mua_known_types		= ();
				foreach my $record ( &access_DB("SELECT ss_id, ss_variety, sys_id, const_id FROM locations_indices ;") ) {
					if ( $record->{ss_variety} eq "station" ) {
						$mua_known_stations{$record->{ss_id}}	= undef;
						}
					#elsif ( $record->{ss_variety} eq "structure" ) {}
					else {
						$mua_known_structures{$record->{ss_id}}	= undef;
						}

					$mua_known_systems{$record->{sys_id}}		= undef;
					$mua_known_constellations{$record->{const_id}}	= undef;
					}

				# Checklists for type_id
				foreach my $record ( &access_DB("SELECT id FROM types ;") ) {
					$mua_known_types{$record->{id}}			= undef;
					}

				# Fill dynamic arrays
				if ( ! @mua_primary ) {
					&debug_out("permanent_update_manager(): Filling primary list");
					@mua_primary		= @mua_static_primary;
					}
				if ( ! @mua_not_primary ) {
					&debug_out("permanent_update_manager(): Filling not primary list");
					@mua_not_primary	= @mua_static_not_primary;
					}
				if ( ! @mua_structures ) {
					&debug_out("permanent_update_manager(): Filling structures list");
					@mua_structures		= @mua_static_structures;
					}

				# Nonblocking process handler
				my $_sub_cc_children	= sub {		# cc = clean & count
					my $children	= shift;

					@agency		= grep { kill(0 => $_) } @agency;		# Keep agency up to date

					if ( ! %{$children} ) {
						return(0);
						}
					else {
						foreach my $key ( keys(%{$children}) ) {
							if ( !( kill(0 => $children->{$key}) ) ) {
								delete($children->{$key});
								}
							}
						&debug_out("_sub_cc_children(): " . scalar(keys(%{$children})) . " children left");
						return(scalar(keys(%{$children})));
						}
					};

				# Primary
				primary:
				for ( my $agent_count = &{$_sub_cc_children}(\%mua_p_agents) ; $agent_count < 3 && @mua_primary ; $agent_count++ ) {		# former 2 agents
					my $region	= shift(@mua_primary);

					if ( defined($mua_p_agents{$region}) && kill(0 => $mua_p_agents{$region}) ) {
						&debug_out("permanent_update_manager(): Region $region is already beeing updated by agent $mua_p_agents{$region}");
						next(primary);
						}
					else {
						$mua_started_something	= 1;
						}

					my $agent	= fork;

					# Parent
					if ( defined($agent) && $agent ) {
						push(@agency, $agent);
						$mua_p_agents{$region}	= $agent;
						&debug_out("permanent_update_manager(): started primary market agent $agent for region $region");
						Time::HiRes::sleep(0.01);
						}
					# Child
					elsif ( defined($agent) ) {
						srand();
						local $SIG{INT}			= "DEFAULT";
						local $SIG{HUP}			= "DEFAULT";
						my $adb_knot			= tie(my %agent_delivery_boy, 'IPC::Shareable', $transID);
						my @region_sell_orders		= &downloader(0, "/markets/$region/orders", { order_type => "sell", });		# returns a array of hashes	# false
						my @region_buy_orders		= &downloader(0, "/markets/$region/orders", { order_type => "buy", });		# returns a array of hashes	# true
						# Regions are tested separatly by the initiation!

						&{$_sub_clarify_missing_locations}(@region_sell_orders, @region_buy_orders);

						#if ( @region_sell_orders || @region_buy_orders ) {

							my($_sub_seperate_insert);
							my $_sub_stop_on_create = sub {
								&debug_out("_sub_stop_on_create(): $DBI::errstr");
								kill(HUP => $ppid);
								$adb_knot->shlock;
								$agent_delivery_boy{error_stmt}		= $DBI::errstr;			# Report about error in statement
								$adb_knot->shunlock;
								&db_token(0);
								return(0);
								};

							# Open seperate DB handle
							&db_token(1);
							local $SIG{INT}		= "IGNORE";
							local $SIG{HUP}		= "IGNORE";
							my $dbh_seperate	= DBI->connect(
								$dsn,
								$user_id,
								$password,
								{
									RaiseError	=> 0,
									AutoCommit	=> 1,
									#ReadOnly	=> 0,
									},
								) or do {
									&{$_sub_stop_on_create}();
									return(0);
									};
							my $current_insert	= 0;

							$dbh_seperate->do("PRAGMA foreign_keys = ON;") or do {
								&debug_out("orders_update_agent(): Can't enforce foreign keys: " . $dbh_seperate->errstr);
								#$dbh_seperate->commit();
								$dbh_seperate->disconnect();
								&db_token(0);
								return(0);
								};

#=begin problem1
							$dbh_seperate->do("PRAGMA journal_mode = MEMORY;") or do {
								&debug_out("orders_update_agent(): Can't set journal mode to memory: " . $dbh_seperate->errstr);
								#$dbh_seperate->commit();
								$dbh_seperate->disconnect();
								&db_token(0);
								return(0);
								};
#=end problem1
#=cut

							# Station orders' prepare
							my $sth_sta_orders	= $dbh_seperate->prepare(
								"REPLACE INTO orders_stations " .  
								"(id, " .
								"volume_total, " .
								"volume_remain, " .
								"min_volume, " .
								"price, " .
								"duration, " .
								"issued, " .
								"range, " .
								"is_buy_order, " .
								"type_id, " .
								"location_id)\n" .
								# no column character_id
								"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"
								);

							# Structure orders' prepare
							my $sth_str_orders	= $dbh_seperate->prepare(
								"REPLACE INTO orders_structures " .  
								"(id, " .
								"volume_total, " .
								"volume_remain, " .
								"min_volume, " .
								"price, " .
								"duration, " .
								"issued, " .
								"range, " .
								"is_buy_order, " .
								"type_id, " .
								"location_id, " .
								"character_id)\n" .	# $char_id
								"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"
								);

							do_delete1:
							while ( 1 ) {
								$dbh_seperate->do("DELETE FROM orders_stations WHERE location_id IN ( " .
									"SELECT ss_id FROM locations_indices WHERE region_id == " . &quote_DB($region) . " AND ss_variety == " . &quote_DB("station") . " ) ;") or print STDERR $dbh_seperate->errstr . " - going to retry";
								if ( defined($dbh_seperate->errstr) && $dbh_seperate->errstr =~ m/[Dd]atabase is locked/s ) {	# /s include \n
									my $return_text	= $dbh_seperate->errstr;
									&debug_out(qq{DELETE1 failed, will retry; $return_text});

									Time::HiRes::sleep(0.015);
									}
								else {
									last(do_delete1);
									}
								}

							# Station orders' execute
							&debug_out("orders_update_agent(): Inserting station orders");
							$dbh_seperate->begin_work();
							foreach my $order ( @region_sell_orders ) {
								if ( ref($order) && defined($order->{order_id}) && $order->{order_id}
							 	&& defined($order->{price}) && $order->{price}
							 	&& defined($order->{is_buy_order})
							 	&& defined($order->{location_id}) && $order->{location_id}
							 	&& defined($order->{volume_total}) && $order->{volume_total}
							 	&& defined($order->{volume_remain}) && $order->{volume_remain}
							 	&& ( exists($mua_known_stations{$order->{location_id}}) || exists($mua_known_structures{$order->{location_id}}) )
							 	) {
									#&debug_out("orders_update_agent(): Order $order->{order_id} is " . ( ( &quote_DB($order->{is_buy_order}) ) ? "buy" : "sell" ) . qq{ order - quote_DB() returns "} . &quote_DB($order->{is_buy_order}) . qq{" from "$order->{is_buy_order}"});
									if ( &is_ccp_station($order->{location_id}) ) {	# Station
										$sth_sta_orders->execute(
											$order->{order_id},
											$order->{volume_total},
											$order->{volume_remain},
											$order->{min_volume},
											$order->{price},
											$order->{duration},
											$order->{issued},
											$order->{range},
											0,				# is_buy_order
											$order->{type_id},
											$order->{location_id},
											) or print STDERR "orders_update_agent(): order_id = $order->{order_id}, FK type_id = $order->{type_id}, FK location_id = $order->{location_id} returned: " . $sth_sta_orders->errstr;
										}
									else {						# Structure
										$sth_str_orders->execute(
											$order->{order_id},
											$order->{volume_total},
											$order->{volume_remain},
											$order->{min_volume},
											$order->{price},
											$order->{duration},
											$order->{issued},
											$order->{range},
											0,				# is_buy_order
											$order->{type_id},
											$order->{location_id},
											$char_id,
											) or print STDERR "orders_update_agent(): order_id = $order->{order_id}, FK type_id = $order->{type_id}, FK location_id = $order->{location_id} returned: " . $sth_sta_orders->errstr;
										}
									}
								}

							# Structure orders' execute
							&debug_out("orders_update_agent(): Inserting structure orders");
							foreach my $order ( @region_buy_orders ) {
								if ( ref($order) && defined($order->{order_id}) && $order->{order_id}
							 	&& defined($order->{price}) && $order->{price}
							 	&& defined($order->{is_buy_order})
							 	&& defined($order->{location_id}) && $order->{location_id}
							 	&& defined($order->{volume_total}) && $order->{volume_total}
							 	&& defined($order->{volume_remain}) && $order->{volume_remain}
							 	&& ( exists($mua_known_stations{$order->{location_id}}) || exists($mua_known_structures{$order->{location_id}}) )
							 	) {
									#&debug_out("orders_update_agent(): Order $order->{order_id} is " . ( ( &quote_DB($order->{is_buy_order}) ) ? "buy" : "sell" ) . qq{ order - quote_DB() returns "} . &quote_DB($order->{is_buy_order}) . qq{" from "$order->{is_buy_order}"});
									if ( &is_ccp_station($order->{location_id}) ) {	# Station 
										$sth_sta_orders->execute(
											$order->{order_id},
											$order->{volume_total},
											$order->{volume_remain},
											$order->{min_volume},
											$order->{price},
											$order->{duration},
											$order->{issued},
											$order->{range},
											1,				# is_buy_order
											$order->{type_id},
											$order->{location_id},
											) or print STDERR "orders_update_agent(): order_id = $order->{order_id}, FK type_id = $order->{type_id}, FK location_id = $order->{location_id} returned: " . $sth_sta_orders->errstr;
										}
									else {						# Structure
										$sth_str_orders->execute(
											$order->{order_id},
											$order->{volume_total},
											$order->{volume_remain},
											$order->{min_volume},
											$order->{price},
											$order->{duration},
											$order->{issued},
											$order->{range},
											1,				# is_buy_order
											$order->{type_id},
											$order->{location_id},
											$char_id,
											) or print STDERR "orders_update_agent(): order_id = $order->{order_id}, FK type_id = $order->{type_id}, FK location_id = $order->{location_id} returned: " . $sth_sta_orders->errstr;}
									}
								}

							$dbh_seperate->commit();
							$dbh_seperate->disconnect();
							&db_token(0);
							#}
						exit(0);
						}
					# Failure
					else {
						&debug_out("permanent_update_manager(): Can't fork");
						&pprop_exit();
						}
					}

				# Not primary
				not_primary:
				for ( my $agent_count = &{$_sub_cc_children}(\%mua_np_agents) ; $agent_count < 5 && @mua_not_primary ; $agent_count++ ) {	# former 4 agents
					my $region	= shift(@mua_not_primary);

					if ( defined($mua_np_agents{$region}) && kill(0 => $mua_np_agents{$region}) ) {
						&debug_out("permanent_update_manager(): Region $region is already beeing updated by agent $mua_np_agents{$region}");
						next(not_primary);
						}
					else {
						$mua_started_something	= 1;
						}

					my $agent	= fork;

					# Parent
					if ( defined($agent) && $agent ) {
						push(@agency, $agent);
						$mua_np_agents{$region}	= $agent;
						&debug_out("permanent_update_manager(): started not primary market agent $agent");
						Time::HiRes::sleep(0.01);
						}
					# Child
					elsif ( defined($agent) ) {
						srand();
						local $SIG{INT}		= "DEFAULT";
						local $SIG{HUP}		= "DEFAULT";
						my $adb_knot		= tie(my %agent_delivery_boy, 'IPC::Shareable', $transID);
						my @region_sell_orders	= &downloader(0, "/markets/$region/orders", { order_type => "sell", });		# returns a array of hashes	# false
						my @region_buy_orders	= &downloader(0, "/markets/$region/orders", { order_type => "buy", });		# returns a array of hashes	# true

						&{$_sub_clarify_missing_locations}(@region_sell_orders, @region_buy_orders);

						#if ( @region_sell_orders || @region_buy_orders ) {

							my($_sub_seperate_insert);
							my $_sub_stop_on_create = sub {
								&debug_out("_sub_stop_on_create(): $DBI::errstr");
								kill(HUP => $ppid);
								$adb_knot->shlock;
								$agent_delivery_boy{error_stmt}		= $DBI::errstr;			# Report about error in statement
								$adb_knot->shunlock;
								&db_token(0);
								return(0);
								};

							# Open seperate DB handle
							&db_token(1);
							local $SIG{INT}		= "IGNORE";
							local $SIG{HUP}		= "IGNORE";
							my $dbh_seperate	= DBI->connect(
								$dsn,
								$user_id,
								$password,
								{
									RaiseError	=> 0,
									AutoCommit	=> 1,
									#ReadOnly	=> 0,
									},
								) or do {
									&{$_sub_stop_on_create}();
									return(0);
									};
							my $current_insert	= 0;

							$dbh_seperate->do("PRAGMA foreign_keys = ON;") or do {
								&debug_out("orders_update_agent(): Can't enforce foreign keys: " . $dbh_seperate->errstr);
								#$dbh_seperate->commit();
								$dbh_seperate->disconnect();
								&db_token(0);
								return(0);
								};

#=begin problem2
							$dbh_seperate->do("PRAGMA journal_mode = MEMORY;") or do {
								&debug_out("orders_update_agent(): Can't set journal mode to memory: " . $dbh_seperate->errstr);
								#$dbh_seperate->commit();
								$dbh_seperate->disconnect();
								&db_token(0);
								return(0);
								};
#=end problem2
#=cut

							# Station orders' prepare
							my $sth_sta_orders	= $dbh_seperate->prepare(
								"REPLACE INTO orders_stations " .  
								"(id, " .
								"volume_total, " .
								"volume_remain, " .
								"min_volume, " .
								"price, " .
								"duration, " .
								"issued, " .
								"range, " .
								"is_buy_order, " .
								"type_id, " .
								"location_id)\n" .
								# no column character_id
								"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"
								);

							# Structure orders' prepare
							my $sth_str_orders	= $dbh_seperate->prepare(
								"REPLACE INTO orders_structures " .  
								"(id, " .
								"volume_total, " .
								"volume_remain, " .
								"min_volume, " .
								"price, " .
								"duration, " .
								"issued, " .
								"range, " .
								"is_buy_order, " .
								"type_id, " .
								"location_id, " .
								"character_id)\n" .	# $char_id
								"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"
								);

							do_delete2:
							while ( 1 ) {
								$dbh_seperate->do("DELETE FROM orders_stations WHERE location_id IN ( " .
									"SELECT ss_id FROM locations_indices WHERE region_id == " . &quote_DB($region) . " AND ss_variety == " . &quote_DB("station") . " ) ;") or print STDERR $dbh_seperate->errstr . " - going to retry";
								if ( defined($dbh_seperate->errstr) && $dbh_seperate->errstr =~ m/[Dd]atabase is locked/s ) {	# /s include \n
									my $return_text	= $dbh_seperate->errstr;
									&debug_out(qq{DELETE2 failed, will retry; $return_text});

									Time::HiRes::sleep(0.015);
									}
								else {
									last(do_delete2);
									}
								}

							# Station orders' execute
							&debug_out("orders_update_agent(): Inserting station orders");
							$dbh_seperate->begin_work();
							foreach my $order ( @region_sell_orders ) {
								if ( ref($order) && defined($order->{order_id}) && $order->{order_id}
							 	&& defined($order->{price}) && $order->{price}
							 	&& defined($order->{is_buy_order})
							 	&& defined($order->{location_id}) && $order->{location_id}
							 	&& defined($order->{volume_total}) && $order->{volume_total}
							 	&& defined($order->{volume_remain}) && $order->{volume_remain}
							 	&& ( exists($mua_known_stations{$order->{location_id}}) || exists($mua_known_structures{$order->{location_id}}) )
							 	) {
									#&debug_out("orders_update_agent(): Order $order->{order_id} is " . ( ( &quote_DB($order->{is_buy_order}) ) ? "buy" : "sell" ) . qq{ order - quote_DB() returns "} . &quote_DB($order->{is_buy_order}) . qq{" from "$order->{is_buy_order}"});
									if ( &is_ccp_station($order->{location_id}) ) {	# Station
										$sth_sta_orders->execute(
											$order->{order_id},
											$order->{volume_total},
											$order->{volume_remain},
											$order->{min_volume},
											$order->{price},
											$order->{duration},
											$order->{issued},
											$order->{range},
											0,				# is_buy_order
											$order->{type_id},
											$order->{location_id},
											) or print STDERR "orders_update_agent(): order_id = $order->{order_id}, FK type_id = $order->{type_id}, FK location_id = $order->{location_id} returned: " . $sth_sta_orders->errstr;
										}
									else {						# Structure
										$sth_str_orders->execute(
											$order->{order_id},
											$order->{volume_total},
											$order->{volume_remain},
											$order->{min_volume},
											$order->{price},
											$order->{duration},
											$order->{issued},
											$order->{range},
											0,				# is_buy_order
											$order->{type_id},
											$order->{location_id},
											$char_id,
											) or print STDERR "orders_update_agent(): order_id = $order->{order_id}, FK type_id = $order->{type_id}, FK location_id = $order->{location_id} returned: " . $sth_sta_orders->errstr;}
									}
								}

							# Structure orders' execute
							&debug_out("orders_update_agent(): Inserting structure orders");
							foreach my $order ( @region_buy_orders ) {
								if ( ref($order) && defined($order->{order_id}) && $order->{order_id}
							 	&& defined($order->{price}) && $order->{price}
							 	&& defined($order->{is_buy_order})
							 	&& defined($order->{location_id}) && $order->{location_id}
							 	&& defined($order->{volume_total}) && $order->{volume_total}
							 	&& defined($order->{volume_remain}) && $order->{volume_remain}
							 	&& ( exists($mua_known_stations{$order->{location_id}}) || exists($mua_known_structures{$order->{location_id}}) )
							 	) {
									#&debug_out("orders_update_agent(): Order $order->{order_id} is " . ( ( &quote_DB($order->{is_buy_order}) ) ? "buy" : "sell" ) . qq{ order - quote_DB() returns "} . &quote_DB($order->{is_buy_order}) . qq{" from "$order->{is_buy_order}"});
									if ( &is_ccp_station($order->{location_id}) ) {	# Station
										$sth_sta_orders->execute(
											$order->{order_id},
											$order->{volume_total},
											$order->{volume_remain},
											$order->{min_volume},
											$order->{price},
											$order->{duration},
											$order->{issued},
											$order->{range},
											1,				# is_buy_order
											$order->{type_id},
											$order->{location_id},
											) or print STDERR "orders_update_agent(): order_id = $order->{order_id}, FK type_id = $order->{type_id}, FK location_id = $order->{location_id} returned: " . $sth_sta_orders->errstr;
										}
									else {						# Structure
										$sth_str_orders->execute(
											$order->{order_id},
											$order->{volume_total},
											$order->{volume_remain},
											$order->{min_volume},
											$order->{price},
											$order->{duration},
											$order->{issued},
											$order->{range},
											1,				# is_buy_order
											$order->{type_id},
											$order->{location_id},
											$char_id,
											) or print STDERR "orders_update_agent(): order_id = $order->{order_id}, FK type_id = $order->{type_id}, FK location_id = $order->{location_id}, FK character_id = $char_id returned: " . $sth_sta_orders->errstr;}
									}
								}

							$dbh_seperate->commit();
							$dbh_seperate->disconnect();
							&db_token(0);
							#}
						exit(0);
						}
					# Failure
					else {
						&debug_out("permanent_update_manager(): Can't fork");
						&pprop_exit();
						}
					}

				# Structures
				structures:
				for ( my $agent_count = &{$_sub_cc_children}(\%mua_s_agents) ; $agent_count < 1 && @mua_structures ; $agent_count++ ) {
					my $structure	= shift(@mua_structures);

					if ( defined($mua_s_agents{$structure}) && kill(0 => $mua_s_agents{$structure}) ) {
						&debug_out("permanent_update_manager(): Region $structure is already beeing updated by agent $mua_s_agents{$structure}");
						next(structures);
						}
					else {
						$mua_started_something	= 1;
						}

					my $agent	= fork;

					# Parent
					if ( defined($agent) && $agent ) {
						push(@agency, $agent);
						$mua_s_agents{$structure}	= $agent;
						&debug_out("permanent_update_manager(): started structure market agent $agent");
						Time::HiRes::sleep(0.01);
						}
					# Child
					elsif ( defined($agent) ) {
						srand();
						local $SIG{INT}		= "DEFAULT";
						local $SIG{HUP}		= "DEFAULT";
						my $adb_knot			= tie(my %agent_delivery_boy, 'IPC::Shareable', $transID);
						my @structure_sell_orders	= &downloader(1, "/markets/structures/$structure/", { order_type => "sell", });	# false
						my @structure_buy_orders	= ();	# Will be done later to not increase error count unneded	# true

						if ( defined($structure_sell_orders[0]) && $structure_sell_orders[0] eq "fail" && $structure_sell_orders[1] == 403 ) {
							&access_DB("REPLACE INTO denied_structures_markets ( structure_id, character_id, detected ) VALUES ( " .
								&quote_DB($structure) . " , " .
								&quote_DB($char_id) . " , " .
								&quote_DB(time) .
								" );");
							}
						if ( defined($structure_sell_orders[0]) && $structure_sell_orders[0] eq "fail" ) {
							&debug_out("update_structure_orders(): Download of market data for structure $structure failed with HTML code $structure_sell_orders[1]");
							print STDERR "Download of market data for structure $structure failed with HTML code $structure_sell_orders[1]\n";
							}
						else {
							@structure_buy_orders	= &downloader(1, "/markets/structures/$structure/", { order_type => "buy", });	# true

							# Leave if nothing was downloaded
							#if ( !( @structure_sell_orders || @structure_buy_orders ) ) {
								#exit(0);
								#}

							my $_sub_stop_on_create = sub {
								&debug_out( "update_structure_orders(): $DBI::errstr");
								kill(HUP => $ppid);
								$adb_knot->shlock;
								$agent_delivery_boy{error_stmt}		= $DBI::errstr;			# Report about error in statement
								$adb_knot->shunlock;
								&db_token(0);
								return(0);
								};

							# Open seperate DB handle
							&db_token(1);
							local $SIG{INT}		= "IGNORE";
							local $SIG{HUP}		= "IGNORE";
							my $dbh_seperate	= DBI->connect(
								$dsn,
								$user_id,
								$password,
								{
									RaiseError	=> 0,
									AutoCommit	=> 1,
									#ReadOnly	=> 0,
									},
								) or do {
									&{$_sub_stop_on_create}();
									return(0);
									};
							my $current_insert	= 0;

#=begin problem3
							$dbh_seperate->do("PRAGMA journal_mode = MEMORY;") or do {
								&debug_out("orders_update_agent(): Can't set journal mode to memory: " . $dbh_seperate->errstr);
								#$dbh_seperate->commit();
								$dbh_seperate->disconnect();
								&db_token(0);
								return(0);
								};
#=end problem3
#=cut

							# Structure orders' prepare
							my $sth_str_orders	= $dbh_seperate->prepare(
								"REPLACE INTO orders_structures " .  
								"(id, " .
								"volume_total, " .
								"volume_remain, " .
								"min_volume, " .
								"price, " .
								"duration, " .
								"issued, " .
								"range, " .
								"is_buy_order, " .
								"type_id, " .
								"location_id, " .
								"character_id)\n" .
								"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"
								);


							do_delete3:
							while ( 1 ) {
								$dbh_seperate->do("DELETE FROM orders_structures WHERE location_id == " . &quote_DB($structure) . " AND character_id == " . &quote_DB($char_id) . " ;") or print STDERR $dbh_seperate->errstr . " - going to retry";
								if ( defined($dbh_seperate->errstr) && $dbh_seperate->errstr =~ m/[Dd]atabase is locked/s ) {	# /s include \n
									my $return_text	= $dbh_seperate->errstr;
									&debug_out(qq{DELETE3 failed, will retry; $return_text});

									Time::HiRes::sleep(0.015);
									}
								else {
									last(do_delete3);
									}
								}


							# Structure orders' execute
							$dbh_seperate->begin_work();
							foreach my $order ( @structure_sell_orders ) {
								if ( ref($order) && defined($order->{order_id}) && $order->{order_id} &&
							 	defined($order->{price}) && $order->{price} &&
							 	defined($order->{is_buy_order}) &&
								exists($mua_known_structures{$order->{location_id}}) &&
							 	defined($order->{location_id}) && $order->{location_id} ) {
									$sth_str_orders->execute(
										$order->{order_id},
										$order->{volume_total},
										$order->{volume_remain},
										$order->{min_volume},
										$order->{price},
										$order->{duration},
										$order->{issued},
										$order->{range},
										$order->{is_buy_order},			# is_buy_order
										$order->{type_id},
										$order->{location_id},
										$char_id,
										) or &debug_out("update_structure_orders(): " . $sth_str_orders->errstr);
									}
								}

							# Structure orders' execute
							foreach my $order ( @structure_buy_orders ) {
								if ( ref($order) && defined($order->{order_id}) && $order->{order_id} &&
							 	defined($order->{price}) && $order->{price} &&
							 	defined($order->{is_buy_order}) &&
								exists($mua_known_structures{$order->{location_id}}) &&
							 	defined($order->{location_id}) && $order->{location_id} ) {
									$sth_str_orders->execute(
										$order->{order_id},
										$order->{volume_total},
										$order->{volume_remain},
										$order->{min_volume},
										$order->{price},
										$order->{duration},
										$order->{issued},
										$order->{range},
										$order->{is_buy_order},			# is_buy_order
										$order->{type_id},
										$order->{location_id},
										$char_id,
										) or &debug_out("update_structure_orders(): " . $sth_str_orders->errstr);
									}
								}

							$dbh_seperate->commit;
							$dbh_seperate->disconnect;
							&db_token(0);

							$perc_count	+= 4;
							$ac_knot->shlock;
							$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
							$ac_knot->shunlock;
							}

						exit(0);	# always exit forks
						}
					# Failure
					else {
						&debug_out("permanent_update_manager(): Can't fork");
						&pprop_exit();
						}
					}

				# Check cycling round
				if ( ! @mua_primary ) {
					&debug_out("permanent_update_manager(): Primary cycle done after " . ( time - $time{primary} ) . " seconds");
					$time{primary}		= time;
					$mua_circle_primary	= 1;
					}
				if ( ! @mua_not_primary ) {
					&debug_out("permanent_update_manager(): Non-primary cycle done after " . ( time - $time{non_primary} ) . " seconds");
					$time{non_primary}	= time;
					$mua_circle_not_primary	= 1;
					}
				if ( ! @mua_structures ) {
					&debug_out("permanent_update_manager(): Structures cycle done after " . ( time - $time{structures} ) . " seconds");
					$time{structures}	= time;
					$mua_circle_structures	= 1;
					}

				if ( $mua_circle_primary && $mua_circle_not_primary && $mua_circle_structures ) {
					my $finish_time		= time;
					$mua_circle_primary	= 0;
					$mua_circle_not_primary	= 0;
					$mua_circle_structures	= 0;

					# Set last update info as transport
					$ac_knot->shlock;
					$agent_carrier{perma_text}	= localtime($finish_time);
					$ac_knot->shunlock;

					# Set last update info as fork in database
					my $agent	= fork;

					# Parent
					if ( defined($agent) && $agent ) {
						push(@agency, $agent);
						&debug_out("permanent_update_manager(): started character insert agent $agent");
						Time::HiRes::sleep(0.01);
						}
					elsif ( defined($agent) ) {
						srand();
						# This is importent and must not be killed!
						local $SIG{INT}		= "IGNORE";
						local $SIG{HUP}		= "IGNORE";
						&access_DB("UPDATE characters SET last_update_markets = " . &quote_DB($finish_time) . " WHERE id == " . &quote_DB($char_id) . " ;");
						exit(0);
						}
					else {
						&debug_out("permanent_update_manager(): Can't fork");
						&pprop_exit();
						}
					}

				# If any agents were started in this round, we don't need anymore to wait
				if ( $mua_started_something ) {
					$mua_started_something	= 0;
					}
				# If nothing was started, we wait
				else {
					sleep(1);
					}

				&infinite_lock_protector(\@agency, 60);

				} # End of markets update agents

			elsif ( $agent_carrier{run_update} ) { # start, all, markets
				$started_as				= $agent_carrier{run_update};
				$agent_carrier{progress_percent}	= 0.00;
				$agent_carrier{progress_text}		= "Starting...";

				## Update markets
				if ( $agent_carrier{run_update} eq "markets" && $mua_init ) {
					my $current_time	= time;
					my $char_id		= $agent_carrier{CharacterID};	# separate variable really needed? YES
					$ac_knot->shunlock;
					&debug_out("update_agent(): Update for markets was requested");
					my $time_details	= [ &access_DB(
						"SELECT last_update_markets, update_running\n" .
						"FROM characters\n" .
						"WHERE id == " . &quote_DB($char_id) . ";"
						) ];

					# Only make an update if at least 5 minutes are passed since the last update
					if ( scalar(@{$time_details}) == 1 && ref($time_details->[0]) && ( $current_time > ( $time_details->[0]->{last_update_markets} + $min_age_markets * 60 ) || $time_details->[0]->{update_running} ) ) {

						# Remember last update
						&access_DB(
							"UPDATE characters\n" .
							"SET last_update_markets = " . &quote_DB($current_time) . ",\n" .
							"update_running = 2\n" .
							"WHERE id == " . &quote_DB($char_id) . ";"
							);

						## Station markets (from regions)
						# Get station IDs
						my @regions	= &access_DB(
							"SELECT id \n" .
							"FROM locations_regions\n;"
							);

						# Do this now, to prevent SELECT on blocked database
						my @structures		= &access_DB("SELECT ls.id FROM locations_structures ls " .
							" LEFT JOIN denied_structures_markets ds ON ls.id == ds.structure_id AND ds.character_id == " . &quote_DB($char_id) .
							" WHERE ls.character_id == " . &quote_DB($char_id) . " AND ds.structure_id IS NULL ;");

						&access_DB(
							"DELETE\n" .
							"FROM orders_structures\n" .
							"WHERE character_id == " . &quote_DB($char_id) . ";",
							);

						&access_DB(
							"DELETE\n" .
							"FROM orders_stations;",
							);

						$ac_knot->shlock;
						$agent_carrier{progress_text}		= "Updating orders...";
						$ac_knot->shunlock;

##### Station (and some structure) orders (gained by regions)
						&debug_out("Updating " . &human_readable(scalar(@regions)) . " regions orders");
						foreach my $region ( @regions ) {
							my $agent = fork;
							# Parent
							if ( defined($agent) && $agent ) {
								push(@agency, $agent);
								&debug_out("update_station_orders(): Started download agent $agent");
								Time::HiRes::sleep(0.01);
								&wait_children($max_forks, \@agency, 60);	# Prevent from running more than 100 childs at a time (including itself)

								# Report to main window
								$perc_count	+= 162 / scalar(@regions);
								$ac_knot->shlock;
								$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
								$ac_knot->shunlock;
								}
							# Child
							elsif ( defined($agent) ) {
								srand();
								local $SIG{INT}		= "DEFAULT";
								local $SIG{HUP}		= "DEFAULT";
								my $adb_knot		= tie(my %agent_delivery_boy, 'IPC::Shareable', $transID);
								my @region_sell_orders	= &downloader(0, "/markets/$region->{id}/orders", { order_type => "sell", });		# returns a array of hashes	# false
								my @region_buy_orders	= &downloader(0, "/markets/$region->{id}/orders", { order_type => "buy", });		# returns a array of hashes	# true
								# Does /markets/<region_id>/orders return structure orders, too? If so, why is /markets/structures/<structure_id>/ there??
								# Solution: Doing both ways

								if ( @region_sell_orders || @region_buy_orders ) {

									my($_sub_seperate_insert);
									my $_sub_stop_on_create = sub {
										&debug_out("_sub_stop_on_create(): $DBI::errstr");
										kill(HUP => $ppid);
										$adb_knot->shlock;
										$agent_delivery_boy{error_stmt}		= $DBI::errstr;			# Report about error in statement
										$adb_knot->shunlock;
										&db_token(0);
										return(0);
										};

									# Open seperate DB handle
									&db_token(1);
									local $SIG{INT}		= "IGNORE";
									local $SIG{HUP}		= "IGNORE";
									my $dbh_seperate	= DBI->connect(
										$dsn,
										$user_id,
										$password,
										{
											RaiseError	=> 0,
											AutoCommit	=> 1,
											#ReadOnly	=> 0,
											},
										) or do {
											&{$_sub_stop_on_create}();
											return(0);
											};
									my $current_insert	= 0;

									$dbh_seperate->do("PRAGMA foreign_keys = ON;") or do {
										&debug_out("orders_update_agent(): Can't enforce foreign keys: " . $dbh_seperate->errstr);
										#$dbh_seperate->commit();
										$dbh_seperate->disconnect();
										&db_token(0);
										return(0);
										};

#=begin problem4
									$dbh_seperate->do("PRAGMA journal_mode = MEMORY;") or do {
										&debug_out("orders_update_agent(): Can't set journal mode to memory: " . $dbh_seperate->errstr);
										#$dbh_seperate->commit();
										$dbh_seperate->disconnect();
										&db_token(0);
										return(0);
										};
#=end problem4
#=cut

									# Station orders' prepare
									sleep(1);
									my $sth_sta_orders	= $dbh_seperate->prepare(
										"REPLACE INTO orders_stations " .  
										"(id, " .
										"volume_total, " .
										"volume_remain, " .
										"min_volume, " .
										"price, " .
										"duration, " .
										"issued, " .
										"range, " .
										"is_buy_order, " .
										"type_id, " .
										"location_id)\n" .
										# no column character_id
										"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"
										);

									# Structure orders' prepare
									my $sth_str_orders	= $dbh_seperate->prepare(
										"REPLACE INTO orders_structures " .  
										"(id, " .
										"volume_total, " .
										"volume_remain, " .
										"min_volume, " .
										"price, " .
										"duration, " .
										"issued, " .
										"range, " .
										"is_buy_order, " .
										"type_id, " .
										"location_id, " .
										"character_id)\n" .
										"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"
										);

									# Station orders' execute
									&debug_out("orders_update_agent(): Inserting station orders");
									$dbh_seperate->begin_work();
									foreach my $order ( @region_sell_orders ) {
										if ( ! ref($order) && $order eq "fail" ) {
											&debug_out("orders_update_agent(): Download failed");
											next();
											}
										elsif ( ref($order) && defined($order->{order_id}) && $order->{order_id}
									 	&& defined($order->{price}) && $order->{price}
									 	&& defined($order->{is_buy_order})
									 	&& defined($order->{location_id}) && $order->{location_id}
									 	&& defined($order->{volume_total}) && $order->{volume_total}
									 	&& defined($order->{volume_remain}) && $order->{volume_remain}
									 	) {
											#&debug_out("orders_update_agent(): Order $order->{order_id} is " . ( ( &quote_DB($order->{is_buy_order}) ) ? "buy" : "sell" ) . qq{ order - quote_DB() returns "} . &quote_DB($order->{is_buy_order}) . qq{" from "$order->{is_buy_order}"});
											if ( &is_ccp_station($order->{location_id}) ) {	# Station
												$sth_sta_orders->execute(
													$order->{order_id},
													$order->{volume_total},
													$order->{volume_remain},
													$order->{min_volume},
													$order->{price},
													$order->{duration},
													$order->{issued},
													$order->{range},
													0,				# is_buy_order
													$order->{type_id},
													$order->{location_id},
													) or print STDERR "orders_update_agent(): order_id = $order->{order_id}, FK type_id = $order->{type_id}, FK location_id = $order->{location_id} returned: " . $sth_sta_orders->errstr;
												}
											}
										}

									# Structure orders' execute
									&debug_out("orders_update_agent(): Inserting structure orders");
									foreach my $order ( @region_buy_orders ) {
										if ( ref($order) && defined($order->{order_id}) && $order->{order_id}
									 	&& defined($order->{price}) && $order->{price}
									 	&& defined($order->{is_buy_order})
									 	&& defined($order->{location_id}) && $order->{location_id}
									 	&& defined($order->{volume_total}) && $order->{volume_total}
									 	&& defined($order->{volume_remain}) && $order->{volume_remain}
									 	) {
											#&debug_out("orders_update_agent(): Order $order->{order_id} is " . ( ( &quote_DB($order->{is_buy_order}) ) ? "buy" : "sell" ) . qq{ order - quote_DB() returns "} . &quote_DB($order->{is_buy_order}) . qq{" from "$order->{is_buy_order}"});
											if ( &is_ccp_station($order->{location_id}) ) {	# Station
												$sth_sta_orders->execute(
													$order->{order_id},
													$order->{volume_total},
													$order->{volume_remain},
													$order->{min_volume},
													$order->{price},
													$order->{duration},
													$order->{issued},
													$order->{range},
													1,				# is_buy_order
													$order->{type_id},
													$order->{location_id},
													) or print STDERR "orders_update_agent(): order_id = $order->{order_id}, FK type_id = $order->{type_id}, FK location_id = $order->{location_id} returned: " . $sth_sta_orders->errstr;
												}
											}
										}

									# Free foreign keys for insert orders before statisfying
									$dbh_seperate->commit();
									$dbh_seperate->do("PRAGMA foreign_keys = OFF;") or do {
										&debug_out("orders_update_agent(): Can't foreign keys let free: " . $dbh_seperate->errstr);
										&db_token(0);
										return(0);
										};
									$dbh_seperate->begin_work();

									# Station orders' execute
									&debug_out("orders_update_agent(): Inserting station orders");
									foreach my $order ( @region_sell_orders ) {
										if ( ref($order) && defined($order->{order_id}) && $order->{order_id}
									 	&& defined($order->{price}) && $order->{price}
									 	&& defined($order->{is_buy_order})
									 	&& defined($order->{location_id}) && $order->{location_id}
									 	&& defined($order->{volume_total}) && $order->{volume_total}
									 	&& defined($order->{volume_remain}) && $order->{volume_remain}
									 	) {
											#&debug_out("orders_update_agent(): Order $order->{order_id} is " . ( ( &quote_DB($order->{is_buy_order}) ) ? "buy" : "sell" ) . qq{ order - quote_DB() returns "} . &quote_DB($order->{is_buy_order}) . qq{" from "$order->{is_buy_order}"});
											if ( !( &is_ccp_station($order->{location_id}) ) ) {	# Station
												$sth_str_orders->execute(
													$order->{order_id},
													$order->{volume_total},
													$order->{volume_remain},
													$order->{min_volume},
													$order->{price},
													$order->{duration},
													$order->{issued},
													$order->{range},
													0,				# is_buy_order
													$order->{type_id},
													$order->{location_id},
													$char_id
													) or &debug_out("orders_update_agent(): " . $sth_str_orders->errstr);
												}
											}
										}

									# Structure orders' execute
									&debug_out("orders_update_agent(): Inserting structure orders");
									foreach my $order ( @region_buy_orders ) {
										if ( ref($order) && defined($order->{order_id}) && $order->{order_id}
									 	&& defined($order->{price}) && $order->{price}
									 	&& defined($order->{is_buy_order})
									 	&& defined($order->{location_id}) && $order->{location_id}
									 	&& defined($order->{volume_total}) && $order->{volume_total}
									 	&& defined($order->{volume_remain}) && $order->{volume_remain}
									 	) {
											#&debug_out("orders_update_agent(): Order $order->{order_id} is " . ( ( &quote_DB($order->{is_buy_order}) ) ? "buy" : "sell" ) . qq{ order - quote_DB() returns "} . &quote_DB($order->{is_buy_order}) . qq{" from "$order->{is_buy_order}"});
											if ( !( &is_ccp_station($order->{location_id}) ) ) {	# Station
												$sth_str_orders->execute(
													$order->{order_id},
													$order->{volume_total},
													$order->{volume_remain},
													$order->{min_volume},
													$order->{price},
													$order->{duration},
													$order->{issued},
													$order->{range},
													1,				# is_buy_order
													$order->{type_id},
													$order->{location_id},
													$char_id
													) or print STDERR "orders_update_agent(): order_id = $order->{order_id}, FK type_id = $order->{type_id}, FK location_id = $order->{location_id} returned: " . $sth_str_orders->errstr;
												}
											}
										}

									$dbh_seperate->commit();
									$dbh_seperate->disconnect();
									&db_token(0);
									#};
								#&{$_sub_seperate_insert}();
								}
							exit(0);								# always exit forks
							}
						else {
							&debug_out("orders_update_agent(): Can't fork");
							&pprop_exit();
							}
						}

						&wait_children(1, \@agency, 60);

##### Structure orders ##########################
						# Load list of structures from local database (done beforehand, to omit blocked database)

						# DELETE was already done

						if ( @structures && &{$_sub_update_access_token}() ) {
							my $next_at_test	= time + 100;

							&debug_out("Updating " . &human_readable(scalar(@structures)) . " structure markets");
							foreach my $structure_id ( @structures ) {
								$structure_id	= $structure_id->{id};
								my $agent	= fork;

								# Parent
								if ( defined($agent) && $agent ) {
									push(@agency, $agent);
									&debug_out("update_structure_orders(): Started agent $agent");

									Time::HiRes::sleep(0.01);

									&wait_children($max_forks, \@agency, 60);

									# Update nearly all five minutes the access token (_sub_update_access_token ensures at least five minutes left until token gets invalid)
									if ( time >= $next_at_test ) {
										&wait_children(1, \@agency);	# Wait all agents to finish
										&debug_out("structure_markets_updater(): checking access token for update");
										&{$_sub_update_access_token}() or do {
											&debug_out("structure_markets_updater(): Can't update access token!");
											};
										$next_at_test	= time + 100;	# Set next time
										}

									# Report to main window
									$perc_count	+= 70 / scalar(@structures);
									$ac_knot->shlock;
									$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
									$ac_knot->shunlock;
									}
								# Child
								elsif ( defined($agent) ) {
									srand();
									local $SIG{INT}		= "DEFAULT";
									local $SIG{HUP}		= "DEFAULT";
									my $adb_knot			= tie(my %agent_delivery_boy, 'IPC::Shareable', $transID);
									my @structure_sell_orders	= &downloader(1, "/markets/structures/$structure_id/", { order_type => "sell", });	# false
									my @structure_buy_orders	= ();	# Will be done later to not increase error count unneded	# true

									if ( defined($structure_sell_orders[0]) && $structure_sell_orders[0] eq "fail" && $structure_sell_orders[1] == 403 ) {
										&access_DB("REPLACE INTO denied_structures_markets ( structure_id, character_id, detected ) VALUES ( " .
											&quote_DB($structure_id) . " , " .
											&quote_DB($char_id) . " , " .
											&quote_DB(time) .
											" );");
										}
									if ( defined($structure_sell_orders[0]) && $structure_sell_orders[0] eq "fail" ) {
										&debug_out("update_structure_orders(): Download of market data for structure $structure_id failed with HTML code $structure_sell_orders[1]");
										print STDERR "Download of market data for structure $structure_id failed with HTML code $structure_sell_orders[1]\n";
										}
									else {
										@structure_buy_orders	= &downloader(1, "/markets/structures/$structure_id/", { order_type => "buy", });	# true

										# Leave if nothing was downloaded
										if ( !( @structure_sell_orders || @structure_buy_orders ) ) {
											exit(0);
											}

										my $_sub_stop_on_create = sub {
											&debug_out( "update_structure_orders(): $DBI::errstr");
											kill(HUP => $ppid);
											$adb_knot->shlock;
											$agent_delivery_boy{error_stmt}		= $DBI::errstr;			# Report about error in statement
											$adb_knot->shunlock;
											&db_token(0);
											return(0);
											};

										# Open seperate DB handle
										&db_token(1);
										local $SIG{INT}		= "IGNORE";
										local $SIG{HUP}		= "IGNORE";
										my $dbh_seperate	= DBI->connect(
											$dsn,
											$user_id,
											$password,
											{
												RaiseError	=> 0,
												AutoCommit	=> 1,
												#ReadOnly	=> 0,
												},
											) or do {
												&{$_sub_stop_on_create}();
												return(0);
												};
										my $current_insert	= 0;

#=begin problem4
										$dbh_seperate->do("PRAGMA journal_mode = MEMORY;") or do {
											&debug_out("orders_update_agent(): Can't set journal mode to memory: " . $dbh_seperate->errstr);
											#$dbh_seperate->commit();
											$dbh_seperate->disconnect();
											&db_token(0);
											return(0);
											};
#=end problem4
#=cut

										# Structure orders' prepare
										my $sth_str_orders	= $dbh_seperate->prepare(
											"REPLACE INTO orders_structures " .  
											"(id, " .
											"volume_total, " .
											"volume_remain, " .
											"min_volume, " .
											"price, " .
											"duration, " .
											"issued, " .
											"range, " .
											"is_buy_order, " .
											"type_id, " .
											"location_id, " .
											"character_id)\n" .
											"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"
											);

										# Structure orders' execute
										sleep(1);
										$dbh_seperate->begin_work();
										foreach my $order ( @structure_sell_orders ) {
											if ( ref($order) && defined($order->{order_id}) && $order->{order_id} &&
										 	defined($order->{price}) && $order->{price} &&
										 	defined($order->{is_buy_order}) &&
										 	defined($order->{location_id}) && $order->{location_id} ) {
												$sth_str_orders->execute(
													$order->{order_id},
													$order->{volume_total},
													$order->{volume_remain},
													$order->{min_volume},
													$order->{price},
													$order->{duration},
													$order->{issued},
													$order->{range},
													$order->{is_buy_order},			# is_buy_order
													$order->{type_id},
													$order->{location_id},
													$char_id,
													) or &debug_out("update_structure_orders(): " . $sth_str_orders->errstr);
												}
											}

										# Structure orders' execute
										foreach my $order ( @structure_buy_orders ) {
											if ( ref($order) && defined($order->{order_id}) && $order->{order_id} &&
										 	defined($order->{price}) && $order->{price} &&
										 	defined($order->{is_buy_order}) &&
										 	defined($order->{location_id}) && $order->{location_id} ) {
												$sth_str_orders->execute(
													$order->{order_id},
													$order->{volume_total},
													$order->{volume_remain},
													$order->{min_volume},
													$order->{price},
													$order->{duration},
													$order->{issued},
													$order->{range},
													$order->{is_buy_order},			# is_buy_order
													$order->{type_id},
													$order->{location_id},
													$char_id,
													) or &debug_out("update_structure_orders(): " . $sth_str_orders->errstr);
												}
											}

										$dbh_seperate->commit;
										$dbh_seperate->disconnect;
										&db_token(0);

										$perc_count	+= 4;
										$ac_knot->shlock;
										$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
										$ac_knot->shunlock;
										}

									exit(0);	# always exit forks
									}
								# Error
								else {
									&debug_out("update_structure_orders(): Can't fork");
									&pprop_exit();
									}
								}
							&wait_children(1, \@agency, 100);
							}
						else {
							$perc_count	+= 74;
							$ac_knot->shlock;
							$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
							$ac_knot->shunlock;
							}

##### Missing structures
						# Remove denied
						&access_DB("DELETE FROM orders_structures WHERE character_id == " . &quote_DB($char_id) . " AND location_id IN ( SELECT structure_id FROM denied_structures WHERE character_id == " . &quote_DB($char_id) . " );");
						# Load ids of missing structures
						@structures		= &access_DB("SELECT location_id FROM missing_structures WHERE character_id = " . &quote_DB($char_id) . ";");
						my @db_data		= &access_DB("SELECT * FROM locations_structures WHERE character_id == " . &quote_DB($char_id) . ";");

						$ac_knot->shlock;
						$agent_carrier{progress_text}		= "Updating structure list...";
						$ac_knot->shunlock;

						if ( @structures && &{$_sub_update_access_token}() ) {
							my $next_at_test	= time + 290;

							# name	owner_id	position	solar_system_id	type_id
							# WARNING: no id is returend!
							&debug_out("Updating " . &human_readable(scalar(@structures)) . " structures");
							foreach my $structure_id ( @structures ) {
								$structure_id	= $structure_id->{location_id};
								my $agent	= fork;
								# Parent
								if ( defined($agent) && $agent ) {
									push(@agency, $agent);
									&debug_out("update_structures(): Started download agent $agent");

									if ( scalar(@structures) > 90 ) {
										sleep(1);		# Otherwhise the 4XX errors counter may exceed
										}
									else {
										Time::HiRes::sleep(0.01);
										}

									&wait_children($max_forks, \@agency);

									# Update nearly all five minutes the access token (_sub_update_access_token ensures at least five minutes left until token gets invalid)
									if ( time >= $next_at_test ) {
										$next_at_test	= time + 290;	# Set next time
										&wait_children(1, \@agency);	# Wait all agents to finish
										&debug_out("structure_markets_updater(): checking access token for update");
										&{$_sub_update_access_token}() or do {
											&debug_out("structure_markets_updater(): Can't update access token!");
											};
										}

									# Report to main window
									$perc_count	+= 30 / scalar(@structures);
									$ac_knot->shlock;
									$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
									$ac_knot->shunlock;
									}
								elsif ( defined($agent) ) {
									srand();
									local $SIG{INT}		= "DEFAULT";
									local $SIG{HUP}		= "DEFAULT";
									my %structure_data	= &downloader(1, "/universe/structures/$structure_id/") or exit(1);

									# Offers only name solar_system_id (NO id!!!)
									if ( defined($structure_data{name}) && $structure_data{name} ) {
										if ( !( grep {
									 	$_->{name}		eq $structure_data{name} &&
									 	$_->{solar_system_id}	eq $structure_data{solar_system_id}
									 	} @db_data ) ) {
											&access_DB("REPLACE INTO locations_structures ( id, name, solar_system_id, character_id ) VALUES ( " .
												&quote_DB($structure_id) . " , " .
												&quote_DB($structure_data{name}) . " , " .
												&quote_DB($structure_data{solar_system_id}) . " , " .
												&quote_DB($char_id) .
												" );");
											}
										}
									exit(0);	# always exit forks
									}
								else {
									&debug_out(
										"update_structures(): Can't fork",
										);
									&pprop_exit();
									}
								}

							&wait_children(1, \@agency);

							# Add forbidden to denied list
							&access_DB("REPLACE INTO denied_structures ( structure_id, character_id ) SELECT location_id, character_id FROM missing_structures WHERE character_id == " . &quote_DB($char_id) . " ;");

							# Remove all orders, which seem to be from forbidden structures
							&access_DB("DELETE FROM orders_structures WHERE orders_structures.location_id IN ( SELECT ms.location_id FROM missing_structures ms WHERE ms.character_id == " . &quote_DB($char_id) . " ) AND orders_structures.character_id == " . &quote_DB($char_id) . " ;");
							#&access_DB("VACUUM;");

							# Report to main window
							$perc_count	+= 4;
							$ac_knot->shlock;
							$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
							$ac_knot->shunlock;
							}
						else{
							$perc_count	+= 34;
							$ac_knot->shlock;
							$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
							$ac_knot->shunlock;
							}

						# Wait for agents from stations
						&wait_children(1, \@agency);	# Block until all children are gone

						&access_DB(
							"UPDATE characters\n" .
							"SET last_update_markets = " . &quote_DB(time) . ",\n" .
							"update_running = 0\n" .
							"WHERE id == " . &quote_DB($char_id) . ";"
							);

						#&access_DB("VACUUM;");
						}
					else {
						$perc_count	+= 270;
						}
					}

			## Update all (but start with types and structures)
			elsif ( $agent_carrier{run_update} eq "all" ) {
				my $current_time	= time;
				my $char_id		= $agent_carrier{CharacterID};	# separate variable really needed?
				$ac_knot->shunlock;
				&debug_out("Update for all was requested");
				my $time_details	= [ &access_DB(
					"SELECT last_update_all, update_running, done_regions, done_constellations, done_systems, done_systems, done_stargates, done_stations, done_structures, done_types, done_jumps\n" .
					"FROM characters\n" .
					"WHERE id == " . &quote_DB($char_id) . ";"
					) ];
				my @db_data		= ();

				# Calculate if it is to early to be updated again
				if ( scalar(@{$time_details}) == 1 && ref($time_details->[0]) && ( $current_time > ( $time_details->[0]->{last_update_all} + $min_age_all * 60 ) || $time_details->[0]->{update_running} == 1 ) ) {

					# Remember last update
					&access_DB(
						"UPDATE characters\n" .
						"SET last_update_all = " . &quote_DB($current_time) . ",\n" .
						"update_running = 1\n" .
						"WHERE id == " . &quote_DB($char_id) . ";"
						);

					# Free disk space
					#&access_DB("VACUUM;");

##### Types (prepare IDs from regions)
					# Download Region IDs
					my @regions				= &downloader(0, "/universe/regions/");		# returns a array

					$ac_knot->shlock;
					$agent_carrier{progress_text}		= "Preparing types...";
					$ac_knot->shunlock;
					# Download Type IDs
					#my @types				= &downloader(0, "/universe/types/");		# returns a array
					my @types				= ();

					if ( !@regions ) {
						&debug_out("update_all(): No regions nor types got");
						# WORK Message for user?
						#return(0);
						}

##### Types #####################################
					# Types must come from /markets/{region_id}/types/ AND /universe/types/ AND /universe/types/{type_id}
					# Get region dependend type ids
					if ( ! $time_details->[0]->{done_types} ) {
						foreach my $region ( @regions ) {
							my $agent		= fork;
							# Parent
							if ( defined($agent) && $agent ) {
								push(@agency, $agent);
								&debug_out("get_region_types(): Started download agent $agent");
								Time::HiRes::sleep(0.01);
								&wait_children($max_forks, \@agency);

								# Report to main window
								$perc_count	+= 15 / scalar(@regions);
								$ac_knot->shlock;
								$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
								$ac_knot->shunlock;
								}
							# Child
							elsif ( defined($agent) ) {
								srand();
								local $SIG{INT}		= "DEFAULT";
								local $SIG{HUP}		= "DEFAULT";
								my @region_market_types	= &downloader(0, "/markets/$region/types/");

								if ( @region_market_types && scalar(@region_market_types) > 0 ) {

									# Encode
									my $enc_data	= encode_json(\@region_market_types);

									# Save
									&access_DB("INSERT INTO transfer VALUES ( " . &quote_DB($enc_data) . " , " . &quote_DB($char_id) . " );");
									}
								exit(0);
								}
							else {
								&debug_out(
									"update_types(): Can't fork",
									);
								&pprop_exit();
								}
							}

						# Wait for children
						&wait_children(1, \@agency);


						# Last time receiving
						$update_knot->shlock;
						@receiver		= ();
						$update_knot->shunlock;

						# Prepare storage to act as usually
						@storage		= &access_DB("SELECT content FROM transfer WHERE character_id == " . &quote_DB($char_id) . ";");
						foreach ( @storage ) { $_	= $_->{content}; }

						{	# Clean database...
							my $agent	= fork;

							# Parent
							if ( defined($agent) && $agent ) {
								push(@agency, $agent);
								&debug_out("update_types(): Startet cleanup agent $agent");
								}
							# Child
							elsif ( defined($agent) ) {
								srand();
								local $SIG{INT}		= "DEFAULT";
								local $SIG{HUP}		= "DEFAULT";
								&access_DB("DELETE FROM transfer WHERE character_id = " . &quote_DB($char_id) . ";");
								#&access_DB("VACUUM;");
								exit(0); # Always exit children
								}
							else {
								&debug_out("update_types(): Can't fork");
								}
							}

						# Decode content
						@storage		= ( @{ &test_json(&{$_sub_merge_json}(@storage)) } );

						$ac_knot->shlock;
						$agent_carrier{progress_text}		= "Updating types...";
						$ac_knot->shunlock;
						# Move to types and omit dublicates
						@db_data		= &access_DB("SELECT * FROM types ;");
						@types			= &make_unique(@types, @storage);
						@storage		= ();
						&debug_out("\@storage is empty");
 						#@storage		= ( grep { my $helper = $_->{id} ; not grep { $helper == $_ } @types } &access_DB("SELECT id FROM types") );
						# Delete types, which ids are only known in database
						if ( @types ) {
							#&access_DB("DELETE FROM types WHERE id NOT IN ( " . join(" , ", @types) . " );");	# NEVER EVER delete types to keep database integrety up through just adding new ones even if types weren't updated for long!
							}

						&debug_out("Updating " . &human_readable(scalar(@types)) . " type elements");
						foreach my $type_id ( @types ) {
							my $agent	= fork;
							# Parent
							if ( defined($agent) && $agent ) {
								push(@agency, $agent);
								&debug_out("update_types(): Started download agent $agent");
								Time::HiRes::sleep(0.01);
								&wait_children($max_forks, \@agency);

								# Report to main window
								$perc_count	+= 50 / scalar(@types);
								$ac_knot->shlock;
								$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
								$ac_knot->shunlock;
								}
							# Child
							elsif ( defined($agent) ) {
								srand();
								local $SIG{INT}		= "DEFAULT";
								local $SIG{HUP}		= "DEFAULT";
								my %type_data		= &downloader(0, "/universe/types/$type_id");

								if ( defined($type_data{type_id}) && $type_data{type_id} && defined($type_data{name}) && $type_data{name} ) {
									if ( !( grep {
								 	$_->{name}		eq $type_data{name} &&
								 	$_->{volume}		eq $type_data{volume} &&
								 	$_->{packaged_volume}	eq $type_data{packaged_volume} &&
								 	$_->{capacity}		eq $type_data{capacity} &&
								 	$_->{mass}		eq $type_data{mass}
								 	} @db_data ) ) {
										&access_DB("REPLACE INTO types (id, name, volume, packaged_volume, capacity, mass) VALUES ( " .
											&quote_DB($type_data{type_id}) . " , " .
											&quote_DB($type_data{name}) . " , " .
											&quote_DB($type_data{volume}) . " , " .
											&quote_DB($type_data{packaged_volume}) . " , " .
											&quote_DB($type_data{capacity}) . " , " .
											&quote_DB($type_data{mass}) .
											" );");
										}
									else {
										&debug_out("update_types(): No need to update $type_id");
										}
									}
								exit(0);						# always exit forks
								}
							else {
								&debug_out("update_types(): Can't fork");
								&pprop_exit();
								}
							}

						# Wait for agents from types # _sub_gatherer() depends on waiting or not, if the transfer is made, but here we need to do the transfer under all circumstances!
						&wait_children(1, \@agency);	# Block until all children are gone

						&access_DB(qq{UPDATE characters SET done_types = } . &quote_DB(1) . qq{ ;});	# For ALL characters!

						# Report to main window
						$perc_count	+= 10;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}
					else {
						# Report to main window
						$perc_count	+= 75;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}

##### Regions ###################################
					$ac_knot->shlock;
					$agent_carrier{progress_text}		= "Updating regions...";
					$ac_knot->shunlock;

					# Delete types, which ids are only known in database
					if ( @regions ) {
						#&access_DB("DELETE FROM locations_regions WHERE id NOT IN ( " . join(" , ", @regions) . " );");
						}

					@db_data	= &access_DB("SELECT * FROM locations_regions ;");

					if ( ! $time_details->[0]->{done_regions} || (grep { my $dlr = $_ ; not grep { $dlr == $_->{id} } @db_data } @regions) ) { # Run anyway if there are new regions
						&debug_out("Updating " . &human_readable(scalar(@regions)) . " regions");
						foreach my $region_id ( @regions ) {
							my $agent = fork;
							# Parent
							if ( defined($agent) && $agent ) {
								push(@agency, $agent);
								&debug_out("update_regions(): Started download agent $agent");
								Time::HiRes::sleep(0.01);
								&wait_children($max_forks, \@agency);

								# Report to main window
								$perc_count	+= 15 / scalar(@regions);
								$ac_knot->shlock;
								$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
								$ac_knot->shunlock;
								}
							# Child
							elsif ( defined($agent) ) {
								srand();
								local $SIG{INT}		= "DEFAULT";
								local $SIG{HUP}		= "DEFAULT";
								my %region_data	= &downloader(0, "/universe/regions/$region_id");

								if ( defined($region_data{region_id}) && $region_data{region_id} && defined($region_data{name}) && $region_data{name} ) {
									if ( !( grep {
								 	$_->{name} eq $region_data{name}
								 	} @db_data ) ) {
										&access_DB("REPLACE INTO locations_regions ( id, name ) VALUES ( " .
											&quote_DB($region_data{region_id}) . " , " .
											&quote_DB($region_data{name}) .
											" );");
										}
									}
								exit(0);						# always exit forks
								}
							else {
								&debug_out(
									"update_regions(): Can't fork",
									);
								&pprop_exit();
								}
							}

						# Wait for agents from regions
						&wait_children(1, \@agency);	# Block until all children are gone

						&access_DB(qq{UPDATE characters SET done_regions = } . &quote_DB(1) . qq{ ;});	# For ALL characters!

						# Report to main window
						$perc_count	+= 2;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}
					else {
						# Report to main window
						$perc_count	+= 17;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}

##### Constellations ############################
					$ac_knot->shlock;
					$agent_carrier{progress_text}		= "Updating constellations...";
					$ac_knot->shunlock;

					if ( ! $time_details->[0]->{done_constellations} ) {
						my @constellations		= &downloader(0, "/universe/constellations/");		# returns an array

						if ( @constellations ) {
							#&access_DB("DELETE FROM locations_constellations WHERE id NOT IN ( " . join(" , ", @constellations) . " );");
							}

						@db_data			= &access_DB("SELECT * FROM locations_constellations ;");

						# constellation_id	name	position-x	position-y	position-z	region_id	systems
						&debug_out("Updating " . &human_readable(scalar(@constellations)) . " constellations");
						foreach my $constellation_id ( @constellations ) {
							my $agent = fork;
							# Parent
							if ( defined($agent) && $agent ) {
								push(@agency, $agent);
								&debug_out("update_constellations(): Started download agent $agent");
								Time::HiRes::sleep(0.01);
								&wait_children($max_forks, \@agency);

								# Report to main window
								$perc_count	+= 30 / scalar(@constellations);
								$ac_knot->shlock;
								$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
								$ac_knot->shunlock;
								}
							# Child
							elsif ( defined($agent) ) {
								srand();
								local $SIG{INT}		= "DEFAULT";
								local $SIG{HUP}		= "DEFAULT";
								my %constellation_data	= &downloader(0, "/universe/constellations/$constellation_id/");

								if ( defined($constellation_data{constellation_id}) && $constellation_data{constellation_id}
								 && defined($constellation_data{name}) && $constellation_data{name} ) {
									if ( !( grep {
								 	$_->{name}		eq $constellation_data{name} &&
								 	$_->{region_id}	eq $constellation_data{region_id}
								 	} @db_data ) ) {
										&access_DB("REPLACE INTO locations_constellations ( id, name, region_id ) VALUES ( " .
											&quote_DB($constellation_data{constellation_id}) . " , " .
											&quote_DB($constellation_data{name}) . " , " .
											&quote_DB($constellation_data{region_id}) .
											" );");
										}
									}
								exit(0);						# always exit forks
								}
							else {
								&debug_out(
									"update_constellations(): Can't fork",
									);
								&pprop_exit();
								}
							}

						# Wait for agents from constellations
						&wait_children(1, \@agency);	# Block until all children are gone

						&access_DB(qq{UPDATE characters SET done_constellations = } . &quote_DB(1) . qq{ ;});	# For ALL characters!

						# Report to main window
						$perc_count	+= 2;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}
					else {
						# Report to main window
						$perc_count	+= 32;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}

##### Systems ###################################
					$ac_knot->shlock;
					$agent_carrier{progress_text}		= "Updating systems...";
					$ac_knot->shunlock;

					if ( ! $time_details->[0]->{done_systems} ) {
						my @systems		= &downloader(0, "/universe/systems/");		# returns a array

						if ( @systems ) {
							#&access_DB("DELETE FROM locations_systems WHERE id NOT IN ( " . join(" , ", @systems) . " );");
							}

						@db_data	= &access_DB("SELECT * FROM locations_systems ;");

						# system_id	name	position-x	position-y	position-z	security_status	security_class	constellation_id	planets	stargates	stations
						&debug_out("Updating " . &human_readable(scalar(@systems)) . " systems");
						foreach my $system_id ( @systems ) {
							my $agent = fork;
							# Parent
							if ( defined($agent) && $agent ) {
								push(@agency, $agent);
								&debug_out("update_systems(): Started download agent $agent");
								Time::HiRes::sleep(0.01);
								&wait_children($max_forks, \@agency);
								#&_sub_gatherer(ceil($max_forks * 0.12)); # 12 elements + 12 * 15 elements = 192 elements in @storage ( $max_forks = 100

								# Report to main window
								$perc_count	+= 45 / scalar(@systems);
								$ac_knot->shlock;
								$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
								$ac_knot->shunlock;
								}
							# Child
							elsif ( defined($agent) ) {
								srand();
								local $SIG{INT}		= "DEFAULT";
								local $SIG{HUP}		= "DEFAULT";
								my %system_data	= &downloader(0, "/universe/systems/$system_id");

								if ( defined($system_data{system_id}) && $system_data{system_id} && defined($system_data{name}) && $system_data{name} ) {
									my $transfer_block	= "";
									if ( !( grep {
								 	$_->{name}		eq $system_data{name} &&
								 	$_->{security_status}	eq $system_data{security_status} &&
								 	$_->{constellation_id}	eq $system_data{constellation_id} &&
								 	( ( defined($_->{security_class}) && defined($system_data{security_class}) && $_->{security_class} eq $system_data{security_class} ) ||
								  	( !defined($_->{security_class}) && !defined($system_data{security_class}) ) )
								 	} @db_data ) ) {
										&access_DB("REPLACE INTO locations_systems ( id, name, security_status, security_class, constellation_id ) VALUES ( " .
											&quote_DB($system_data{system_id}) . " , " .
											&quote_DB($system_data{name}) . " , " .
											&quote_DB($system_data{security_status}) . " , " .
											&quote_DB($system_data{security_class}) . " , " .
											&quote_DB($system_data{constellation_id}) .
											" );");
										}

									# WORK If security status only changed between high and low/zero, all routes_jumps jumps_low and jumps_high must be set to -1 again, but just one time!
									# WORK Only delete origin == $system_id or destination == $system_id ?

									# Save stations list
									if ( defined($system_data{stations}) && @{$system_data{stations}} ) {
										$transfer_block	= &quote_DB("-stations-" . encode_json($system_data{stations})) . ", " . &quote_DB($char_id);
										}
									if ( defined($system_data{stargates}) && @{$system_data{stargates}} ) {
										$transfer_block	.= ( ( $transfer_block ) ? " ), ( " : "" ) . &quote_DB("-stargates-" . encode_json($system_data{stargates})) . ", " . &quote_DB($char_id);
										}

									if ( $transfer_block ) {
										&access_DB("INSERT INTO transfer VALUES ( $transfer_block );");
										}
									}
								exit(0);						# always exit forks
								}
							else {
								&debug_out(
									"update_systems(): Can't fork",
									);
								&pprop_exit();
								}
							}

						# Wait for agents from regions
						&wait_children(1, \@agency);	# Block until all children are gone

						$ac_knot->shlock;
						if ( $agent_carrier{jumps_reset} ) {
							$ac_knot->shunlock;
							#&access_DB("UPDATE routes_jumps SET jumps_high = " . &quote_DB(-1) . " , jumps_low = " . &quote_DB(-1) . " ;");
							}
						else {
							$ac_knot->shunlock;
							}

						&access_DB(qq{UPDATE characters SET done_systems = } . &quote_DB(1) . qq{ ;});	# For ALL characters!

						# Report to main window
						$perc_count	+= 3;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}
					else {
						# Report to main window
						$perc_count	+= 48;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}

##### Stations ##################################
					$ac_knot->shlock;
					$agent_carrier{progress_text}		= "Updating stations...";
					$ac_knot->shunlock;
					my @stations				= &access_DB("SELECT content FROM transfer WHERE character_id == " . &quote_DB($char_id) . " ;");

					if ( $time_details->[0]->{done_systems} && $time_details->[0]->{done_systems} && $time_details->[0]->{done_stargates} ) {	# Clean database...
						my $agent	= fork;

						# Parent
						if ( defined($agent) && $agent ) {
							push(@agency, $agent);
							&debug_out("Startet cleanup agent $agent");
							}
						# Child
						elsif ( defined($agent) ) {
							srand();
							local $SIG{INT}		= "DEFAULT";
							local $SIG{HUP}		= "DEFAULT";
							&access_DB("DELETE FROM transfer WHERE character_id = " . &quote_DB($char_id) . ";");
							#&access_DB("VACUUM;");
							exit(0); # Always exit children
							}
						else {
							&debug_out("update_stations(): Can't fork");
							}
						}

					# Decode content
					my @stargates				= grep { $_->{content} =~ m/-stargates-/ } @stations;
					@stations				= grep { $_->{content} =~ m/-stations-/ } @stations;
					foreach my $element ( @stations, @stargates ) {
						$element->{content}	=~ s/-(stargates|stations)-//g;	# Remove identifier
						$element		= $element->{content};
						}

					if ( ! $time_details->[0]->{done_stations} ) {
						@stations		= ( @{ &test_json(&{$_sub_merge_json}(@stations)) } );

						if ( @stations ) {
							#&access_DB("DELETE FROM locations_stations WHERE id NOT IN ( " . join(" , ", @stations) . " );");
							}

						@db_data	= &access_DB("SELECT * FROM locations_stations ;");

						&debug_out("Updating " . &human_readable(scalar(@stations)) . " stations");
						foreach my $station_id ( @stations ) {
							my $agent	= fork;
							# Parent
							if ( defined($agent) && $agent ) {
								push(@agency, $agent);
								&debug_out("update_stations(): Startet download agent $agent");
								Time::HiRes::sleep(0.01);
								&wait_children($max_forks, \@agency);

								# Report to main window
								$perc_count	+= 20 / scalar(@stations);
								$ac_knot->shlock;
								$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
								$ac_knot->shunlock;
								}
							# Child
							elsif ( defined($agent) ) {
								srand();
								local $SIG{INT}		= "DEFAULT";
								local $SIG{HUP}		= "DEFAULT";
								my %station_data = &downloader(0, "/universe/stations/$station_id/");

								if ( defined($station_data{station_id}) && $station_data{station_id} && defined($station_data{name}) && $station_data{name} ) {
									if ( !( grep {
								 	$_->{name}		eq $station_data{name} &&
								 	$_->{system_id}	eq $station_data{system_id}
								 	} @db_data ) ) {
										&access_DB("REPLACE INTO locations_stations ( id, name, system_id ) VALUES ( " .
											&quote_DB($station_data{station_id}) . " , " .
											&quote_DB($station_data{name}) . " , " .
											&quote_DB($station_data{system_id}) .
											" );");
										}
									}
								exit(0);
								}
							else {
								&debug_out(
									"update_systems_subagent(): Can't fork",
									);
								&pprop_exit();
								}
							}

						# Wait for agents from stations
						&wait_children(1, \@agency);	# Block until all children are gone

						&access_DB(qq{UPDATE characters SET done_stations = } . &quote_DB(1) . qq{ ;});	# For ALL characters!

						# Report to main window
						$perc_count	+= 2;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}
					else {
						# Report to main window
						$perc_count	+= 22;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}

##### Stargates (System's neighbours) ###########
					$ac_knot->shlock;
					$agent_carrier{progress_text}		= "Updating stargates...";
					$ac_knot->shunlock;

					if ( ! $time_details->[0]->{done_stargates} ) {
						# Decode content
						@stargates		= ( @{ &test_json(&{$_sub_merge_json}(@stargates)) } );	# Generated like stations

						# Clean
						if ( @stargates ) {
							#&access_DB("DELETE FROM locations_stargates WHERE id NOT IN ( " . join(" , ", @stargates) . " );");
							}
						@db_data		= &access_DB("SELECT * FROM locations_stargates ;");

						&debug_out("Updating " . &human_readable(scalar(@stargates)) . " stargates");
						foreach my $stargate_id ( @stargates ) {
							my $agent	= fork;
							# Parent
							if ( defined($agent) && $agent ) {
								push(@agency, $agent);
								&debug_out("update_stations(): Startet download agent $agent");
								Time::HiRes::sleep(0.01);
								&wait_children($max_forks, \@agency);

								# Report to main window
								$perc_count	+= 40 / scalar(@stargates);
								$ac_knot->shlock;
								$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
								$ac_knot->shunlock;
								}
							# Child
							elsif ( defined($agent) ) {
								srand();
								local $SIG{INT}		= "DEFAULT";
								local $SIG{HUP}		= "DEFAULT";
								my %stargate_data	= &downloader(0, "/universe/stargates/$stargate_id/");

								if ( defined($stargate_data{stargate_id}) && $stargate_data{stargate_id} && defined($stargate_data{name}) && $stargate_data{name} ) {
									if ( !( grep {
								 	$_->{id}		eq $stargate_data{stargate_id} &&
								 	$_->{system_id}	eq $stargate_data{system_id} &&
								 	$_->{neighbour_id}	eq $stargate_data{destination}->{system_id}
								 	} @db_data ) ) {
										&access_DB("REPLACE INTO locations_stargates ( id, system_id, neighbour_id ) VALUES ( " .
											&quote_DB($stargate_data{stargate_id}) . " , " .
											&quote_DB($stargate_data{system_id}) . " , " .
											&quote_DB($stargate_data{destination}->{system_id}) .
											" );");
										}
									}
								exit(0);
								}
							else {
								&debug_out(
									"update_systems_subagent(): Can't fork",
									);
								&pprop_exit();
								}
							}

						# Wait for agents from stargates
						&wait_children(1, \@agency);	# Block until all children are gone

						&access_DB(qq{UPDATE characters SET done_stargates = } . &quote_DB(1) . qq{ ;});	# For ALL characters!

						# Report to main window
						$perc_count	+= 2;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}
					else {
						# Report to main window
						$perc_count	+= 42;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}

##### Structures ################################
					$ac_knot->shlock;
					$agent_carrier{progress_text}		= "Updating structures...";
					$ac_knot->shunlock;

					if ( ! $time_details->[0]->{done_structures} ) {
						# According to https://docs.esi.evetech.net/docs/scenarios/resolve_structure_ids.html this will return a FULL PUBLIC list (i.e. everybody may access)
						my @structures		= &downloader(0, "/universe/structures/");
						# Release structures from denail if it is in the official list
						&access_DB("DELETE FROM denied_structures WHERE character_id == " . &quote_DB($char_id) . " AND structure_id IN ( " . join(" , ", @structures) . " );");
						# V.v.: Remove structures from official table if not in official list anymore
						#&access_DB("DELETE FROM locations_structures WHERE character_id == " . &quote_DB($char_id) . " AND id NOT IN ( " . join(" , ", @structures) . " );");
						# Load comparsion table
						@db_data		= &access_DB("SELECT * FROM locations_structures WHERE character_id == " . &quote_DB($char_id) . ";");

						if ( @structures && &{$_sub_update_access_token}() ) {

							&debug_out("update_structures(): Going to update " . scalar(@structures) . " structures");
							my $next_at_test	= time + 290;

							# name	owner_id	position	solar_system_id	type_id
							# WARNING: no id is returend!
							&debug_out("Updating " . &human_readable(scalar(@structures)) . " structures");
							foreach my $structure_id ( @structures ) {
								my $agent	= fork;

								# Parent
								if ( defined($agent) && $agent ) {
									push(@agency, $agent);
									&debug_out("update_structures(): Started download agent $agent");

									Time::HiRes::sleep(0.01);

									&wait_children($max_forks, \@agency);

									# Update nearly all five minutes the access token (_sub_update_access_token ensures at least five minutes left until token gets invalid)
									if ( time >= $next_at_test ) {
										$next_at_test	= time + 290;	# Set next time
										&wait_children(1, \@agency);	# Wait all agents to finish
										&debug_out("structure_updater(): checking access token for update");
										&{$_sub_update_access_token}() or do {
											&debug_out("structure_updater(): Can't update access token!");
											};
										}

									# Report to main window
									$perc_count	+= 60 / scalar(@structures);
									$ac_knot->shlock;
									$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
									$ac_knot->shunlock;
									}
								# Child
								elsif ( defined($agent) ) {
									srand();
									local $SIG{INT}		= "DEFAULT";
									local $SIG{HUP}		= "DEFAULT";
									my %structure_data	= &downloader(1, "/universe/structures/$structure_id/");

									# Offers only name solar_system_id type_id (NO id!!!)
									if ( defined($structure_data{name}) && $structure_data{name} ) {
										if ( !( grep {
									 	$_->{name}		eq $structure_data{name} &&
									 	$_->{solar_system_id}	eq $structure_data{solar_system_id}
									 	} @db_data ) ) {
											&access_DB("REPLACE INTO locations_structures ( id, name, solar_system_id, character_id ) VALUES ( " .
												&quote_DB($structure_id) . " , " .
												&quote_DB($structure_data{name}) . " , " .
												&quote_DB($structure_data{solar_system_id}) . " , " .
												&quote_DB($char_id) .
												" );");
											}
										else {
											&debug_out("structure_agent(): No need to update structure $structure_id");
											}
										}
									elsif ( defined($structure_data{fail}) && $structure_data{fail} == 403 ) {
										&access_DB("REPLACE INTO denied_structures ( structure_id, character_id ) VALUES ( " .
											&quote_DB($structure_id) . " , " .
											&quote_DB($char_id) .
											" );");
										}
	
									exit(0);	# always exit forks
									}
								else {
									&debug_out(
										"update_structures(): Can't fork",
										);
									&pprop_exit();
									}
								}

							&wait_children(1, \@agency);

							# Report to main window
							$perc_count	+= 4;

							$ac_knot->shlock;
							$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
							$ac_knot->shunlock;
							}
						else {
							# Report to main window
							$perc_count	+= 64;
							$ac_knot->shlock;
							$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
							$ac_knot->shunlock;
							}

						@db_data		= ();

						&access_DB(qq{UPDATE characters SET done_structures = } . &quote_DB(1) . qq{ ;});	# For ALL characters!
						}
					else {
						# Report to main window
						$perc_count	+= 64;
						$ac_knot->shlock;
						$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
						$ac_knot->shunlock;
						}

# Calculate and write route jumps ###############
					$ac_knot->shlock;
					$agent_carrier{progress_text}		= "Calculating routes' jumps...";
					$ac_knot->shunlock;

					if ( ! $time_details->[0]->{done_jumps} ) {	# This is not needed because there's an internal filter
						my($todo)	= &access_DB("SELECT count() counter FROM routes_jumps WHERE jumps_high == " . &quote_DB(-1) . " OR jumps_low == " . &quote_DB(-1) . " ;");
						&debug_out("jumps_calculator(): $todo->{counter} routes jumps left to calculate");

						my $offset_counter	=  0;
						my @missing_jumps	= ();
						my @impassable_routes	= ();
						my @slow_nb_list	= &access_DB("SELECT * FROM locations_neighbours;");
						my %neighbours_list	= ();
							# system_id1	=> {
							#	neighbours	=> [
							#		{
							#			id		=> INT,
							#			security_status	=> FLOAT,
							#			security_class	=> TEXT,
							#			},
							#		],
							#	security_status	=> FLOAT,
							#	security_class	=> TEXT,
							#	},
						while ( @slow_nb_list ) {
							my $system_id	= $slow_nb_list[0]->{system_id};
							&debug_out("neighbour_list_builder(): Preparing neighbour list for $system_id");

							if ( ! defined($neighbours_list{$system_id}) ) {
								$neighbours_list{$system_id}	= {
									neighbours	=> [],
									security_status	=> $slow_nb_list[0]->{sys_sec},
									security_class	=> $slow_nb_list[0]->{sys_class},
									};
								}

							foreach my $neighbour ( grep { $system_id == $_->{system_id} } @slow_nb_list ) {
								#&debug_out("neighbour_list_builder(): Adding neighbour $neighbour->{neighbour_id}");
								push(@{$neighbours_list{$system_id}->{neighbours}}, {
									id		=> $neighbour->{neighbour_id},
									security_status	=> $neighbour->{neig_sec},
									security_class	=> $neighbour->{neig_class},
									});
								}

							@slow_nb_list	= grep { $system_id != $_->{system_id} } @slow_nb_list;
							}

						&debug_out("There are " . &human_readable(scalar(keys(%neighbours_list))) . " elements in the neighbours list");

						my $_sub_dijkstra_algorythm	= sub {
							my $origin		= shift;
							my @queue		= ({
								id		=> $origin,
								jumps_all	=> 0,
								});
							my %done		= ();	# Visited
							my @delayed_queue	= ();	# Delay for next mode
							my %finished		= ();	# Ready for handover

							&debug_out("Calculating routes for system $origin");

							# jumps_all via breadth first search
							while ( @queue ) {
								my $u	= shift(@queue);

								if ( !defined($done{$u->{id}}) || ( defined($done{$u->{id}}) && $u->{jumps_all} < $done{$u->{id}}->{jumps_all} ) ) {
									$done{$u->{id}}		= {
										jumps_all	=> $u->{jumps_all},
										origin		=> $origin,
										#destination	=> $u->{id},	# is key
										};
									}

								#&debug_out("_sub_dijkstra_algorythm(): Added route from $done{$u->{id}}->{origin} to $u->{id} with $done{$u->{id}}->{jumps_all} jumps to CloseList");

								foreach my $knot ( @{$neighbours_list{$u->{id}}->{neighbours}} ) {
									my $knot	= {	# Needed, to make a proper copy and not changing values of @neighbours_list
										id		=> $knot->{id},
										jumps_all	=> $u->{jumps_all} + 1,
										};
					
									if ( ! defined($done{$knot->{id}}) ) {
										push(@queue, $knot);
										#&debug_out("_sub_dijkstra_algorythm(): Added $knot->{id} to queue");
										}
									}
								}

							%finished		= ( %done );
							%done			= ();

							# More complex Dijkstra algorythm for calculating jumps_high and jumps_low
							my $_sub_is_high_sec	= sub {
								my $client	= shift;

								if ( ! defined($neighbours_list{$client}) ) {
									print STDERR qq{$client not found in list!\n"};
									}
								elsif ( ! defined($neighbours_list{$client}->{security_status}) ) {
									print STDERR qq{$client has no "security_status" element!!\n};
									}

								if ( ( POSIX::lround($neighbours_list{$client}->{security_status} * 10) / 10 ) >= 0.5 ) { # POSIX is more accurate for integer, as sprintf, but offers only integer rounding
									return(1);
									}
								else {
									return(0);
									}
								};

							my $_sub_is_low_sec	= sub {
								my $lc		= shift;

								if ( &{$_sub_is_high_sec}($lc) ) {
									return(0);
									}
								else {
									return(1);
									}
								};

							my $_sub_is_below_zero	= sub {
								my $client	= shift;

								if ( ! defined($neighbours_list{$client}) ) {
									print STDERR qq{$client not found in list!\n"};
									}
								elsif ( ! defined($neighbours_list{$client}->{security_status}) ) {
									print STDERR qq{$client has no "security_status" element!!\n};
									}

								if ( ( POSIX::lround($neighbours_list{$client}->{security_status} * 10) / 10 ) < 0.0 ) { # POSIX is more accurate for integer, as sprintf, but offers only integer rounding
									return(1);
									}
								else {
									return(0);
									}
								};

							&debug_out("_sub_dijkstra_algorythm(): Calculating routes for $origin");

							foreach my $jump_type ( qw(jumps_high jumps_low) ) {

								@queue			= ({
									id		=> $origin,
									$jump_type	=>  0,	# jumps
									effective_value	=>  0,	# calculation value
									former		=> -1,
									});

								complex_listing:
								while ( @queue ) {
									my $u	= shift(@queue);

									# Prefer wanted route before length
									if ( !defined($done{$u->{id}})
									 || ( defined($done{$u->{id}})
									  && ( $u->{effective_value} < $done{$u->{id}}->{effective_value}
									   || ( $u->{effective_value} == $done{$u->{id}}->{effective_value}
									    && $u->{$jump_type} < $done{$u->{id}}->{$jump_type}
									    )
									   )
									  )
									 ) {
										$done{$u->{id}}		= {
											$jump_type	=> $u->{$jump_type},
											origin		=> $origin,
											effective_value	=> $u->{effective_value},
											former		=> $u->{former},
											#destination	=> $u->{id},	# is key
											};
										}

									neightbour:
									foreach my $real_knot ( @{$neighbours_list{$u->{id}}->{neighbours}} ) {

										my $knot	= {	# Needed, to make a proper copy and not changing values of @neighbours_list
											id		=> $real_knot->{id},
											$jump_type	=> $u->{$jump_type} + 1,
											effective_value	=> $u->{effective_value},
											former		=> $u->{id},
											};

										## Decide which is to increase
										if ( $jump_type eq "jumps_high" ) {
											# If fits
											if ( &{$_sub_is_high_sec}($knot->{id}) ) {
												$knot->{effective_value}		+=     1;
												}
											# If it doesn't fit
											else {
												$knot->{effective_value}		+= 1_000;
												}
											}
										elsif ( $jump_type eq "jumps_low" ) {
											if ( &{$_sub_is_low_sec}($knot->{id}) ) {
												if ( &{$_sub_is_below_zero}($knot->{id}) ) {
													$knot->{effective_value}	+=   500;
													}
												else {
													$knot->{effective_value}	+=     1;
													}
												}
											else {
												$knot->{effective_value}		+= 1_000;
												}
											}
										else {
											$knot->{effective_value}		+= 1_000_000;
											}

										if ( !defined($done{$knot->{id}}) || ( defined($done{$knot->{id}}) && $done{$knot->{id}}->{effective_value} >= $knot->{effective_value} ) ) {
											push(@queue, $knot);
											#&debug_out("_sub_dijkstra_algorythm(): Added $knot->{id} to queue");
											}
										}
									}

								# Handover to %finished
								finishing:
								foreach my $to_round ( keys(%done) ) {
									if ( defined($finished{$to_round}) ) {

										if ( $origin == $to_round ) {
											$finished{$origin}->{$jump_type}		= 0;
											#$finished{$origin}->{"${jump_type}_route"}	= [ $origin ];
											next(finishing);
											}

										$done{$to_round}->{route}		= [ $to_round ];
										#&debug_out("_sub_dijkstra_algorythm(): Starting rebuild route from $to_round to $origin");

										build_route:
										while ( 1 ) {
											if ( defined($done{$done{$to_round}->{route}->[-1]}->{former}) && $done{$done{$to_round}->{route}->[-1]}->{former} > 0 ) {
												push(@{$done{$to_round}->{route}}, $done{$done{$to_round}->{route}->[-1]}->{former});
												#&debug_out("_sub_dijkstra_algorythm(): Added $done{$done{$to_round}->{route}->[-1]}->{former} to list");
												}
											# If route is complete
											elsif ( defined($done{$done{$to_round}->{route}->[-1]}) && ( $done{$done{$to_round}->{route}->[-1]}->{former} == -1 || $done{$to_round}->{route}->[-1] == $origin ) ) {
												#&debug_out("_sub_dijkstra_algorythm(): Route complete!");
												last(build_route);
												}
											else {
												#&debug_out("_sub_dijkstra_algorythm(): Route incomplete: @{$done{$to_round}->{route}}\n \"former\" is set to $done{$to_round}->{route}->[-1]->{former}");
												next(finishing);	# Prevent infinite search for not existing route
												}
											}

										#$finished{$to_round}->{"${jump_type}_route"}	= $done{$to_round}->{route};
										$finished{$to_round}->{$jump_type}		= scalar(@{$done{$to_round}->{route}}) - 1;
										#&debug_out(qq{_sub_dijkstra_algorythm(): Route from $to_round to $origin as $jump_type ($finished{$to_round}->{$jump_type} jumps) is build:\n @{$done{$to_round}->{route}}});
										}
									else {
										&debug_out("_sub_dijkstra_algorythm(): Entry for $to_round is missing!");
										}
									}
								# And empty %done
								%done	= ();
								}

							&debug_out("_sub_dijkstra_algorythm(): returning " . &human_readable(scalar(keys(%finished))) . " routes");
							return(%finished);
							};

						#my %heuristic			= ();	# now to be understood as "jumps_all", this may differ through runtime!	OBSOLETE #1
						my @missing_heuristic		= ();
						my($min_count)			= &access_DB("SELECT count() count FROM locations_systems_with_stargates ;");
						$min_count			= 5100; #$min_count->{count} - 1;	# Currently not calculatable
						# Check, which systems doesn't have all routes
						foreach my $row ( &access_DB("SELECT lws.id origin , COUNT(rj.destination) AS count FROM locations_systems_with_stargates lws LEFT JOIN routes_jumps rj ON lws.id == rj.origin WHERE rj.origin IS NULL OR 'count' > 1 GROUP BY lws.id ;") ) { # TEST
							&debug_out("System $row->{origin} has " . &human_readable($row->{count}) . " different routes");
							if ( $row->{count} <= $min_count ) {
								push(@missing_heuristic, $row->{origin});
								}
							}

						if ( @missing_heuristic ) {
							# Add single jumps, we already know through stargates
							&access_DB("INSERT OR IGNORE INTO routes_jumps (origin, destination, jumps_all, jumps_high, jumps_low)\n" .
								" SELECT system_id, neighbour_id, 1 jumps_all, 1 jumps_high, 1 jumps_low FROM locations_stargates UNION ALL\n" .
								" SELECT neighbour_id, system_id, 1 jumps_all, 1 jumps_high, 1 jumps_low FROM locations_stargates ;");

							# Add routes, which aren't routes at all as single jumps to omit division by zero on hauls table
							&access_DB("INSERT OR IGNORE INTO routes_jumps (origin, destination, jumps_all, jumps_high, jumps_low)\n" .
								" SELECT ls.id, ls.id, 1 jumps_all, 1 jumps_high, 1 jumps_low FROM locations_systems ls;");

							# Add routes which doesn't have any stargates at all
							&access_DB("INSERT OR IGNORE INTO routes_impassable (origin, destination)\n" .
								" SELECT origin, destination FROM missing_impassable_routes;");
							}

						my $mh_divisor			= ceil(scalar(@missing_heuristic) / &get_count_of_CPUs());	# mh = missing heuristic

						foreach ( 0..9 ) {		# Maximally 10 agents

							my @systems		= splice(@missing_heuristic, 0, $mh_divisor);

							my $agent	= fork;
							# Parent
							if ( defined($agent) && $agent ) {
								push(@agency, $agent);
								&debug_out("jumps_calculator(): Started calculator agent $agent");
								Time::HiRes::sleep(0.01);
								#&wait_children($max_forks, \@agency, 150);	# replaced by CPU count!
								&wait_children(&get_count_of_CPUs(), \@agency, 150);
	
								# Report to main window
								#$perc_count	+= 20 / scalar(@stations);		# WORK Recalculate number!
								#$ac_knot->shlock;
								#$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
								#$ac_knot->shunlock;
								}
							# Child
							elsif ( defined($agent) ) {
								srand();
								local $SIG{INT}		= "DEFAULT";
								local $SIG{HUP}		= "DEFAULT";
								my @full_jumps_list		= ();

								# WORK alternative: redo from here
								heuristic_calculator:
								foreach my $system ( @systems ) {

									# Calculate jumps (heuristic)
									&debug_out("Building routes/jumps table for $system");
									my %heuristic_jumps	= &{$_sub_dijkstra_algorythm}($system);

									if ( ! %heuristic_jumps ) {
										&debug_out("No jumps found for system $system");
										}
									else {
										push(@full_jumps_list, { %heuristic_jumps });
										}
									}

								# Insert into database
								my($_sub_seperate_insert);
								my $_sub_stop_on_create = sub {
									&debug_out("_sub_stop_on_create(): $DBI::errstr");
									kill(HUP => $ppid);
									&db_token(0);
									return(0);
									};

								Time::HiRes::sleep(sprintf("%.3f", rand(15) / 10)); # For better preventing double locks at the same time
								&db_token(1);
								local $SIG{INT}		= "IGNORE";
								local $SIG{HUP}		= "IGNORE";
								my $dbh_seperate	= DBI->connect(
									$dsn,
									$user_id,
									$password,
									{
										RaiseError	=> 0,
										AutoCommit	=> 1,
										#ReadOnly	=> 0,
										},
									) or do {
										&{$_sub_stop_on_create}();
										return(0);
										};

								$dbh_seperate->do("PRAGMA foreign_keys = ON;") or do {
									&debug_out("jumps_calculator(): Can't enforce foreign keys: " . $dbh_seperate->errstr);
									#$dbh_seperate->commit();
									$dbh_seperate->disconnect();
									&db_token(0);
									exit(1);
									};

								my $infinite_blocker	= 3;

								my($sth_jumps, $_sub_redo_prepare);
								$infinite_blocker	= 3;
								$_sub_redo_prepare	= sub {
									$sth_jumps	= $dbh_seperate->prepare("REPLACE INTO routes_jumps ( origin, destination, jumps_all, jumps_high, jumps_low ) SELECT ? , ? , ? , ? , ? " .
										"EXCEPT SELECT origin, destination, jumps_all, jumps_high, jumps_low FROM routes_jumps WHERE origin == ? AND destination == ? ;") or do {
											&debug_out("orders_update_agent(): Can't set memory for journal mode " . $dbh_seperate->errstr);
											if ( $infinite_blocker-- ) {
												sleep(2);
												return(&{$_sub_redo_prepare}());
												}
											else {
												#$dbh_seperate->commit();
												$dbh_seperate->disconnect();
												&db_token(0);
												&debug_out("heuristic_calculator(): Prepare failed!");
												print STDERR "heuristic_calculator(): Prepare failed!\n";
												exit(3);
												}
											};
									};

								&{$_sub_redo_prepare}();

								&debug_out("jumps_calculator(): adding jumps to database");
								$dbh_seperate->begin_work();
								foreach my $jumps_list ( @full_jumps_list ) {
									#&debug_out("jumps_calculator(): Going to add " . &human_readable(scalar(keys(%{$jumps_list}))) . " routes to database");
									inserting:
									foreach my $calculated_jumps ( keys(%{$jumps_list}) ) {
										if ( $jumps_list->{$calculated_jumps}->{jumps_all} > 1 ) {
											#&debug_out("INSERT OR IGNORE INTO routes_jumps ( origin , destination , jumps_all ) VALUES ( $jumps_list{$calculated_jumps}->{origin} , $calculated_jumps , $jumps_list{$calculated_jumps}->{jumps} );");
											$sth_jumps->execute(
												$jumps_list->{$calculated_jumps}->{origin},
												$calculated_jumps,	# destination

												$jumps_list->{$calculated_jumps}->{jumps_all},
												$jumps_list->{$calculated_jumps}->{jumps_high},
												$jumps_list->{$calculated_jumps}->{jumps_low},

												$jumps_list->{$calculated_jumps}->{origin},
												$calculated_jumps,	# destination
												) or do {
													&debug_out("inserting(): Failed on first try: " . $dbh_seperate->errstr);
													sleep(1);
													redo(inserting);
													};

											$sth_jumps->execute(
												$calculated_jumps,	# destination
												$jumps_list->{$calculated_jumps}->{origin},

												$jumps_list->{$calculated_jumps}->{jumps_all},
												$jumps_list->{$calculated_jumps}->{jumps_high},
												$jumps_list->{$calculated_jumps}->{jumps_low},

												$calculated_jumps,	# destination
												$jumps_list->{$calculated_jumps}->{origin},
												) or do {
													&debug_out("inserting(): Failed on second try: " . $dbh_seperate->errstr);
													sleep(1);
													redo(inserting);
													};
											}
										}
									}

								$dbh_seperate->commit();
								$dbh_seperate->disconnect();
								sleep(5);
								&db_token(0);

								# Always exit children
								exit(0);
								}
							else {
								&debug_out("jumps_calculator(): Can't fork");
								}
							}

						# Wait until all agents finished their work
						&wait_children(1, \@agency, 300);

						&access_DB(qq{UPDATE characters SET done_jumps = } . &quote_DB(1) . qq{ ;});	# For ALL characters!
						}
					else {
						# WORK set $agent_carrier{progress_percent} !
						}

# Finished ######################################
					# Remember last update
					&access_DB(
						"UPDATE characters\n" .
						"SET last_update_all = " . &quote_DB(time) . "\n" .
						#"update_running = 0\n" . # Do not reset for all - this 1 will enforce the update on markets, too!
						"WHERE id == " . &quote_DB($char_id) . ";"
						);

					(tied(@receiver))->remove;
					}
				else {
					$perc_count	+= 300;
					}
				# Report to main window
				$ac_knot->shlock;
				$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
				$agent_carrier{run_update}		= "markets";
				$ac_knot->shunlock;
				$mua_all_ran				= 1;
				next(update_agent);		# Omitt reset
				}

			elsif ( $agent_carrier{run_update} eq "start" ) {
				my $char_id		= $agent_carrier{CharacterID};
				$ac_knot->shunlock;
				&debug_out("Update was requested via start");
				my $current_time	= time;
				my $omitt_reset		= 0;
				my $char_details	= [ &access_DB(
					"SELECT last_update_markets, last_update_all, update_running\n" .
					"  FROM characters\n" .
					"  WHERE id == " . &quote_DB($char_id) . ";",
					) ];

				# Decide start procedure
				if ( scalar(@{$char_details}) ) {
					$char_details	= $char_details->[0];

					# Last update of "all" is older than $max_age_all days or was interrupted
					if ( $current_time >= $char_details->{last_update_all} + $max_age_all * 24 * 60 ** 2 || $char_details->{update_running} == 1 ) {
						$ac_knot->shlock;
						$agent_carrier{run_update}	= "all";
						$ac_knot->shunlock;
						$old_st_as			= "start+all";
						$omitt_reset			= 1;
						&access_DB("VACUUM;");
						}

					# Last update of "markets" if older than $max_age_markets minutes
					elsif ( $current_time >= $char_details->{last_update_markets} + $max_age_markets * 60 || $char_details->{update_running} == 2 ) {
						$ac_knot->shlock;
						$agent_carrier{run_update}	= "markets";
						$ac_knot->shunlock;
						$old_st_as			= "start+markets";
							$omitt_reset			= 1;
							}

					# Use _sub_update_access_token() to check if token is still valid (returns true) or must be updated (returns false)
					# If false $agent_carrier{progress_text} must sbecome set to an special variable, which will be caught by Tcl and brings a dialog to let the character become deleted from local database
					if ( ! &{$_sub_update_access_token}() ) {
						&debug_out("start(): Access token is invalid");

						# Make sure all tasks of this path are finished before we exit and no stopping request interrupts
						local $SIG{HUP}			= "IGNORE";
						local $SIG{INT}			= "IGNORE";

						# Inform UI
						$ac_knot->shlock;
						$agent_carrier{run_update}	= "";
						$agent_carrier{progress_text}	= "ERROR=Character token expired - please add your character again!";
						$ac_knot->shunlock;

						# Remove character from database # unneeded!
						#&access_DB("DELETE FROM characters WHERE id == " . &quote_DB($char_id) . ";");
						#&debug_out("Removed character with id \"$char_id\" from database");

						# If characters table is empty now, delete the whole database
						my @characters_left		= &access_DB("SELECT * FROM characters;");

						if ( @characters_left ) {
							#&access_DB("VACUUM;");
							#&debug_out("Freed disk space for left characters");
							}
						if ( ! @characters_left ) {
							if ( -e $database ) {
								unlink($database);
								}
							&debug_out("Removed database, because no character exists anymore");
							}

						exit(2);
						}
					else {
						&debug_out("start(): Access token seems to be valid");
						}

						# Set in any case as long as we got an character id
					}
				else {
					$ac_knot->shlock;
					$agent_carrier{run_update}	= "";
					$agent_carrier{progress_text}	= "ERROR=Character not found - update failed";
					$ac_knot->shunlock;
					exit(1);
					}
					$perc_count	+= 2;
					$ac_knot->shlock;
					$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
					$agent_carrier{progress_text}		= "Cleaning...";
					$ac_knot->shunlock;

					# Clear all to old user specific data depending on $max_age
					my $max_age	= $current_time - ( $max_age_all + $max_age_add_to_del ) * 24 * 60 ** 2;
					# Orders
					&access_DB(
						"DELETE\n" .
						"  FROM orders_structures\n" .
						"  WHERE character_id IN (\n" .
						"    SELECT c.id\n" .
						"    FROM characters c\n" .
						"    WHERE last_update_markets < " . &quote_DB($max_age) .
						");",
						);
					$perc_count	+= 14;
					$ac_knot->shlock;
					$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
					$ac_knot->shunlock;

					# Locations
					&access_DB(
						"DELETE\n" .
						"  FROM locations_structures\n" .
						"  WHERE character_id IN (\n" .
						"    SELECT c.id\n" .
						"    FROM characters c\n" .
						"    WHERE last_update_markets < " . &quote_DB($max_age) .
						");",
						);

					# Remember denied markets as long as max age!
					&access_DB(
						"DELETE\n" .
						"  FROM denied_structures_markets\n" .
						"  WHERE character_id == " . &quote_DB($char_id) . "\n" .
						"    AND detected < " . &quote_DB($max_age) .
						";"
						);

					# Transfer
					&access_DB(
						"DELETE\n" .
						"  FROM transfer\n" .
						"  WHERE character_id == " . &quote_DB($char_id) . " ;"
						);

					# Defragment database
					#&access_DB("VACUUM;");		# Do this only on "Refresh all" from start (approximately one time a day)

					$perc_count	+= 14;
					$ac_knot->shlock;
					$agent_carrier{progress_percent}	= $perc_count / &{$_sub_percent_base}();
					$agent_carrier{progress_text}		= "Cleaning . . . done!";
					$ac_knot->shunlock;

					if ( $omitt_reset ) {
						next(update_agent);
						}
					}
				$old_st_as				= "";
				$perc_count				=  0;
				$ac_knot->shlock;
				$agent_carrier{progress_percent}	= 1;			# = 100 %
				$agent_carrier{progress_text}		= "Finished";
				$agent_carrier{run_update}		= "";		# Reset
				$ac_knot->shunlock;
				} # End of main update agent

			else { # if run_update is ""
				$ac_knot->shunlock;
				sleep(1);
				}
			}	# End of while

		&debug_out(
			"Parent $ppid seems to be dead",
			);
		exit(0);
		# End of child
		}
	else {
		&debug_out("esi_reader(): Can't fork");
		(tied(%transport))->remove;
		exit(1);
		}

	### Get characters list
	my $_sub_get_chars	= sub {
		my @tmp		= ();
		my @all_chars	= &access_DB(
			"SELECT name, id\n" .
			"  FROM characters;",
			);
		foreach my $char_row ( @all_chars ) {
			&debug_out("esi_reader(): Adding \"$char_row->{name}\" with id \"$char_row->{id}\" to Optionmenu list");
			push(@tmp, [ $char_row->{name}, $char_row->{id} ]);
			}
		return(@tmp);
		};

	if ( scalar(&{$_sub_get_chars}()) > 1 || $profile ) {

		# Ask user to choose character if more than one before starting main window
		my $sel_win	= MainWindow->new(
			%def_TL,
			);

		# Size of character choose window: 600x300
		my $ww		= 500;
		my $wh		= 200;
		my $xpos	= "+" . sprintf("%.0f", ($sel_win->screenwidth - $ww)  / 2);
		my $ypos	= "+" . sprintf("%.0f", ($sel_win->screenheight - $wh) / 2);

		&check_ssize(250, $sel_win, $ww, $wh);

		# Set window size and position
		$sel_win->geometry("${ww}x${wh}${xpos}${ypos}");
		$sel_win->resizable(0, 0);

		my $MainFrame		= $sel_win->Frame(
			-background	=> $def_bg_hex,
			)->pack(
				-fill	=> "both",
				-expand	=> 1,
				);

		# WORK Optional: Character picture?
		# https://image.eveonline.com/Character/${charid}_256.jpg

		my $Question		= $MainFrame->Label(
			%def_lab,
			-justify	=> "right",
			-text		=> "Choose character:  ",
			)->grid(
				-column	=> 0,
				-row	=> 0,
				-sticky	=> "e",
				);

		my $choosen_char	= 0;
		my $choosen_char_name	= "";
		my $start		= 0;
		my $user_add		= 0;
		my $_sub_update_char_list = sub {
			my $existing		= shift;
			my @viewable_char_list	= &{$_sub_get_chars}();

			if ( defined($existing) && Tk::Exists($existing) ) {
				$existing->destroy;
				}

			my $tmp_ddm		= $MainFrame->Optionmenu(
				%def_OptMenu,
				-options		=> \@viewable_char_list,
				-variable		=> \$choosen_char,
				-textvariable		=> \$choosen_char_name,
				)->grid(
					-column	=> 1,
					-row	=> 0,
					-sticky	=> "w",
					);

			return($tmp_ddm);
			};
		my $dropdown		= &{$_sub_update_char_list}();
		my($addChar_Button, $ButtonStart, $delChar_Button);
		my $_sub_change_btn_state	= sub {
			my $state	= ( shift ) ? "normal" : "disabled";
			foreach my $elem ( $delChar_Button, $dropdown, $addChar_Button, $ButtonStart ) {
				$elem->configure(
					-state	=> $state,
					);
				}
			};

		# Seperator
		$sel_win->Frame(
			-background	=> $def_sep_hex,
			-height		=> 2,
			-borderwidth	=> 1,
			)->pack(
				-fill	=> "x",
				-anchor	=> "n",
				-padx	=> 5,
				-pady	=> 5,
				);

		my $ChangeFrame		= $sel_win->Frame(
			-background	=> $def_bg_hex,
			)->pack(
				#-fill	=> "none",
				-pady	=> 20,
				-padx	=> 20,
				-side	=> "left",
				-anchor	=> "w",
				);

		$addChar_Button		= $ChangeFrame->Button(
			%def_btn,
			-text		=> "Add character",
			-status		=> "disabled",
			-command	=> sub {
				# Only one character allowed!
				#$user_add	= 1;
				#$sel_win->destroy;
				},
			)->pack(
				#-fill	=> "none",
				-padx	=> 1,
				-side	=> "left",
				);

		my $ButtonFrame		= $sel_win->Frame(
			-background	=> $def_bg_hex,
			)->pack(
				#-fill	=> "none",
				-pady	=> 20,
				-padx	=> 20,
				-side	=> "right",
				-anchor	=> "e",
				);

		$ButtonStart		= $ButtonFrame->Button(
			%def_btn,
			-text		=> "Start",
			-command	=> sub {
				&{$_sub_change_btn_state}(0);

				my $running	= 0;
				my $user	= "";

				my $_sub_dialog	= sub {
					my $title	= shift;
					my $text	= shift;
					my $dia	= $sel_win->Toplevel(
						%def_TL,
						-title		=> "${MainTitle}$title",
						);

					# Get sel_win's geometry
					my $mwgeo	= $sel_win->geometry();
					$mwgeo		=~ m/^([0-9]+)x([0-9]+)([+-][0-9]+)([+-][0-9]+)$/;
					my $mww		= $1;
					my $mwh		= $2;
					my $mwx		= $3;
					my $mwy		= $4;

					# Set dialog to mid of mw
					my $midx	= $mwx + $mww / 2;
					my $midy	= $mwy + $mwh / 2;
					$midx		-= 300 / 2;
					$midy		-= 120 / 2;
					$midx		= ( $midx >= 0 ) ? "+$midx" : $midx;
					$midy		= ( $midy >= 0 ) ? "+$midy" : $midy;
					$dia->geometry("300x120$midx$midy");
					$dia->resizable(0, 0);

					my $info	= $dia->Label(
						%def_lab,
						-text		=> $text,
						-wraplength	=> 250,
						)->pack;

					my($ok_btn);
					$ok_btn		= $dia->Button(
						%def_btn,
						-text		=> "OK",
						-command	=> sub {
							$dia->destroy;
							},
						)->pack;
					};

				if ( $ENV{USER} ) {
					$user	= $ENV{USER};
					}
				else {
					chomp($user = qx(whoami));
					}

				my $pid		= [ &access_DB(
					"SELECT in_use\n" .
					"FROM characters\n" .
					"WHERE id == " . &quote_DB($choosen_char) . ";",
					) ];
				$pid		= $pid->[0]->{in_use};

				my @fpid	= &access_DB(
					"SELECT in_use\n" .
					"FROM characters\n" .
					"WHERE id <> " . &quote_DB($choosen_char) . ";",
					);
				&debug_out("esi_reader(): Found PID in DB: $pid");

				# WORK Only allow one user to run the database!
				if ( !$pgrep ) {
					&debug_out("esi_reader(): No pgrep found - can't check if session is running");
					&{$_sub_dialog}("ERROR", "Can't check processes. Make sure you have »pgrep« installed!");
					&{$_sub_change_btn_state}(1);
					return(0);
					}
				else {
					foreach my $foreign_pid ( @fpid ) {
						if ( kill(0 => $foreign_pid->{in_use}) ) {
							$running	= 1;
							}
						}
					if ( $pid ) {
						open(my $ph, "-|", "$pgrep -u $user \"" . (fileparse($0))[0] . "\"") or die "Can't run pgrep\n";
							while ( my $found	= <$ph> ) {
								chomp($found);
								if ( $found == $pid ) {
									$running	= 1;
									}
								}
							close($ph);

						if ( kill(0 => $pid) ) {
							$running	= 1;
							}
						}

					if ( $running ) {
						#&debug_out("esi_reader(): Session for $choosen_char_name ($choosen_char) already running at PID $pid");
						#&{$_sub_dialog}("Double", "There is already a session for $choosen_char_name with PID $pid");
						&debug_out("esi_reader(): There's already a session running");
						&{$_sub_dialog}("Only one allowed!", "There's already a session running");
						&{$_sub_change_btn_state}(1);
						return(0);
						}
					else {
						$start	= 1;
						$sel_win->destroy;
						}
					}
				},
			)->pack(
				#-fill	=> "none",
				-padx	=> 1,
				-side	=> "right",
				);

#		# Can be done by closing the window itself
#		my $ButtonCancel	= $ButtonFrame->Button(
#			%def_btn,
#			-text		=> "Quit",
#			-command	=> sub {
#				exit(0);
#				},
#			)->pack(
#				-fill	=> "none",
#				-padx	=> 1,
#				-side	=> "right",
#				);

		$delChar_Button	= $ChangeFrame->Button(
			%def_btn,
			-text		=> "Forget Character",
			-state		=> "disabled",
			-command	=> sub {
				# Block main window
				&{$_sub_change_btn_state}(0);

				# Deleting the last Character is not allowed!
				if ( scalar(&{$_sub_get_chars}()) == 1 ) {
					my $dia	= $sel_win->Toplevel(
						%def_TL,
						-title		=> "${MainTitle}Access denied!",
						);

					# Get sel_win's geometry
					my $mwgeo	= $sel_win->geometry();
					$mwgeo		=~ m/^([0-9]+)x([0-9]+)([+-][0-9]+)([+-][0-9]+)$/;
					my $mww		= $1;
					my $mwh		= $2;
					my $mwx		= $3;
					my $mwy		= $4;

					# Set dialog to mid of mw
					my $midx	= $mwx + $mww / 2;
					my $midy	= $mwy + $mwh / 2;
					$midx		-= 300 / 2;
					$midy		-= 120 / 2;
					$midx		= ( $midx >= 0 ) ? "+$midx" : $midx;
					$midy		= ( $midy >= 0 ) ? "+$midy" : $midy;
					$dia->geometry("300x120$midx$midy");
					$dia->resizable(0, 0);

					my $info	= $dia->Label(
						%def_lab,
						-text		=> "Last character must not be deleted!",
						-wraplength	=> 250,
						)->pack;

					my $accept	= $dia->Button(
						%def_btn,
						-text		=> "OK",
						-command	=> sub {
							$dia->destroy;
							&{$_sub_change_btn_state}(1);
							},
						)->pack;
					}

				elsif ( $choosen_char ) {
					my $dia	= $sel_win->Toplevel(
						%def_TL,
						-title		=> "${MainTitle}Character delition",
						);

					# Get sel_win's geometry
					my $mwgeo	= $sel_win->geometry();
					$mwgeo		=~ m/^([0-9]+)x([0-9]+)([+-][0-9]+)([+-][0-9]+)$/;
					my $mww		= $1;
					my $mwh		= $2;
					my $mwx		= $3;
					my $mwy		= $4;

					# Set dialog to mid of mw
					my $midx	= $mwx + $mww / 2;
					my $midy	= $mwy + $mwh / 2;
					$midx		-= 440 / 2;
					$midy		-= 140 / 2;
					$midx		= ( $midx >= 0 ) ? "+$midx" : $midx;
					$midy		= ( $midy >= 0 ) ? "+$midy" : $midy;
					$dia->geometry("440x140$midx$midy");
					$dia->resizable(0, 0);

					my $info	= $dia->Label(
						%def_lab,
						-text		=> "Do you really want to remove all information of \"$choosen_char_name\"?",
						-wraplength	=> 350,
						)->pack(
							#-fill	=> "none",
							#-expand	=> 1
							-pady	=> 20,
							);

					my $reject	= $dia->Button(
						%def_btn,
						-text		=> "No, please leave it.",
						-width		=> 21,
						-command	=> sub {
							$dia->destroy;
							&{$_sub_change_btn_state}(1);
							},
						)->pack(
							#-fill	=> "none",
							-padx	=> 20,
							-pady	=> 20,
							-side	=> "left",
							#-expand	=> 1,
							);

					my($accept);
					$accept		= $dia->Button(
						%def_btn,
						-text		=> "Yes, delete!",
						-width		=> 21,
						-command	=> sub {
							foreach my $btn ( $accept, $reject ) {
								$btn->configure(
									-state	=> "disabled",
									);
								}

							$info->configure(
								-text	=> "Deleting...",
								);
							$dia->update;

							# Should delete recursively
							&access_DB(
								"DELETE\n" .
								"FROM characters\n" .
								"WHERE id == " . &quote_DB($choosen_char) . ";",
								);

							$info->configure(
								-text		=> "$Signs{tick}  Deleted.",
								-foreground	=> $Colors{green},
								);

							$dropdown	= &{$_sub_update_char_list}($dropdown);
							&{$_sub_change_btn_state}(1);

							# Wait half second until closing the dialog
							$dia->after(500, sub {
								$dia->destroy;
								});
							},
						)->pack(
							#-fill	=> "none",
							-padx	=> 20,
							-pady	=> 20,
							-side	=> "right",
							#-expand	=> 1,
							);
					}
				},
			)->pack(
				#-fill	=> "none",
				-padx	=> 1,
				-side	=> "left",
				);

		$sel_win->MainLoop;

		if ( $user_add ) {
			&pprop_exit(1);
			&win_setup("man_appIdKey");
			exit(0);
			}
		elsif ( $start ) {
			$main_knot->shlock;
			$transport{CharacterName}	= $choosen_char_name;
			$transport{CharacterID}		= $choosen_char;
			$main_knot->shunlock;
			}
		else {
			&pprop_exit();
			}
		}
	elsif ( scalar(&{$_sub_get_chars}()) == 1 ) {
		my @char	= &{$_sub_get_chars}();
		$main_knot->shlock;
		$transport{CharacterName}		= $char[0]->[0];
		$transport{CharacterID}			= $char[0]->[1];
		$main_knot->shunlock;
		}
	else {
		&err_msg(255, "FATAL ERROR", "FATAL: Characters table is empty, but exists");
		}

	# ESI Reader's main window
	$main_knot->shlock;
	my $character_id = $transport{CharacterID};
	my $esi_reader	= MainWindow->new(
		%def_TL,
		-title		=> $MainTitle . $transport{CharacterName},
		#-font		=> '*-arial-*-r-*-*-*-*-*-*-*-*-*-*'
		);
	$main_knot->shunlock;
	&up_lock(1) or do {
		&debug_out(qq{esi_reader(): Can't lock database for character "$character_id" (id)});
		&pprop_exit();
		};

	my $min_ww	= ( $esi_reader->screenwidth < 1500 ) ? $esi_reader->screenwidth : 1500;
	#my $min_wh	= ( $esi_reader->screenheight < 1175 ) ? $esi_reader->screenheight - 150 : 1175;
	my $min_wh	= ( $esi_reader->screenheight < 1240 ) ? $esi_reader->screenheight - 150 : 1240;
	#my $ww		= sprintf("%u", $esi_reader->screenwidth * 3 / 4 - 0.5);
	my $ww		= $esi_reader->screenwidth;
	my $wh		= $esi_reader->screenheight;
	my $xpos	= "+0";
	my $ypos	= "+0";
	$esi_reader->geometry("${ww}x$wh$xpos$ypos");
	$esi_reader->minsize($min_ww, $min_wh);

	my $_sub_save_geo	= sub {
		my $geo		= shift;
		$geo		= ( $geo ) ? $geo : $esi_reader->geometry();

		if ( $geo =~ m/^[0-9]+x[0-9]+[+-][0-9]+[+-][0-9]+$/ ) {
			&access_DB(
				"UPDATE characters\n" .
				"SET " .
				"geometry = " . &quote_DB($geo) . " " .
				"WHERE id == " . &quote_DB($character_id) . ";"
				);
			return(1);
			}
		else {
			return(0);
			}
		};
	$esi_reader->protocol("WM_DELETE_WINDOW", sub {
		my $geo_helper	= $esi_reader->geometry();

		$esi_reader->destroy();

		&pprop_exit(1);
		&{$_sub_save_geo}($geo_helper);

		&pprop_exit();
		});

	my $active_char	= (&access_DB(
		"SELECT id, name, cargo_maximum, investment_maximum, tax, profit_minimum, security_maximum, security_minimum, geometry, language\n" . # how to reset geometry?!
		"FROM characters\n" .
		"WHERE id == " . &quote_DB($character_id) . ";"
		))[0];

	# Use saved window size if screen is huge enough
	if ( $active_char->{geometry} =~ m/^([0-9]+)x([0-9]+)([+-][0-9]+)([+-][0-9]+)$/ ) {
		&debug_out(qq{esi_reader(): Geometry syntax check successful});
		my $dbw		= $1;
		my $dbh		= $2;
		my $dbpx	= $3;
		my $dbpy	= $4;

		if ( $dbw >= $min_ww && $dbw <= $ww
		 && $dbh >= $min_wh && $dbh <= $wh
		 && $dbpx >= 0 && $dbpx <= ( $esi_reader->screenwidth - 100 )
		 && $dbpy >= 0 && $dbpy <= ( $esi_reader->screenheight - 100 ) ) {
			&debug_out(qq{esi_reader(): Geometry information fits screen size});
			$esi_reader->geometry($active_char->{geometry});
			}
		}

	# Init for $mw widgets
	my $base_table		= "hauls";	# Radiation button
	my $base_ignores	= "locations";	# Radiation button ignores viewer
	my $force_update	=  0;
	my $old_baset		= "";		# Old base_table value
	my $old_basei		= "";		# Old base_ignores value
	#my $order_by		= "";		# DISABLED - optionally set order sting, but this is already done for the views in SQL
	my @header		= ();		# Also needed for ignores window later
	#my $sort_option		=  0;		# Boolean for sorting via profit_qm (profit per m³)
	my @purchased_header	= (
		# Good to trade
		{ dbn	=> "good",			pretty	=> "Type" },

		# Quantity & space
		{ dbn	=> "quantity",			pretty	=> "Quantity (units)" },
		{ dbn	=> "needed_space",		pretty	=> "Required cargo (m³)" },

		# Unit prices
		{ dbn	=> "sell_price",		pretty	=> "Purchase price p.u. (ISK)" },
		{ dbn	=> "buy_price",			pretty	=> "Sales price p.u. (ISK)" },

		# Locations & distance
		{ dbn	=> "from_location",		pretty	=> "Pickup location" },
		{ dbn	=> "jumps",			pretty	=> "Jumps" },
		{ dbn	=> "to_location",		pretty	=> "Drop-off location" },

		# Further Details
		{ dbn	=> "investment",		pretty	=> "Required investment (ISK)" },
		{ dbn	=> "profit",			pretty	=> "Possible profit total (ISK)" },	# Tax is subtracted here
		{ dbn	=> "revenue",			pretty	=> "Revenue total (ISK)" },
		{ dbn	=> "profit_qm",			pretty	=> "Profit per m³ (ISK)" },
		{ dbn	=> "profit_jump",		pretty	=> "Profit per jump (ISK)" },
		{ dbn	=> "profit_qm_jump",		pretty	=> "Profit per m³ per jump (ISK)" },

		# IDs
		{ dbn	=> "sell_id",			pretty	=> "Order id (seller)" },
		{ dbn	=> "buy_id",			pretty	=> "Order id (buyer)" },
		{ dbn	=> "sell_issued",		pretty	=> "Issued (seller)" },
		{ dbn	=> "buy_issued",		pretty	=> "Issued (buyer)" },
		);
	my @route_options	= (
		[ "Shorter - ignore security status", "all" ],
		[ "Safer - stay in 0.5 to 1.0 where possible", "high" ],
		[ "Less secure - stay in 0.0 to 0.4 where possible", "low" ],
		);
	my @sort_options	= (
		[ "Profit", "profit" ],
		[ "Profit / m³", "qm" ],
		[ "Profit / jump", "jumps" ],
		[ "Profit / m³ / jump", "jumps_qm" ],
		);
	my $cbtn_auto_remru	=  1;		# Automatically remove runns
	my $prompt_reload	=  0;		# After a refresh cycle was ran
	my @ignores_header	= ();
	my @type_list		= ();		# List for BrowseEntry field
	#my @from_list		= ();		# List for BrowseEntry field
	my @location_list	= ();		# List for BrowseEntry field
	# Progress/Status bar
	my $priority_lock	= 0;
	my $prog_perc		= 0.00;
	my $prog_pen		= pending->new($Signs{ball});
	my $prog_ltext		= $prog_pen->motion() . "  Starting...";
	my $match_counter	= "";
	my($prog_label);	# Needed for configuration within _sub_add_ignore()

	# Init for $mw functions
	my $machine		= 1;		# Needed for first proper setup of digit values (because whitespaces may be accepted from program but not form user)

	# Variables for entry fields and arrays for selection fields
	# BrowseEntry:Typ	(fl = full list)	# used by ignore lists and selection
	my @full_list		= ();			# Used to save full market data, which isn't the head lines nor shown in list for user (like the id, which isn't shown to the user, but needed for operations)
	my @fl_types		= ();			# (fl = full list)	# used by ignore lists and selection
	my @purchased_list	= ();
	my @ignores_list	= ();
	my @ignores_sb_id	= ();			# Ignores for sell_id and buy_id
	my %filtered_types	= (
		entry		=> "",
		entry_old	=> "",
		herachy		=> 0,
		real_list	=> [],
		choice		=> {},			# One hash, which was gathered through _select()
		);
	# Used by from, to and ignore lists
	my @fl_locations	= ();			# Used by from, to and ignore lists
	# BrowseEntry:From
	my %filtered_from	= (
		entry		=> "",
		entry_old	=> "",
		herachy		=> 1,
		real_list	=> [],
		choice		=> {},
		);
	# BrowseEntry:To
	my %filtered_to		= (
		entry		=> "",
		entry_old	=> "",
		herachy		=> 1,
		real_list	=> [],
		choice		=> {},
		);
	my %ignores_filter	= (
		entry		=> "",
		entry_old	=> "",
		#herachy	=> 0|1, # will be set within $_sub_update_ignores_table
		real_list	=> [],
		choice		=> {},
		);
	# Entry:MaxInvestment:INT
	my $hr_invest		= &human_readable(sprintf("%.2f", 10000));	# hr = human readable
	# Entry:Cargo:INT
	my $hr_cargo		= &human_readable(sprintf("%.1f", 500));
	# Entry:MinProfit:INT
	my $hr_profit		= &human_readable(sprintf("%.2f", 1000));
	# Entry:Tax:FLOAT (Tax + Broker fee)
	my $tax			= sprintf("%.2f", 5);
	# Entry:MinSec:FLOAT
	my $min_sec		= 0.5;
	# Entry:MaxSec:FLOAT
	my $max_sec		= sprintf("%.1f", 1);

	# Error output variables
	my $type_err		= "";
	my $from_err		= "";
	my $to_err		= "";
	my $inv_err		= "";
	my $prof_err		= "";
	my $cargo_err		= "";
	my $tax_err		= "";
	my $mins_err		= "";
	my $maxs_err		= "";
	my $ignores_error	= "";	# for at bottom of ignores_viewer
	my %remains		= (
		investment	=> "",
		space		=> "",
		);
	my %pur_amnt		= (	# Profit amounts
		investment	=> "",
		profit		=> "",
		revenue		=> "",
		space		=> "",
		profit_qm	=> "",
		);

	# GUI Tcl objects
	my(
		# Buttons
		$interactive,
		$extras,
		$apply,
		$rfsh_all,
		$rfsh_mrkts,

		# Radio buttons
		$rdm_haul,	# radio button mode
		$rdm_sales,
		$rdm_buys,

		# Entry fields
		$type_BEF,	# BrowseEntry Field
		$from_BEF,
		$to_BEF,
		$inv_ETY,	# invest EnTrY
		$prof_ETY,
		$cargo_ETY,
		$tax_ETY,
		$mins_ETY,	# min security
		$maxs_ETY,	# max security

		# Dropdown menus
		$route_option,
		$route_option_helper,
		$sort_option,
		$sort_option_helper,

		# Table
		$mode_bar,
		$table_frame,
		$table,
		$tlscroll,
		$tbscroll,

		# Widget objects
		$first_update,	# After object for setting "start"
		$resetter,

		# Local subfunction references
		$_sub_num_validation,
		$_sub_entry_preparation,
		$_sub_entry_postprocessing,
		$_sub_change_state,
		$_sub_update_entries,
		$_sub_update_ignores_table,
		$_sub_update_purchase_table,
		$_sub_show_ignores_table,
		$_sub_show_purchase_table,
		$_sub_add_ignore,
		$_sub_add_ignore_id,
		$_sub_add_purchase,
		$_sub_update_main_table,
		$_sub_reset_market_buttons,
		$_sub_rebuild_db,
		$_sub_apply_selection,
		$_sub_build_select_list,
		$_sub_fill_info_section,
		$_sub_perma_status_updater,
		$_sub_reload_prompter,

		## Toplevel widgets

		# Purchases table
		$purchased_viewer,
		$purchased_table,

		# Ignores table
		$ignores_viewer,
		$ignores_table,
		$ignores_frame,
		$tester,	# to check if a after() method is applied
		$rdm_locations,
		$rdm_types,

		# About window
		$about,

		# Error= window
		$err_window,

		## Info section
		# PIckup
		$pickup_region,
		$pickup_constellation,
		$pickup_system,
		$pickup_sys_sec,
		$pickup_sys_sec_label,
		$pickup_sta_str,
		$pickup_buy_price,
		$pickup_buy_price_obj,

		# Drop-off
		$drop_off_region,
		$drop_off_constellation,
		$drop_off_system,
		$drop_off_sys_sec,
		$drop_off_sys_sec_label,
		$drop_off_sta_str,
		$drop_off_sell_price,
		$drop_off_sell_price_obj,

		# Cargo
		$cargo_object,
		$cargo_quantity,
		$cargo_investment_obj,
		$cargo_investment,
		$cargo_profit_obj,
		$cargo_profit,
		);
	my %row			= (
		type		=> 0,
		from		=> 3,
		to		=> 3,
		inv		=> 6,
		prof		=> 6,
		cargo		=> 9,
		tax		=> 9,
		mins		=> 12,
		maxs		=> 12,
		route_opts	=> 15,
		sort_opts	=> 18,
		cbtn_brun	=> 24,
		);
	my %info_sec_rows	= (
		region		=> 0,
		constellation	=> 1,
		system		=> 2,
		sta_str		=> 3,
		price		=> 4,
		object		=> 0,
		quantity	=> 1,
		investment	=> 2,
		profit		=> 3,
		pur_amnt	=> {
			profit	=> 0,
			invest	=> 1,
			revenue	=> 2,
			nspace	=> 3,
			prof_qm	=> 4,
			},
		);

	# &_sub_num_validation		# Checks if it is an floating or integer number; 
	# &_sub_entry_preparation		# removes whitespaces and sets selection
	# &_sub_entry_postprocessing	# formats number in fitting length (integer places and fractional places), then writes it to the given value (for apply), and makes it human readable
	# &_sub_change_state		# Disable or enable buttons
	# &_sub_reset_market_buttons	# Decide about disabled or normal market buttons
	# &_sub_update_entries		# Compares entrie fields for changes and if this applies it writes it to the database; with "start" updates the application side and brings the values to the ui
	# &_sub_update_ignores_table	# Build table for ignores window
	# &_sub_update_purchase_table	# Build table for purchaes window
	# &_sub_show_ignores_table		# Opens the ignores table window
	# &_sub_show_purchase_table		# Opens the purchase table window
	# &_sub_update_main_table		# Generate and fill table including filters; runs _sub_update_entries() before, runs _sub_update_ignores_table and _sub_update_purchase_table if windows are open
	# &_sub_rebuild_db			# Runs _sub_change_state() and sets $transport{run_update} and start GUI agent to reenable the window and start _sub_reset_market_buttons()
	# &_sub_build_select_list		# Load lists from database for BaseEntry fields (type & location)

	# Number entry fields'
	$_sub_num_validation		= sub {
		my $err_ref		= shift;
		my $new_value		= shift;

		if ( $machine || $new_value =~ m/^-?[0-9]+(?:\.[0-9]*)?$/ || $new_value eq "" ) {
			# Accept changes by program itself
			# Accept initialize values
			# Accept integer and floating numbers
			# Accept empty field (will become 0 on postprocessing)
			${$err_ref}	= "";
			}
		else {
			# Block all other values
			${$err_ref}	= "Must be a floating point number!";
			# Reset after 2 seconds
			$esi_reader->after(2000, sub {		# Reset after 2 seconds
				${$err_ref}	= "";
				});
			return(0);
			}

		return(1);
		};

	# Number entry fields'
	$_sub_entry_preparation		= sub {		# <FocusIn>
		my $target		= shift;	# Object REFERENCE which will be used to make delete and insert
		my $editable		= shift;	# Create copy of initial value	# automatically supplied through bind method

		$editable		=~ s/\s+//g;	# Remove possible whitespaces of human_readable()

		# Replace to new value
		$target->delete(0, "end");
		$target->insert(0, $editable);

		# Remove selection if accedantelly selected
		$target->selectionClear();
		# Select all for immediate overwriting
		$target->selectionRange(0, "end");

		return(1);
		};

	# Number entry fields'
	$_sub_entry_postprocessing		= sub {		# <FocusOut>
		my $target		= shift;	# Object REFERENCE which will be used to make delete and insert
		my $opts		= shift;	# { min => -1.0 max => sprintf("%.1f", 1), dp => 1 } # dp = decimal places	# example from security
		my $editable		= shift;	# Create copy of initial value	# automatically supplied through bind method

		if ( defined($opts->{max}) && $editable >= $opts->{max} ) {
			$editable	= $opts->{max};
			}
		elsif ( defined($opts->{min}) && $editable <= $opts->{min} ) {
			$editable	= $opts->{min};
			}
		elsif ( defined($opts->{dp}) && $editable =~ m/^[0-9]+(?:\.[0-9]*)?$/ ) {
			$editable	= &human_readable(sprintf("%.$opts->{dp}f", $editable));
			}
		elsif ( defined($opts->{dp}) && $editable eq "" ) {
			$editable	= sprintf("%.$opts->{dp}f", 0);
			}
		else {
			print STDERR "FATAL ERROR: You should never read this...\n";
			&pprop_exit();
			}

		$machine		= 1;
		$target->delete(0, "end");
		$target->insert(0, $editable);
		$machine		= 0;

		return(1);
		};

	$_sub_change_state		= sub {		# Disable or enable buttons
		my $mode	= ( shift ) ? "normal" : "disable";
		my $issuer	= shift;

		if ( $mode eq "disable" ) {
#			if ( $issuer ) {
#				$issuer->configure(
#					-state	=> "disabled",
#					);
#				}
			$esi_reader->Busy(-recurse => 1);
			Time::HiRes::sleep(0.2);
			$esi_reader->update;
			Time::HiRes::sleep(0.2);
			#$interactive->Busy(-recurse => 1);
			#$mode_bar->Busy(-recurse => 1);
			}
		else {
			$esi_reader->Unbusy;
			&{$_sub_reset_market_buttons}();
			#$interactive->Unbusy;
			#$mode_bar->Unbusy;
			}

		return(1);
		};

	$_sub_fill_info_section		= sub {
		my $request	= shift;
		my $pos		= $table->info("anchor");

		if ( $request eq "reset" ) {
			(
				$pickup_region,
				$pickup_constellation,
				$pickup_system,
				$pickup_sys_sec,
				$pickup_sta_str,
				$pickup_buy_price,
				$drop_off_region,
				$drop_off_constellation,
				$drop_off_system,
				$drop_off_sys_sec,
				$drop_off_sta_str,
				$drop_off_sell_price,
				$cargo_object,
				$cargo_quantity,
				$cargo_investment,
				$cargo_profit,
				)	= (
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					);

			$pickup_buy_price_obj->configure(	-width	=> -1,);
			$drop_off_sell_price_obj->configure(	-width	=> -1,);
			$cargo_investment_obj->configure(	-width	=> -1,);
			$cargo_profit_obj->configure(		-width	=> -1,);
			}
		elsif ( $base_table !~ m/^(?:hauls|orders_(?:sells|buys))$/ ) {
			&debug_out("_sub_fill_info_section(): \"$base_table\" is not valid for \$base_table !");
			return(0);
			}
		elsif ( defined($pos) && $pos ne "" && defined($full_list[$pos]) ) {
			# Pickup details
			if ( $base_table eq "hauls" ) {
				(
					$pickup_region,
					$pickup_constellation,
					$pickup_system,
					$pickup_sys_sec,
					$pickup_sta_str,
					$pickup_buy_price,
					)	= (
						$full_list[$pos]->{from_region},
						$full_list[$pos]->{from_constellation},
						$full_list[$pos]->{from_system},
						sprintf("%.1f", $full_list[$pos]->{from_sys_security}),
						$full_list[$pos]->{from_structure_station},
						&human_readable(sprintf("%.2f", $full_list[$pos]->{sell_price})) . " ISK",
						);
				}
			elsif ( $base_table eq "orders_sells" ) {
				(
					$pickup_region,
					$pickup_constellation,
					$pickup_system,
					$pickup_sys_sec,
					$pickup_sta_str,
					$pickup_buy_price,
					)	= (
						$full_list[$pos]->{region},
						$full_list[$pos]->{constellation},
						$full_list[$pos]->{system},
						sprintf("%.1f", $full_list[$pos]->{security_status}),
						$full_list[$pos]->{location},
						&human_readable(sprintf("%.2f", $full_list[$pos]->{price})) . " ISK",
						);
				}
			else {
				(
					$pickup_region,
					$pickup_constellation,
					$pickup_system,
					$pickup_sys_sec,
					$pickup_sta_str,
					$pickup_buy_price,
					)	= (
						"",
						"",
						"",
						"",
						"",
						"",
						);
				}

			if ( $pickup_sys_sec ne "" ) {
				my $hex_color	= &get_security_color_hex($pickup_sys_sec);
				if ( defined($hex_color) && $hex_color ) {
					$pickup_sys_sec_label->configure(-foreground => $hex_color);
					}
				else {
					$pickup_sys_sec_label->configure(-foreground => $def_fg_hex);
					}
				}

			# Drop-off details
			if ( $base_table eq "hauls" ) {
				(
					$drop_off_region,
					$drop_off_constellation,
					$drop_off_system,
					$drop_off_sys_sec,
					$drop_off_sta_str,
					$drop_off_sell_price,
					)	= (
						$full_list[$pos]->{to_region},
						$full_list[$pos]->{to_constellation},
						$full_list[$pos]->{to_system},
						sprintf("%.1f", $full_list[$pos]->{to_sys_security}),
						$full_list[$pos]->{to_structure_station},
						&human_readable(sprintf("%.2f", $full_list[$pos]->{buy_price})) . " ISK",
						);
				}
			elsif ( $base_table eq "orders_buys" ) {
				(
					$drop_off_region,
					$drop_off_constellation,
					$drop_off_system,
					$drop_off_sys_sec,
					$drop_off_sta_str,
					$drop_off_sell_price,
					)	= (
						$full_list[$pos]->{region},
						$full_list[$pos]->{constellation},
						$full_list[$pos]->{system},
						sprintf("%.1f", $full_list[$pos]->{security_status}),
						$full_list[$pos]->{location},
						&human_readable(sprintf("%.2f", $full_list[$pos]->{price})) . " ISK",
						);
				}
			else {
				(
					$drop_off_region,
					$drop_off_constellation,
					$drop_off_system,
					$drop_off_sys_sec,
					$drop_off_sta_str,
					$drop_off_sell_price,
					)	= (
						"",
						"",
						"",
						"",
						"",
						"",
						);
				}

			if ( $drop_off_sys_sec ne "" ) {
				my $hex_color	= &get_security_color_hex($drop_off_sys_sec);
				if ( defined($hex_color) && $hex_color ) {
					$drop_off_sys_sec_label->configure(-foreground => $hex_color);
					}
				else {
					$drop_off_sys_sec_label->configure(-foreground => $def_fg_hex);
					}
				}

			# Cargo details
			$cargo_object	= "$full_list[$pos]->{good} (" . &human_readable($full_list[$pos]->{packaged_volume}) . " m³ p.u.)";
			if ( $base_table eq "hauls" ) {
				$cargo_quantity		= &human_readable($full_list[$pos]->{quantity}) . " units (" .  &human_readable($full_list[$pos]->{needed_space}) . " m³)";
				$cargo_investment	= &human_readable(sprintf("%.2f", $full_list[$pos]->{investment})) . " ISK";
				$cargo_profit		= &human_readable(sprintf("%.2f", $full_list[$pos]->{profit})) . " ISK";

				my $length		= 0;
				foreach my $string ( $pickup_buy_price, $drop_off_sell_price, $cargo_investment, $cargo_profit ) {
					if ( length($string) > $length ) {
						$length	= length($string);
						}
					}

				$length -= 2;
				
				$pickup_buy_price_obj->configure(	-width	=> $length,);
				$drop_off_sell_price_obj->configure(	-width	=> $length,);
				$cargo_investment_obj->configure(	-width	=> $length,);
				$cargo_profit_obj->configure(		-width	=> $length,);
				}
			else {
				$cargo_quantity		= "";
				$cargo_investment	= "";
				$cargo_profit		= "";
				}
			}
		else {
			&debug_out("_sub_fill_info_section(): \$pos not set");
			&{$_sub_fill_info_section}("reset");
			return(0);
			}

		return(1);
		};

	$_sub_update_entries	= sub {		# actual apply information from entry fields to database
		my $special	= shift; # "start" means initialize
		my @db_entries	= ();
		CORE::state %old = ();

		# Load data from database into assigned variables
		if ( defined($special) && $special eq "start" ) {
			@db_entries	= &access_DB("SELECT cargo_maximum, investment_maximum, tax, profit_minimum, security_maximum, security_minimum, sort_method, route_security " .
				"FROM characters " .
				"WHERE id == " . &quote_DB($character_id) . ";"
				);

			if ( scalar(@db_entries) == 1 ) {
				%old		= %{$db_entries[0]};

				my ($rs)	= grep { $_->[1] eq $old{route_security} } @route_options;
				my ($sm)	= grep { $_->[1] eq $old{sort_method} } @sort_options;

				$machine	= 1;
				$hr_invest	= &human_readable(sprintf("%.2f", $old{investment_maximum}));
				$hr_cargo	= &human_readable(sprintf("%.1f", $old{cargo_maximum}));
				$hr_profit	= &human_readable(sprintf("%.2f", $old{profit_minimum}));
				$tax		= sprintf("%.2f", $old{tax});
				$min_sec	= ( $old{security_minimum} <= -1.0 ) ? -1.0 : sprintf("%.1f", $old{security_minimum});
				$max_sec	= ( $old{security_maximum} >= 1 ) ? sprintf("%.1f", 1) : sprintf("%.1f", $old{security_maximum});
				$route_option	= $rs->[1];
				$sort_option	= $sm->[1];
				$route_option_helper	= $rs->[0];
				$sort_option_helper	= $sm->[0];
				$machine	= 0;
				}
			else {
				&debug_out("_sub_update_entries(): No or to many hashes got!");
				return(0);
				}
			}
		else {
			my $machine_invest	= $hr_invest;
			my $machine_cargo	= $hr_cargo;
			my $machine_profit	= $hr_profit;

			# Remove whitespaces to make it machine readable again
			$machine_invest		=~ s/\s+//g;
			$machine_cargo		=~ s/\s+//g;
			$machine_profit		=~ s/\s+//g;

			# If anything changed...
			if (
			 $machine_invest	!= $old{investment_maximum}	||
			 $machine_cargo		!= $old{cargo_maximum}		||
			 $machine_profit	!= $old{profit_minimum}		||
			 $tax			!= $old{tax}			||
			 $min_sec		!= $old{security_minimum}	||
			 $max_sec		!= $old{security_maximum}	||
			 $route_option		ne $old{route_security}		||
			 $sort_option		ne $old{sort_method}
			 ) {

				# Write to database and %old
				&access_DB("UPDATE characters " .
					"SET " .
						  "cargo_maximum = " .		&quote_DB($machine_cargo) .
						", investment_maximum = " .	&quote_DB($machine_invest) .
						", tax = " .			&quote_DB($tax) .
						", profit_minimum = " .		&quote_DB($machine_profit) .
						", security_maximum = " .	&quote_DB($max_sec) .
						", security_minimum = " .	&quote_DB($min_sec) .
						", route_security = " .		&quote_DB($route_option) .
						", sort_method = " .		&quote_DB($sort_option) . " " .
					"WHERE id == " . &quote_DB($character_id) . ";" ,
					"decontrol");

				@old{qw(cargo_maximum	investment_maximum	tax	profit_minimum		security_maximum	security_minimum	route_security	sort_method)} = (
					$machine_cargo,	$machine_invest,	$tax,	$machine_profit,	$max_sec,		$min_sec,		$route_option,	$sort_option );
				}
			}

		return(1);
		};

	$_sub_perma_status_updater	= sub {

		$main_knot->shlock;
		if ( $transport{perma_text} ) {
			$prog_ltext		= "Last update: $transport{perma_text}";
			$transport{perma_text}	= "";
			$prompt_reload		=  0;

			$prog_label->configure(
				-foreground	=> $Colors{warning_yellow},
				);
			$esi_reader->after(2_000, sub {
				$prog_label->configure(
					-foreground	=> $def_lab{-foreground},
					);
				$prompt_reload		=  1;
				$esi_reader->after(150, $_sub_reload_prompter);
				$esi_reader->update;
				});
			}

		if ( $transport{run_update} eq "" ) {
			$main_knot->shunlock;
			$rfsh_mrkts->configure(
				-text				=> "Start market updates",
				-background			=> $Colors{warning_yellow},
				-foreground			=> $def_btn{-background},
				-activebackground		=> $Colors{bright_yellow},
				-activeforeground		=> $def_btn{-background},
				);
			# Reset color after 1 second
			$esi_reader->after(1_000, sub {
				$rfsh_mrkts->configure(
					-background		=> $def_btn{-background},
					-foreground		=> $def_btn{-foreground},
					-activebackground	=> $def_btn{-activebackground},
					-activeforeground	=> $def_btn{-activeforeground},
					);
				$esi_reader->update;
				});
			}
		elsif ( $transport{run_update} eq "perm" ) {
			$main_knot->shunlock;
			$rfsh_mrkts->configure(
				-text		=> "Stop market updates",
				);
			}
		else {
			$main_knot->shunlock;
			}

		$esi_reader->after(5_000, $_sub_perma_status_updater);
		$esi_reader->update;
		return(1);
		};

	$_sub_reload_prompter			= sub {

		if ( $prompt_reload ) {
			$apply->configure(
				-background			=> $Colors{warning_yellow},
				-foreground			=> $def_btn{-background},
				-activebackground		=> $Colors{bright_yellow},
				-activeforeground		=> $def_btn{-background},
				);
			$esi_reader->after(200, sub {
				$apply->configure(
					-foreground		=> $def_btn{-foreground},
					-background		=> $def_btn{-background},
					-activebackground	=> $def_btn{-activebackground},
					-activeforeground	=> $def_btn{-activeforeground},
					);
				$esi_reader->update;
				});
			$esi_reader->after(1_000, $_sub_reload_prompter);
			}

		$esi_reader->update;
		return(1);
		};

	$_sub_update_ignores_table		= sub {		# Fill table within window
		# Check if window is open
		if ( Tk::Exists($ignores_viewer) ) {
			my $select_table	= "";
			my %BE_arguments	= ();
			my($ignores_entry);

			my $_sub_add_ignore_from_search	= sub {
				my $choice		= shift;	# Anonymous hash array
				my $table_name		= "";
				my $column_name		= "";

				&debug_out(qq{_sub_add_ignore_from_search(): Got tier "$choice->{tier}"});
				foreach my $key ( sort(keys(%{$choice})) ) {
					&debug_out(qq{_sub_add_ignore_from_search(): \$choice->{$key} = "$choice->{$key}"});
					}
				if ( $choice->{tier} eq "S" ) {
					$column_name	= "sys_id";
					$table_name	= "ignores_systems";
					}
				elsif ( $choice->{tier} eq "T" ) {
					$column_name	= "id";
					$table_name	= "ignores_types";
					}
				elsif ( $choice->{tier} eq "L" ) {
					$column_name	= "ss_id";
					$table_name	= ( &is_ccp_station($choice->{$column_name}) ) ? "ignores_stations" : "ignores_structures";
					}
				elsif ( $choice->{tier} eq "C" ) {
					$column_name	= "const_id";
					$table_name	= "ignores_constellations";
					}
				elsif ( $choice->{tier} eq "R" ) {
					$column_name	= "region_id";
					$table_name	= "ignores_regions";
					}
				else {
					&debug_out("_sub_add_ignore_from_search() used a bad tier \"$choice->{tier}\"");
					foreach my $key ( sort(keys(%ignores_filter)) ) {
						&debug_out(qq{_sub_add_ignore_from_search(): \$ignores_filter{$key} = "$ignores_filter{$key}"});
						}
					&pprop_exit(1);
					exit(128);
					}

				if ( $table_name && $column_name ) {
					&priority_lock(1);
					&access_DB(
						"REPLACE INTO $table_name VALUES (" .
						"  " . &quote_DB($choice->{$column_name}) . "," .
						"  " . &quote_DB($character_id) .
						" );" ,
						"decontrol"
						);
					&priority_lock(0);
					}

				return(1);
				};

			# Locations
			if ( $base_ignores eq "locations" ) {
				@ignores_header	= (
					{ dbn			=> "list",			pretty	=> "Type", },
					{ dbn			=> "name",			pretty	=> "Name", },
					);
				$select_table			= "ignores_overview";
				$ignores_filter{herachy}	= 1;
				%BE_arguments			= (
					listcmd			=> sub {
						&{$_sub_build_select_list}( \$ignores_entry, \@fl_locations, \%ignores_filter, \$ignores_error);
						},
					browse2cmd		=> sub {
						my $unneeded_object	= shift;
						my $ipos		= shift;

						&{$_sub_apply_selection}( \%ignores_filter, \$ignores_error, $unneeded_object, $ipos);

						# $ignores_filter->{choice}->{tier}	= already set by _sub_build_select_list()
						&{$_sub_add_ignore_from_search}($ignores_filter{choice});
						&{$_sub_update_ignores_table}();
						#&{$_sub_update_main_table}(); - to slow, do this via Apply button!
						},
					);
				}
			elsif ( $base_ignores eq "types" ) {
				@ignores_header	= (
					{ dbn			=> "name",			pretty	=> "Name", },
					);
				$select_table			= "ignored_types_overview";
				$ignores_filter{herachy}	= 0;
				%BE_arguments	= (
					listcmd			=> sub {
						&{$_sub_build_select_list}( \$ignores_entry, \@fl_types, \%ignores_filter, \$ignores_error);
						},
					browse2cmd		=> sub {
						my $unneeded_object	= shift;
						my $ipos		= shift;

						&{$_sub_apply_selection}( \%ignores_filter, \$ignores_error, $unneeded_object, $ipos);

						$ignores_filter{choice}->{tier}	= "T";
						&{$_sub_add_ignore_from_search}($ignores_filter{choice});
						&{$_sub_update_ignores_table}();
						#&{$_sub_update_main_table}(); - to slow, do this via Apply button!
						},
					);
				}
			else {
				&debug_out("_sub_update_ignores_table(): Got bad \$base_ignores \"$base_ignores\"");
				return(0);
				}

			if ( $base_ignores ne $old_basei || ! Tk::Exists($ignores_frame) ) {
				$old_basei	= $base_ignores;

				if ( Tk::Exists($ignores_frame) ) {
					$ignores_frame->destroy();
					}

				$ignores_frame		= $ignores_viewer->Frame(
					-background	=> $def_bg_hex,
					)->pack(
						-side	=> "top",
						-fill	=> "both",
						-expand	=> 1,
						);

				# BrowseEntry field
				$ignores_entry		= $ignores_frame->BrowseEntry(
					%def_BE,
					-variable	=> \$ignores_filter{entry},
					-listcmd	=> \$BE_arguments{listcmd},
					-browse2cmd	=> \$BE_arguments{browse2cmd},
					-autolistwidth	=> 0,
					-listwidth	=> 800,
					-listheight	=> 400,
					# WORK Set size nearly like window width!
					)->pack(
						-side	=> "top",
						-fill	=> "x",
						#-expand	=> 1,
						);
				$ignores_entry->bind('<FocusIn>' => sub {
					$ignores_entry->selectionClear();
					$ignores_entry->selectionRange(0, "end");
					});
				$ignores_entry->bind('<ButtonRelease-1>' => sub {
					$ignores_entry->selectionClear();
					$ignores_entry->selectionRange(0, "end");
					});

				my $right_scroll	= $ignores_frame->Scrollbar(
					%def_scr,
					)->pack(
						-side	=> "right",
						-fill	=> "y",
						);

				$ignores_table		= $ignores_frame->HList(
					%def_HL,
					-columns	=> scalar(@ignores_header),
					-command	=> sub  {
						my $pos		= $ignores_table->info("anchor");

						# Remove purchase on double click and update views
						if ( $pos ne "" ) {
							my $delete_table	= "";
							my $id_name		= "";

							# Select delete table
							if ( ! defined($ignores_list[$pos]->{list}) ) {
								$delete_table	= "ignores_types";
								$id_name	= "type_id";
								}
							elsif ( $ignores_list[$pos]->{list} eq "Structure" ) {
								$delete_table	= "ignores_structures";
								$id_name	= "structure_id";
								}
							elsif ( $ignores_list[$pos]->{list} eq "Station" ) {
								$delete_table	= "ignores_stations";
								$id_name	= "station_id";
								}
							elsif ( $ignores_list[$pos]->{list} eq "System" ) {
								$delete_table	= "ignores_systems";
								$id_name	= "system_id";
								}
							elsif ( $ignores_list[$pos]->{list} eq "Constellation" ) {
								$delete_table	= "ignores_constellations";
								$id_name	= "constellation_id";
								}
							elsif ( $ignores_list[$pos]->{list} eq "Region" ) {
								$delete_table	= "ignores_regions";
								$id_name	= "region_id";
								}
							else {
								&debug_out("_sub_update_ignores_table(): \$ignores_list[\$pos]->{list} = \"$ignores_list[$pos]->{list}\"");
								return(0);
								}

							&priority_lock(1);
							&access_DB(
								"DELETE FROM $delete_table " .
								"  WHERE character_id = " . &quote_DB($character_id) .
								"  AND $id_name =  " . &quote_DB($ignores_list[$pos]->{id}) .
								";" ,
								"decontrol"
								);
							&priority_lock(0);

							# Update purchased_viewer
							$ignores_table->delete("entry", $pos);

							# Update main table - to slow, do this via Apply button!
							#&{$_sub_update_main_table}();
							return(1);
							}
						},
					-yscrollcommand	=> [
						set	=> $right_scroll,
						],
					)->pack(
						-side	=> "right",
						-fill	=> "both",
						-expand	=> 1,
						);

				$right_scroll->configure(
					-command	=> [
						yview	=> $ignores_table,
						],
					);

				for ( my $col = 0 ; $col < scalar(@ignores_header) ; $col++ ) {
					$ignores_table->header(
						"create",
						$col,
						-text			=> $ignores_header[$col]->{pretty},
						%def_Header,
						);
					}
				}

			$ignores_table->delete("all");

			if ( ! $priority_lock ) {
				&priority_lock(1);
				&db_lock(1, "decontrol");
				}
			# Select table
			@ignores_list		= &access_DB("SELECT * FROM $select_table WHERE character_id = " . &quote_DB($character_id) . ";");
			if ( ! $priority_lock ) {
				&db_lock(0);
				&priority_lock(0);
				}

			# Fill table
			for ( my $row = 0 ; $row < scalar(@ignores_list) ; $row++ ) {
				$ignores_table->add($row);
				for ( my $column = 0 ; $column < scalar(@ignores_header) ; $column++ ) {
					$ignores_table->item(
						"create",
						$row,
						$column,
						-text			=> $ignores_list[$row]->{$ignores_header[$column]->{dbn}},
						);
					}
				}
			}
		return(1);
		};

	$_sub_update_purchase_table		= sub {		# Fill table within window
		# Check if window is open
		if ( Tk::Exists($purchased_table) ) {
			$purchased_table->delete("all");

			if ( ! $priority_lock ) {
				&priority_lock(1);
				&db_lock(1, "decontrol");
				}
			@purchased_list	= &access_DB("SELECT * FROM purchased WHERE character_id = " . &quote_DB($character_id) . " ORDER BY to_location ;");
			if ( ! $priority_lock ) {
				&db_lock(0);
				&priority_lock(0);
				}

			for ( my $row = 0 ; $row < scalar(@purchased_list) ; $row++ ) {
				$purchased_table->add($row);
				for ( my $col = 0 ; $col < scalar(@purchased_header) ; $col++ ) {
					$purchased_table->item(
						"create",
						$row,
						$col,
						-text			=> &human_readable($purchased_list[$row]->{$purchased_header[$col]->{dbn}}),
						);
					}
				}
			}
		return(1);
		};

	$_sub_show_ignores_table	= sub {
		if ( ! Tk::Exists($ignores_viewer) ) {
			my $bgeo	= $esi_reader->geometry();	# get base geometry
			my $itw		= 800;
			my $ith		= 700;
			my $itx		= "+0";
			my $ity		= "+0";
			$base_ignores	= "locations";

			# Calculate central placing geometry string
			# $bgeo = 1919x1364+-2+0 Problem??
			if ( $bgeo =~ m/^([0-9]+)x([0-9]+)\+?([+-][0-9]+)\+?([+-][0-9]+)$/ ) {
				my $bw	= $1;
				my $bh	= $2;
				my $bx	= $3;
				my $by	= $4;

				$itx	= sprintf("%+d", sprintf("%.0f", ( $bx + $bw / 2 ) - $itw / 2));
				$ity	= sprintf("%+d", sprintf("%.0f", ( $by + $bh / 2 ) - $ith / 2));
				}
			else {
				&debug_out("_sub_show_ignores_table(): can't distungish ESI-Readers geometry as \"$bgeo\"");
				return(0);
				}

			# Build toplevel widget
			$main_knot->shlock;
			$ignores_viewer		= $esi_reader->Toplevel(
				%def_TL,
				-title		=> "$MainTitle$transport{CharacterName} - Ignores",
				);
			$main_knot->shunlock;

			# Set window size and position
			$ignores_viewer->geometry("${itw}x${ith}${itx}${ity}");
			$ignores_viewer->resizable(0, 0);

			my $ignores_mode_bar	= $ignores_viewer->Frame(
				-background	=> $def_bg_hex,
				)->pack(
					-side	=> "top",
					-fill	=> "x",
					#-expand	=> 1,
					);

			my %ignores_mode_rdbtn	= (	
				%def_rdbtn,
				-variable	=> \$base_ignores,
				-indicatoron	=> 0,
				);

			# Radiation button Locations
			$rdm_locations		= $ignores_mode_bar->Radiobutton(	# RaDiobutton Mode bar (=rdm)
				%ignores_mode_rdbtn,
				-text		=> "Locations",
				-value		=> "locations",
				-foreground	=> $def_bg_hex,
				-command	=> sub {
					&{$_sub_update_ignores_table}();

					$rdm_locations->configure(	-foreground	=> $def_bg_hex, );
					$rdm_types->configure(		-foreground	=> $def_fg_hex, );
					},
				)->grid(
					-column	=> 0,
					-row	=> 0,
					-sticky	=> "nsew",
					);

			# Radiation button Goods To Ignore
			$rdm_types		= $ignores_mode_bar->Radiobutton(	# RaDiobutton Mode bar (=rdm)
				%ignores_mode_rdbtn,
				-text		=> "Types",
				-value		=> "types",
				-command	=> sub {
					&{$_sub_update_ignores_table}();

					$rdm_types->configure(		-foreground	=> $def_bg_hex, );
					$rdm_locations->configure(	-foreground	=> $def_fg_hex, );
					},
				)->grid(
					-column	=> 1,
					-row	=> 0,
					-sticky	=> "nsew",
					);

			foreach my $col ( 0..1 ) {
				$ignores_mode_bar->gridColumnconfigure($col, -weight => 1);
				}

			my $ignores_statusbar	= $ignores_viewer->Frame(
				-background	=> $def_bg_hex,
				)->pack(
					-side	=> "bottom",
					-fill	=> "x",
					#-expand	=> 1,
					-anchor	=> "w",
					);

			my $ignores_error_label	= $ignores_statusbar->Label(
				%def_lab,
				-textvariable	=> \$ignores_error,
				)->pack(
					-side	=> "left",
					-anchor	=> "w",
					);
			}

		&{$_sub_update_ignores_table}();
		$ignores_viewer->deiconify();
		$ignores_viewer->raise();
		return(1);
		};

	$_sub_show_purchase_table	= sub {		# Build window
		if ( ! Tk::Exists($purchased_viewer) ) {
			my $bgeo	= $esi_reader->geometry();	# get base geometry
			my $ptw		= 1000;
			my $pth		= 800;
			my $ptx		= "+0";
			my $pty		= "+0";

			# Calculate central placing geometry string
			if ( $bgeo =~ m/^([0-9]+)x([0-9]+)([+-][0-9]+)([+-][0-9]+)$/ ) {
				# 1819x1078+202+116
				my $bw	= $1;
				my $bh	= $2;
				my $bx	= $3;
				my $by	= $4;

				$ptx	= sprintf("%+d", sprintf("%.0f", ( $bx + $bw / 2 ) - $ptw / 2));
				$pty	= sprintf("%+d", sprintf("%.0f", ( $by + $bh / 2 ) - $pth / 2));
				}
			else {
				&debug_out("_sub_show_purchase_table(): can't distungish ESI-Readers geometry as \"$bgeo\"");
				return(0);
				}


			# Build toplevel widget
			$main_knot->shlock;
			$purchased_viewer	= $esi_reader->Toplevel(
				%def_TL,
				-title		=> "$MainTitle$transport{CharacterName} - Purchased orders",
				);
			$main_knot->shunlock;

			# Set window size and position
			$purchased_viewer->geometry("${ptw}x${pth}${ptx}${pty}");
			#$purchased_viewer->resizable(0, 0);

			my $right_scroll	= $purchased_viewer->Scrollbar(
				%def_scr,
				)->grid(
					-column	=> 1,
					-row	=> 0,
					-sticky	=> "ns",
					);
			my $bottom_scroll	= $purchased_viewer->Scrollbar(
				%def_scr,
				-orient		=> "horizontal",
				)->grid(
					-column	=> 0,
					-row	=> 1,
					-sticky	=> "we",
					);

			$purchased_table	= $purchased_viewer->HList(
				%def_HL,
				-columns	=> scalar(@purchased_header),
				-command	=> sub {
					my $pos		= $purchased_table->info("anchor");

					# Remove purchase on double click and update views
					if ( $pos ne "" ) {
						&{$_sub_change_state}(0);

						&priority_lock(1);
						&access_DB(
							"DELETE FROM purchased " .
							"  WHERE character_id = " . &quote_DB($character_id) .
							"  AND type_id =  " . &quote_DB($purchased_list[$pos]->{type_id}) .
							"  AND sell_id =  " . &quote_DB($purchased_list[$pos]->{sell_id}) .
							"  AND buy_id =  " . &quote_DB($purchased_list[$pos]->{buy_id}) .
							";" ,
							"decontrol"
							);
						&priority_lock(0);

						# WORK switched table update sequence, because it seems to be blocking completely.

						# Update purchased_viewer
						&{$_sub_update_purchase_table}();

						# Update main table
						&{$_sub_update_main_table}();

						&{$_sub_change_state}(1);
						}
					},
				-yscrollcommand	=> [
					set	=> $right_scroll,
					],
				-xscrollcommand	=> [
					set	=> $bottom_scroll,
					],
				)->grid(
					-column	=> 0,
					-row	=> 0,
					-sticky	=> "nswe",
					);

			$right_scroll->configure(
				-command	=> [
					yview	=> $purchased_table,
					],
				);

			$bottom_scroll->configure(
				-command	=> [
					xview	=> $purchased_table,
					],
				);

			$purchased_viewer->Frame(				# Free space in the corner between the scroll bar ends at south-east
				-background	=> $def_bg_hex,
				)->grid(
					-column	=> 1,
					-row	=> 1,
					-sticky	=> "nswe",
					);

			$purchased_viewer->gridColumnconfigure(0, -weight => 1);
			$purchased_viewer->gridRowconfigure(0, -weight => 1);

			for ( my $col = 0 ; $col < scalar(@purchased_header) ; $col++ ) {
				$purchased_table->header(
					"create",
					$col,
					-text			=> $purchased_header[$col]->{pretty},
					%def_Header,
					);
				}
			}

		# Show "Purchases" window if not already open, otherwhise update it's view this must happen in a subfunction, because this is also usable from the extras menu
		# If window exists, bring it in front with $mw->raise - https://docstore.mik.ua/orelly/perl3/tk/ch13_19.htm#INDEX-1958
		&{$_sub_update_purchase_table}();
		$purchased_viewer->deiconify();
		$purchased_viewer->raise();
		return(1);
		};

	$_sub_add_ignore_id		= sub {
		my $column_name		= shift;
		my $pos			= $table->info("anchor");

		if ( defined($pos) && $pos ne "" && !( grep { $_->{key} eq $column_name && $_->{value} == $full_list[$pos]->{$column_name} } @ignores_sb_id ) ) {	# Omitt empty position or already added ignores
			&debug_out("Adding filter $column_name for $full_list[$pos]->{$column_name}");
			push(@ignores_sb_id, { key => $column_name,	value => $full_list[$pos]->{$column_name} });
			}

		return(1);
		};

	$_sub_add_ignore		= sub {		# Add to ignore list and update windows
		my $tier		= shift;
		my $column_name		= shift;
		my $pos			= $table->info("anchor");

		# use @full_list and $table->info("anchor") to destungish the other values
		if ( defined($pos) && $pos ne "" ) {
			my $table	= "";
			if ( $tier eq "S" ) {
				$table	= "ignores_systems";
				}
			elsif ( $tier eq "T" ) {
				$table	= "ignores_types";
				}
			elsif ( $tier eq "L" ) {
				$table	= ( &is_ccp_station($full_list[$pos]->{$column_name}) ) ? "ignores_stations" : "ignores_structures";
				}
			elsif ( $tier eq "C" ) {
				$table	= "ignores_constellations";
				}
			elsif ( $tier eq "R" ) {
				$table	= "ignores_regions";
				}
			else {
				&debug_out("_sub_add_ignore() used bad tier \"$tier\"");
				exit(128);
				}

			&priority_lock(1);
			&access_DB(
				"REPLACE INTO $table VALUES (" .
				"  " . &quote_DB($full_list[$pos]->{$column_name}) . "," .
				"  " . &quote_DB($full_list[$pos]->{character_id}) .
				" );" ,
				"decontrol"
				);
			&priority_lock(0);

			# Update tables... - to slow, do this via Apply button!
			#&{$_sub_update_main_table}();
			&{$_sub_update_ignores_table}();
			}
		else {
			# This must not continue, if a after() is already running, this is just the same error again!
			if ( defined($prog_label->afterInfo($tester)) ) {
				return(0);
				}

			# Remember former text
			my $prog_ltext_old	= $prog_ltext;

			# Write warning
			$prog_ltext		= "No row was selected - nothing added to ignore lists";

			# Change font color to red
			$prog_label->configure(
				-foreground	=> $Colors{red},
				);

			#$prog_label->cancel();
			$tester	= $prog_label->after(10_000, sub {		# 10.0 s
				# Change font color back to normal
				$prog_label->configure(
					-foreground	=> $def_lab{-foreground},
					);

				# Change text back to former text
				$prog_ltext	= $prog_ltext_old;
				});
			return(0);
			}
		return(1);
		};

	$_sub_add_purchase		= sub {
		my $pos		= $table->info("anchor");	# Current INDEX of table list for @full_list, persistent unless whole table is emptied and reloaded so don't touch @full_list!
		# Do NOT remove element from @full_list, because the index numbers of HList are NOT updated on deletions as Perl does it on arrays!

		# Insert element from @full_list into the purchased db table
		if ( $pos ne "" ) {
			&{$_sub_change_state}(0);

			&priority_lock(1);
			&access_DB(
				"REPLACE INTO purchased VALUES (" .
				"  " . &quote_DB($full_list[$pos]->{sell_id})		. "," .
				"  " . &quote_DB($full_list[$pos]->{buy_id})		. "," .
				"  " . &quote_DB($full_list[$pos]->{character_id})	. "," .
				"  " . &quote_DB($full_list[$pos]->{type_id})		. "," .
				"  " . &quote_DB($full_list[$pos]->{investment})	. "," .
				"  " . &quote_DB($full_list[$pos]->{profit})		. "," .
				"  " . &quote_DB($full_list[$pos]->{profit_qm})		. "," .
				"  " . &quote_DB($full_list[$pos]->{profit_jump})	. "," .
				"  " . &quote_DB($full_list[$pos]->{profit_qm_jump})	. "," .
				"  " . &quote_DB($full_list[$pos]->{revenue})		. "," .
				"  " . &quote_DB($full_list[$pos]->{good})		. "," .
				"  " . &quote_DB($full_list[$pos]->{from_location})	. "," .
				"  " . &quote_DB($full_list[$pos]->{sell_price})	. "," .
				"  " . &quote_DB($full_list[$pos]->{quantity})		. "," .
				"  " . &quote_DB($full_list[$pos]->{to_location})	. "," .
				"  " . &quote_DB($full_list[$pos]->{buy_price})		. "," .
				"  " . &quote_DB($full_list[$pos]->{needed_space})	. "," .
				"  " . &quote_DB($full_list[$pos]->{sell_issued})	. "," .
				"  " . &quote_DB($full_list[$pos]->{buy_issued})	. "," .
				"  " . &quote_DB($full_list[$pos]->{jumps})	.
				"  );" ,
				"decontrol"
				);
			&priority_lock(0);

			# Remove element from main table (update table)
			&{$_sub_update_main_table}();	# Can't be omitted even if it is slow, because it changes values...

			&{$_sub_show_purchase_table}(); # Calls _sub_update_purchase_table() and raise() itself in any case

			&{$_sub_change_state}(1);
			}

		return(1);
		};

	$_sub_update_main_table		= sub {
		my $where		= "";
		my @menuitems		= ();
		my @filter		= ();
		my $mc_helper		= "";
		my $sort_helper		= "";
		my($_sub_sort_helper);

		# Menu item builds
		my @haul_menu_elem	= (
			[
				Button		=> "Hauling list",
				%def_buttonmenu,
				-command	=> \$_sub_show_purchase_table,
				],
			[
				Button		=> "Empty hauling list",
				%def_buttonmenu,
				-command	=> sub {
						my $removed	= 0;

						&priority_lock(1);
						&db_lock(1, "decontrol");
						&db_lock(0);
						if ( scalar(&access_DB("SELECT * FROM purchased WHERE character_id == " . &quote_DB($character_id) . " ;")) > 0 ) {
							$removed	= 1;
							}

						&access_DB(
							"DELETE FROM purchased " .
							"  WHERE character_id = " . &quote_DB($character_id) .
							";" ,
							"decontrol"
							);
						&priority_lock(0);

						if ( $removed ) {
							# Update purchased_viewer
							&{$_sub_update_purchase_table}();

							# Update main table
							&{$_sub_update_main_table}();
							}
					},
				],
			"-",
			[
				Cascade		=> "Ignore...",
				%def_menu,
				-menuitems	=> [
					[
						Cascade		=> "Pickup location",
						%def_menu,
						-menuitems	=> [
							[
								Button		=> "Region",
								%def_buttonmenu,
								-command	=> [ $_sub_add_ignore, "R", "from_rid", ],
								],
							[
								Button		=> "Constellation",
								%def_buttonmenu,
								-command	=> [ $_sub_add_ignore, "C", "from_cid", ],
								],
							[
								Button		=> "System",
								%def_buttonmenu,
								-command	=> [ $_sub_add_ignore, "S", "from_sid", ],
								],
							[
								Button		=> "Station",
								%def_buttonmenu,
								-command	=> [ $_sub_add_ignore, "L", "from_ssid", ],
								],
							"-",
							[
								Button			=> "Order id (seller)",
								%def_buttonmenu,
								-command		=> [ $_sub_add_ignore_id, "sell_id", ],
								],
							],
						],
					[
						Cascade		=> "Drop-off location",
						%def_menu,
						#-borderwidth	=> $def_btn{-borderwidth},
						-menuitems	=> [
							[
								Button		=> "Region",
								%def_buttonmenu,
								-command	=> [ $_sub_add_ignore, "R", "to_rid", ],
								],
							[
								Button		=> "Constellation",
								%def_buttonmenu,
								-command	=> [ $_sub_add_ignore, "C", "to_cid", ],
								],
							[
								Button		=> "System",
								%def_buttonmenu,
								-command	=> [ $_sub_add_ignore, "S", "to_sid", ],
								],
							[
								Button		=> "Station",
								%def_buttonmenu,
								-command	=> [ $_sub_add_ignore, "L", "to_ssid", ],
								],
							"-",
							[
								Button			=> "Order id (buyer)",
								%def_buttonmenu,
								-command		=> [ $_sub_add_ignore_id, "buy_id", ],
								],
							],
						],
					[ # Ignore... -> Type
						Button			=> "Type",
						%def_buttonmenu,
						-command		=> [ $_sub_add_ignore, "T", "type_id", ],
						],
					"-",
					[
						Button			=> "Stop ignoring order ids",
						%def_buttonmenu,
						-command		=> sub {
							@ignores_sb_id	= ();

							&{$_sub_update_main_table}();
							},
						],
					],
				],
			"-",
			#[	# Now done by Optionmenu
				#Checkbutton	=> ( ( $sort_option ) ? "Sort by profit" : "Sort by profit/m³" ),
				#%def_menu_cbtn,
				#-indicatoron	=> 1,
				#-variable	=> \$sort_option,
				#-command	=> sub {
					#&debug_out("_sub_update_main_table(): Set \$sort_option to $sort_option");
					## Update main table
					#&{$_sub_update_main_table}();
					#},
				#],
			);

		my @sale_menu_elem	= (						# orders_sells only knows system_id and station_id, but not const, region and so on...
			[
				Cascade		=> "Ignore...",
				%def_menu,
				#-borderwidth	=> $def_btn{-borderwidth},
				-menuitems	=> [
					[
						Button		=> "Region",
						%def_buttonmenu,
						-command	=> [ $_sub_add_ignore, "R", "region_id", ],
						],
					[
						Button		=> "Constellation",
						%def_buttonmenu,
						-command	=> [ $_sub_add_ignore, "C", "constellation_id", ],
						],
					[
						Button		=> "System",
						%def_buttonmenu,
						-command	=> [ $_sub_add_ignore, "S", "system_id", ],
						],
					[
						Button		=> "Station",
						%def_buttonmenu,
						-command	=> [ $_sub_add_ignore, "L", "location_id", ],
						],
					[
						Button		=> "Type",
						%def_buttonmenu,
						-command	=> [ $_sub_add_ignore, "T", "type_id", ],
						],
					],
				],
			);

		my @purch_menu_elem	= (						# orders_buys only knows system_id and station_id, but not const, region and so on...
			[
				Cascade		=> "Ignore...",
				%def_menu,
				-menuitems	=> [
					[
						Button		=> "Region",
						%def_buttonmenu,
						-command	=> [ $_sub_add_ignore, "R", "region_id", ],
						],
					[
						Button		=> "Constellation",
						%def_buttonmenu,
						-command	=> [ $_sub_add_ignore, "C", "constellation_id", ],
						],
					[
						Button		=> "System",
						%def_buttonmenu,
						-command	=> [ $_sub_add_ignore, "S", "system_id", ],
						],
					[
						Button		=> "Station",
						%def_buttonmenu,
						-command	=> [ $_sub_add_ignore, "L", "location_id", ],
						],
					[
						Button		=> "Type",
						%def_buttonmenu,
						-command	=> [ $_sub_add_ignore, "T", "type_id", ],
						],
					],
				],
			);

		my @basic_menu_elem	= (
			[
				Button		=> "Ignores",
				%def_buttonmenu,
				-command	=> $_sub_show_ignores_table,
				],
# Only one character allowed/needed!
#			"-",
#			[
#				Button		=> "Add character",
#				%def_buttonmenu,
#				-command	=> sub {
#					$run_setup	= 1;
#					&{$_sub_save_geo}();
#					$esi_reader->destroy;
#					},
#				],
			"-",
			[
				Button		=> "About",
				%def_buttonmenu,
				-command	=> sub {
					if ( ! Tk::Exists($about) ) {
						my $bgeo		= $esi_reader->geometry();
						my $about_width		= 400;
						my $about_height	= 200;
						my $about_x		= "+0";
						my $about_y		= "+0";

						# Calculate central placing geometry string
						if ( $bgeo =~ m/^([0-9]+)x([0-9]+)([+-][0-9]+)([+-][0-9]+)$/ ) {
							my $bw		= $1;
							my $bh		= $2;
							my $bx		= $3;
							my $by		= $4;

							$about_x	= sprintf("%+d", sprintf("%.0f", ( $bx + $bw / 2 ) - $about_width / 2));
							$about_y	= sprintf("%+d", sprintf("%.0f", ( $by + $bh / 2 ) - $about_height / 2));
							}
						else {
							&debug_out("show_about_window(): can't distungish ESI-Readers geometry as \"$bgeo\"");
							return(0);
							}

						# Build top level widget
						$about			= $esi_reader->Toplevel(
							%def_TL,
							-title		=> "${MainTitle}About",
							);

						# Set window size and position
						$about->geometry("${about_width}x${about_height}${about_x}${about_y}");
						$about->resizable(0, 0);

						my $header		= $about->Label(
							%def_lab,
							-font		=> "* 15",
							-justify	=> "center",
							#-wraplength	=> $about->reqwidth(),
							-text		=> "EVE Swagger Interface Reader",
							)->pack(
								-side	=> "top",
								-fill	=> "both",
								-expand	=> 1,
								);

						my $body		= $about->Label(
							%def_lab,
							-justify	=> "center",
							#-wraplength	=> $about->reqwidth(),
							-text		=> "ESI Reader is licensed under the GNU General Public License v3\n(https://www.gnu.org/licenses/gpl-3.0.en.html)\n\nCopyright © 2019-" . ( (localtime)[5] + 1900 ) . " Dominik Bernhardt\ndomasprogrammer\@gmail.com\n\nhttps://github.com/DomAsProgrammer",
							)->pack(
								-side	=> "top",
								-fill	=> "both",
								-expand	=> 1,
								);
						}

					$about->raise();
					return(1);
					}
				],
			);

		if ( $base_table eq "hauls" ) {
			#$order_by	= "ORDER BY profit DESC, investment, needed_space";
			# sell_id     buy_id      character_id  type_id     investment  profit      good        needed_space  packaged_volume  from_location                          from_region  from_rid    from_constellation  from_cid    from_system  from_sid    from_sys_security  from_structure_station  from_ssid   sell_price  quantity    to_location                           to_region   to_rid      to_constellation  to_cid      to_system   to_sid      to_sys_security  to_structure_station  to_ssid     buy_price
			@header		= (
				# Good to trade
				{ dbn	=> "good",			pretty	=> "Type" },
				{ dbn	=> "sell_id",			pretty	=> "Order id (seller)" },
				{ dbn	=> "buy_id",			pretty	=> "Order id (buyer)" },
				{ dbn	=> "profit",			pretty	=> "Possible profit total (ISK)" },	# Tax and investment is subtracted here
				{ dbn	=> "profit_qm",			pretty	=> "Profit per m³ (ISK)" },
				{ dbn	=> "profit_jump",		pretty	=> "Profit per jump (ISK)" },
				{ dbn	=> "profit_qm_jump",		pretty	=> "Profit per m³ per jump (ISK)" },
				{ dbn	=> "investment",		pretty	=> "Required investment (ISK)" },
				{ dbn	=> "revenue",			pretty	=> "Revenue total (ISK)" },		# Without investment

				# Pickup location
				{ dbn	=> "quantity",			pretty	=> "Quantity (units)" },
				{ dbn	=> "sell_price",		pretty	=> "Purchase price p.u. (ISK)" },
				{ dbn	=> "from_structure_station",	pretty	=> "Pickup location" },

				# Distance
				{ dbn	=> "jumps",			pretty	=> "Jumps" },

				# Drop-off location
				{ dbn	=> "buy_price",			pretty	=> "Sales price p.u. (ISK)" },
				{ dbn	=> "to_structure_station",	pretty	=> "Drop-off location" },

				# Further Details
				{ dbn	=> "packaged_volume",		pretty	=> "Packaged volume p.u. (m³)" },
				{ dbn	=> "needed_space",		pretty	=> "Required cargo (m³)" },
				{ dbn	=> "sell_issued",		pretty	=> "Issued (seller)" },
				{ dbn	=> "buy_issued",		pretty	=> "Issued (buyer)" },
				);

			# Change $extras menubutton menu content
			@menuitems	= ( @haul_menu_elem, @basic_menu_elem );

			if ( ( defined($filtered_from{entry}) && $filtered_from{entry} && $filtered_from{entry} eq $filtered_from{entry_old} && $filtered_from{choice} )
			 || ( defined($filtered_to{entry}) && $filtered_to{entry} && $filtered_to{entry} eq $filtered_to{entry_old} && $filtered_to{choice} )
			 || ( defined($filtered_types{entry}) && $filtered_types{entry} && $filtered_types{entry} eq $filtered_types{entry_old} && $filtered_types{choice} )
			 ) {
				$where			= ""; # empty string (unneed) # THIS IS TO SLOW!
				push(@filter, { key => "character_id", value => $character_id });

				if ( defined($filtered_from{entry}) && $filtered_from{entry}
				 && $filtered_from{entry} eq $filtered_from{entry_old}
				 && $filtered_from{choice}
				 ) {
					if ( $filtered_from{choice}->{tier} eq "R" ) {
						#$where		= " from_rid == " . &quote_DB($filtered_from{choice}->{region_id});
						push(@filter, { key => "from_rid",	value => $filtered_from{choice}->{region_id} });
						}
					elsif ( $filtered_from{choice}->{tier} eq "C" ) {
						#$where		= " from_cid == " . &quote_DB($filtered_from{choice}->{const_id});
						push(@filter, { key => "from_cid",	value => $filtered_from{choice}->{const_id} });
						}
					elsif ( $filtered_from{choice}->{tier} eq "S" ) {
						#$where		= " from_sid == " . &quote_DB($filtered_from{choice}->{sys_id});
						push(@filter, { key => "from_sid",	value => $filtered_from{choice}->{sys_id} });
						}
					elsif ( $filtered_from{choice}->{tier} eq "L" ) {
						#$where		= " from_ssid == " . &quote_DB($filtered_from{choice}->{ss_id});
						push(@filter, { key => "from_ssid",	value => $filtered_from{choice}->{ss_id} });
						}
					}

				if ( defined($filtered_to{entry}) && $filtered_to{entry}
				 && $filtered_to{entry} eq $filtered_to{entry_old}
				 && $filtered_to{choice}
				 ) {

					if ( $where ) {
						$where		.= " AND";
						}

					if ( $filtered_to{choice}->{tier} eq "R" ) {
						#$where		.= " to_rid == " . &quote_DB($filtered_to{choice}->{region_id});
						push(@filter, { key => "to_rid",	value => $filtered_to{choice}->{region_id} });
						}
					elsif ( $filtered_to{choice}->{tier} eq "C" ) {
						#$where		.= " to_cid == " . &quote_DB($filtered_to{choice}->{const_id});
						push(@filter, { key => "to_cid",	value => $filtered_to{choice}->{const_id} });
						}
					elsif ( $filtered_to{choice}->{tier} eq "S" ) {
						#$where		.= " to_sid == " . &quote_DB($filtered_to{choice}->{sys_id});
						push(@filter, { key => "to_sid",	value => $filtered_to{choice}->{sys_id} });
						}
					elsif ( $filtered_to{choice}->{tier} eq "L" ) {
						#$where		.= " to_ssid == " . &quote_DB($filtered_to{choice}->{ss_id});
						push(@filter, { key => "to_ssid",	value => $filtered_to{choice}->{ss_id} });
						}
					}

				if ( defined($filtered_types{entry}) && $filtered_types{entry}
				 && $filtered_types{entry} eq $filtered_types{entry_old}
				 && $filtered_types{choice}
				 ) {
					if ( $where ) {
						$where		.= " AND";
						}

					#$where		.= " type_id == " . &quote_DB($filtered_types{choice}->{id});
					push(@filter, { key => "type_id", value => $filtered_types{choice}->{id} });
					}

				if ( $where ) {
					$where			=  " WHERE $where";
					}
				}
			else {
				$where			= "";
				}

			#&debug_out(qq{_sub_update_main_table(): \$sort_option is "$sort_option"});

			if ( $sort_option eq "qm" ) {
				&debug_out(qq{_sub_update_main_table(): Setting _sub_sort_helper() to "qm" mode});
				#$sort_helper		= " ORDER BY profit_qm DESC, profit DESC, investment, needed_space ";
				$_sub_sort_helper	= sub { $b->{profit_qm} <=> $a->{profit_qm} || $b->{profit} <=> $a->{profit} || $a->{investment} <=> $b->{investment} || $a->{needed_space} <=> $b->{needed_space} };
				}
			elsif ( $sort_option eq "jumps" ) {
				&debug_out(qq{_sub_update_main_table(): Setting _sub_sort_helper() to "jumps" mode});
				#$sort_helper		= " ORDER BY profit_jump DESC, profit DESC, investment, needed_space ";
				$_sub_sort_helper	= sub { $b->{profit_jump} <=> $a->{profit_jump} || $b->{profit} <=> $a->{profit} || $a->{investment} <=> $b->{investment} || $a->{needed_space} <=> $b->{needed_space} };
				}
			elsif ( $sort_option eq "jumps_qm" ) {
				&debug_out(qq{_sub_update_main_table(): Setting _sub_sort_helper() to "jumps_qm" mode});
				#$sort_helper		= " ORDER BY profit_qm_jump DESC, profit DESC, investment, needed_space ";
				$_sub_sort_helper	= sub { $b->{profit_qm_jump} <=> $a->{profit_qm_jump} || $b->{profit} <=> $a->{profit} || $a->{investment} <=> $b->{investment} || $a->{needed_space} <=> $b->{needed_space} };
				}
			else {	# Profit is default sorting
				&debug_out(qq{_sub_update_main_table(): Setting _sub_sort_helper() to "profit" mode});
				#$sort_helper		= " ";
				$_sub_sort_helper	= sub { $b->{profit} <=> $a->{profit} || $a->{investment} <=> $b->{investment} || $a->{needed_space} <=> $b->{needed_space} };
				}
			}
		elsif ( $base_table eq "orders_sells" ) {
			#$order_by	= "ORDER BY os.price, os.volume_remain DESC";
			# orders_sells(volume_total,volume_remain,price,duration,issued,good,packaged_volume,location,system,security_status,constellation,region,source_table)
			@header		= (
				{ dbn	=> "good",			pretty	=> "Type" },
				{ dbn	=> "volume_remain",		pretty	=> "Quantity (units)" },
				{ dbn	=> "price",			pretty	=> "Price (ISK)" },
				{ dbn	=> "location",			pretty	=> "Location" },	# Station / Structure
				{ dbn	=> "packaged_volume",		pretty	=> "Volume per unit (packaged) (m³)" },
				{ dbn	=> "range",			pretty	=> "Range" },
				{ dbn	=> "issued",			pretty	=> "Issued" },
				{ dbn	=> "id",			pretty	=> "Order id (seller)" },

				# Only from array from SQL statement ; must not be included into @header, because it would distort the counter for the header
				#{ dbn	=> "id" },
				#{ dbn	=> "volume_total" },
				#{ dbn	=> "duration" },
				#{ dbn	=> "character_id" },
				#{ dbn	=> "type_id" },
				#{ dbn	=> "location_id" },				# Station / Structure
				#{ dbn	=> "system_id" },
				#{ dbn	=> "source_table" },
				);

			# Change $extras menubutton menu content
			@menuitems	= ( @sale_menu_elem, @basic_menu_elem );

			if ( ( defined($filtered_from{entry}) && $filtered_from{entry} && $filtered_from{entry} eq $filtered_from{entry_old} && $filtered_from{choice} )
			 || ( defined($filtered_types{entry}) && $filtered_types{entry} && $filtered_types{entry} eq $filtered_types{entry_old} && $filtered_types{choice} )
			 ) {
				$where			= ""; # empty string

				if ( defined($filtered_from{entry}) && $filtered_from{entry}
				 && $filtered_from{entry} eq $filtered_from{entry_old}
				 && $filtered_from{choice}
				 ) {
					if ( $filtered_from{choice}->{tier} eq "R" ) {
						$where		= " system_id IN ( SELECT DISTINCT sys_id FROM locations_indices WHERE region_id == " . &quote_DB($filtered_from{choice}->{region_id}) . " )";
						}
					elsif ( $filtered_from{choice}->{tier} eq "C" ) {
						$where		= " system_id IN ( SELECT DISTINCT sys_id FROM locations_indices WHERE const_id == " . &quote_DB($filtered_from{choice}->{const_id}) . " )";
						}
					elsif ( $filtered_from{choice}->{tier} eq "S" ) {
						$where		= " system_id == " . &quote_DB($filtered_from{choice}->{sys_id});
						}
					elsif ( $filtered_from{choice}->{tier} eq "L" ) {
						$where		= " location_id == " . &quote_DB($filtered_from{choice}->{ss_id});		# structures are in a total different id range as stations
						}
					}

				if ( defined($filtered_types{entry}) && $filtered_types{entry}
				 && $filtered_types{entry} eq $filtered_types{entry_old}
				 && $filtered_types{choice}
				 ) {

					if ( $where ) {
						$where		.= " AND";
						}

					$where		.= " type_id == " . &quote_DB($filtered_types{choice}->{id});
					}

				$where			=  "WHERE $where";
				}
			else {
				$where			= "";
				}
			}
		elsif ( $base_table eq "orders_buys" ) {
			#$order_by	= "ORDER BY os.price DESC, os.volume_remain DESC";
			# orders_buys(volume_total,volume_remain,price,duration,issued,"good,packaged_volume,location,system,security_status,constellation,region,source_table)
			@header		= (
				{ dbn	=> "good",			pretty	=> "Type" },
				{ dbn	=> "volume_remain",		pretty	=> "Quantity (units)" },
				{ dbn	=> "price",			pretty	=> "Price (ISK)" },
				{ dbn	=> "location",			pretty	=> "Location" },	# Station / Structure
				{ dbn	=> "packaged_volume",		pretty	=> "Volume per unit (packaged) (m³)" },
				{ dbn	=> "range",			pretty	=> "Range" },
				{ dbn	=> "issued",			pretty	=> "Issued" },
				{ dbn	=> "id",			pretty	=> "Order id (buyer)" },
				);

			# Change $extras menubutton menu content
			@menuitems	= ( @purch_menu_elem, @basic_menu_elem );

			if ( ( defined($filtered_types{entry}) && $filtered_types{entry} && $filtered_types{entry} eq $filtered_types{entry_old} && $filtered_types{choice} )
			 || ( defined($filtered_to{entry}) && $filtered_to{entry} && $filtered_to{entry} eq $filtered_to{entry_old} && $filtered_to{choice} )
			 ) {
				$where			= ""; # empty string

				if ( defined($filtered_to{entry}) && $filtered_to{entry}
				 && $filtered_to{entry} eq $filtered_to{entry_old}
				 && $filtered_to{choice}
				 ) {
					if ( $filtered_to{choice}->{tier} eq "R" ) {
						$where		= " system_id IN ( SELECT DISTINCT sys_id FROM locations_indices WHERE region_id == " . &quote_DB($filtered_to{choice}->{region_id}) . " )";
						}
					elsif ( $filtered_to{choice}->{tier} eq "C" ) {
						$where		= " system_id IN ( SELECT DISTINCT sys_id FROM locations_indices WHERE const_id == " . &quote_DB($filtered_to{choice}->{const_id}) . " )";
						}
					elsif ( $filtered_to{choice}->{tier} eq "S" ) {
						$where		= " system_id == " . &quote_DB($filtered_to{choice}->{sys_id});
						}
					elsif ( $filtered_to{choice}->{tier} eq "L" ) {
						$where		= " location_id == " . &quote_DB($filtered_to{choice}->{ss_id});
						}
					}

				if ( defined($filtered_types{entry}) && $filtered_types{entry}
				 && $filtered_types{entry} eq $filtered_types{entry_old}
				 && $filtered_types{choice}
				 ) {

					if ( $where ) {
						$where		.= " AND";
						}

					$where		.= " type_id == " . &quote_DB($filtered_types{choice}->{id});
					}

				$where			=  " WHERE $where";
				}
			else {
				$where			= "";
				}
			}
		else {
			&debug_out("_sub_update_main_table(): \"$base_table\" is not valid for \$base_table !");
			return(0);
			}

		# Reset unset entries
		if ( !$filtered_from{entry} ) {
			$filtered_from{choice}	= {};
			}
		if ( !$filtered_to{entry} ) {
			$filtered_to{choice}	= {};
			}
		if ( !$filtered_types{entry} ) {
			$filtered_types{choice}	= {};
			}

		if ( $base_table ne $old_baset ) { # Only rebuild table, if type has changed
			$old_baset	= $base_table;

			if ( Tk::Exists($table_frame) ) {
				$table_frame->destroy();
				}

			$table_frame	= $esi_reader->Frame(
				-background	=> $def_bg_hex,
				)->pack(
					-side	=> "top",
					-fill	=> "both",
					-expand	=> 1,
					);

			$tlscroll	= $table_frame->Scrollbar(
				%def_scr,
				)->grid(
					-column	=> 1,
					-row	=> 0,
					-sticky	=> "ns",
					);
			$tbscroll	= $table_frame->Scrollbar(
				%def_scr,
				-orient		=> "horizontal",
				)->grid(
					-column	=> 0,
					-row	=> 1,
					-sticky	=> "we",
					);
			$table		= $table_frame->HList(
				%def_HL,
				-columns		=> scalar(@header),	# Creates columns belonging to the count of header
				#-command		=>				# Defines, what should be done on double clicking an entry, but see below
				-browsecmd		=> \$_sub_fill_info_section,	# Defines, what should be done if something is selected
				-yscrollcommand		=> [
					set		=> $tlscroll,
					],
				-xscrollcommand		=> [
					set		=> $tbscroll,
					],
				)->grid(
					-column	=> 0,
					-row	=> 0,
					-sticky	=> "nswe",
					);
			$tlscroll->configure(
				-command	=> [
					yview	=> $table,
					],
				);
			$tbscroll->configure(
				-command	=> [
					xview	=> $table,
					],
				);

			# Set command function
			if ( $base_table eq "hauls" ) {
				$table->configure(
					-command	=> \$_sub_add_purchase,
					);
				}

			$table_frame->Frame(				# Free space in the corner between the scroll bar ends at south-east
				-background	=> $def_bg_hex,
				)->grid(
					-column	=> 1,
					-row	=> 1,
					-sticky	=> "nswe",
					);

			$table_frame->gridRowconfigure(0, -weight => 1);
			$table_frame->gridColumnconfigure(0, -weight => 1);

			# Set up header lines
			for ( my $col = 0 ; $col < scalar(@header) ; $col++ ) {
				$table->header(
					"create",
					$col,
					-text			=> $header[$col]->{pretty},
					%def_Header,
					);
				}
			}

		my $temp_menu	= $extras->Menu(
			%def_menu,
			-borderwidth	=> $def_btn{-borderwidth},
			-menuitems	=> \@menuitems,
			);

		$extras->configure(
			-menu		=> $temp_menu,
			);

		# Gather tables from database
		if ( $where ) {
			$where	.= " AND character_id == " . &quote_DB($character_id);
			}
		else {
			$where	.= " WHERE character_id == " . &quote_DB($character_id);
			}

		# Clear table
		$match_counter	= "Recalculating list - please be patient!";
		$table->delete("all");
		$table->update();
		$prog_label->focus();
		$esi_reader->update();

		&priority_lock(1);
		$priority_lock	= 1;
		&db_lock(1, "decontrol");
		# Free all other db_locks
		&db_lock(0);
		&{$_sub_update_entries}();

		$prompt_reload		= 0;
		if ( $base_table eq "hauls" ) {
			# Get table list
			# The grep was missed in the base build
			@full_list	= grep { $_->{character_id} == $character_id } &access_DB("SELECT * FROM $base_table ;");	# This is most time to slow # where and order by clause must be done via Perl to increase speed ( @filter and &{$_sub_sort} )
			#@full_list	= &main_table_perl_join($character_id);	# On much rows it is very slow compared to SQL

			@ignores_sb_id	= grep { !( exists($_->{auto}) ) } @ignores_sb_id;	# Remove all automatically added entries
			if ( $cbtn_auto_remru ) {
				my %bid_helper	= ();

				foreach my $entry ( @full_list ) {
					if ( defined($bid_helper{$entry->{buy_id}}) ) {
						$bid_helper{$entry->{buy_id}}++;
						}
					else {
						$bid_helper{$entry->{buy_id}}	= 1;
						}
					}

				foreach my $threshold ( grep { $bid_helper{$_} >= 5 } keys(%bid_helper) ) {
					push(@ignores_sb_id, { key => "buy_id",	value => $threshold, auto => "buy_run", });
					}
				}

			#push(@filter, { key => "from_cid",	value => $filtered_from{choice}->{const_id} });
			&debug_out("_sub_update_main_table(): Filtering through Perl grep");
			foreach my $filter ( @filter ) {
				&debug_out("_sub_update_main_table(): Filtering $filter->{key} for $filter->{value} out of " . &human_readable(scalar(@full_list)) . " elements");
				@full_list	= grep { $_->{$filter->{key}} == $filter->{value} } @full_list;
				&debug_out("_sub_update_main_table(): " . &human_readable(scalar(@full_list)) . " elements left");
				}

			foreach my $filter ( @ignores_sb_id ) {
				&debug_out("_sub_update_main_table(): Removing $filter->{key} for $filter->{value} out of " . &human_readable(scalar(@full_list)) . " elements");
				@full_list	= grep { $_->{$filter->{key}} != $filter->{value} } @full_list;
				&debug_out("_sub_update_main_table(): " . &human_readable(scalar(@full_list)) . " elements left");
				}

			@full_list	= sort $_sub_sort_helper @full_list;

			$mc_helper	= ( ( scalar(@full_list) == 1 ) ? "1 opportunity match your criteria" : &human_readable(scalar(@full_list)) . " opportunities match your criteria" ) .
				#"; sorted by " . ( ( $sort_option ) ? "profit/m³" : "profit" ) .

				( ( @ignores_sb_id ) ? ( ( scalar(@ignores_sb_id) == 1 ) ? "; 1 order ignored" : "; " . scalar(@ignores_sb_id) . " orders ignored" ) : "" );
			}
		else {
			# Get table list
			@full_list	= &access_DB("SELECT * FROM $base_table $where $sort_helper ;");

			$mc_helper	= ( scalar(@full_list) == 1 ) ? "1 order match your criteria" : &human_readable(scalar(@full_list)) . " orders match your criteria";
			}

		$table->update();
		$esi_reader->update();

		# Fill @type_list, @location_list
		@fl_types	= &access_DB("SELECT * FROM market_types;");
		@fl_locations	= &access_DB("SELECT * FROM locations_indices;");

		&{$_sub_update_ignores_table}();
		&{$_sub_update_purchase_table}();
		&{$_sub_fill_info_section}("reset");

		# Leftovers
		my @remains	= &access_DB("SELECT money, cargo FROM leftovers lo WHERE lo.character_id == " . &quote_DB($character_id) . " AND EXISTS (\n" .
			"SELECT p.character_id FROM purchased p WHERE character_id == " . &quote_DB($character_id) . " );"
			);

		if ( scalar(@remains) == 1 ) {

			$remains{investment}	= &human_readable(sprintf("%.2f", $remains[0]->{money})) . " ISK";
			$remains{space}		= &human_readable(sprintf("%.1f", $remains[0]->{cargo})) . " m³";

			my @profit_amounts		= &access_DB("SELECT * FROM purchase_amounts WHERE character_id == " . &quote_DB($character_id) . " ;");
			$pur_amnt{investment}		= &human_readable(sprintf("%.2f", $profit_amounts[0]->{sum_investment})) . " ISK";
			$pur_amnt{profit}		= &human_readable(sprintf("%.2f", $profit_amounts[0]->{sum_profit})) . " ISK";
			$pur_amnt{revenue}		= &human_readable(sprintf("%.2f", $profit_amounts[0]->{sum_revenue})) . " ISK";
			$pur_amnt{space}		= &human_readable(sprintf("%.1f", $profit_amounts[0]->{sum_needed_space})) . " m³";
			$pur_amnt{profit_qm}		= &human_readable(sprintf("%.2f", $profit_amounts[0]->{avg_profit_qm})) . " ISK/m³";
			}
		else {
			$remains{investment}		= "all";
			$remains{space}			= "all";

			$pur_amnt{investment}		= "";
			$pur_amnt{profit}		= "";
			$pur_amnt{revenue}		= "";
			$pur_amnt{space}		= "";
			$pur_amnt{profit_qm}		= "";
			}
		&priority_lock(0);
		$priority_lock	= 0;

		# Insert database data into table
		for ( my $row = 0 ; $row < scalar(@full_list) ; $row++ ) {
			$table->add($row);
			for ( my $column = 0 ; $column < scalar(@header) ; $column++ ) {
				$table->item(
					"create",
					$row,
					$column,
					-text			=> &human_readable($full_list[$row]->{$header[$column]->{dbn}}),
					);
				}
			}

		# Adapt size of columns to fitting size to content
		for ( my $column = 0 ; $column < scalar(@header) ; $column++ ) {
			$table->columnWidth($column, '')
			}

		# Inform user
		$match_counter	= "Finished!";
		$esi_reader->after(500, sub {
			$match_counter	= $mc_helper;
			});

		return(1);
		};

	$_sub_reset_market_buttons		= sub {
		my $last_update		= [ &access_DB(qq{SELECT last_update_all AS "all", last_update_markets AS markets FROM characters WHERE id == } . &quote_DB($character_id) . " ;") ];
		my $current_time	= time;
		my $still_disabled	= 0;
		my $next_run		= 0;

		if ( @{$last_update} ) {
			$last_update			= $last_update->[0];

			$last_update->{all_time}	= $last_update->{all} + $min_age_all * 60 + 1;
			$last_update->{markets_time}	= $last_update->{markets} + $min_age_markets * 60 + 1;
			&debug_out(
				qq{_sub_reset_market_buttons(): Set all_time to "$last_update->{all_time}" (init: $last_update->{all})},
				qq{_sub_reset_market_buttons(): Set markets_time to "$last_update->{markets_time}" (init: $last_update->{markets})},
				);
			}
		else {
			&debug_out("_sub_reset_market_buttons(): Got no character details");
			return(0);
			}

		# ALL
		# If all is longer away than $min_age_all minutes + 1s
		if ( $current_time > $last_update->{all_time} ) {
			$rfsh_all->configure(	-state	=> "normal");
			&debug_out("_sub_reset_market_buttons(): rfsh_all enabled");
			}
		else {
			$rfsh_all->configure(	-state	=> "disabled");
			&debug_out("_sub_reset_market_buttons(): rfsh_all disabled");
			$still_disabled	+= 1;
			}

		# MARKETS
=begin not_longer_needed1
		# If markets is longer away than $min_age_markets minutes + 1s
		if ( $current_time > $last_update->{markets_time} ) {
			$rfsh_mrkts->configure(	-state	=> "normal");
			&debug_out("_sub_reset_market_buttons(): rfsh_mrkts enabled");
			}
		else {
			$rfsh_mrkts->configure(	-state	=> "disabled");
			&debug_out("_sub_reset_market_buttons(): rfsh_mrkts disabled");
			$still_disabled	+= 2;
			}
=end not_longer_needed1
=cut

		# Decide how long to wait...
		if ( $still_disabled == 1 ) {
			$next_run	= $last_update->{all_time};	# s
			}
		elsif ( $still_disabled == 2 ) {
			$next_run	= $last_update->{markets_time};	# s
			}
		elsif ( $still_disabled == 3 ) {
			$next_run	= ( $last_update->{all_time} < $last_update->{markets_time} ) ? $last_update->{all_time} : $last_update->{markets_time};	# seconds
			}

		&debug_out(qq{_sub_reset_market_buttons(): Still disabled = "$still_disabled"});

		# Restart if something is still disabled
		if ( $next_run && $still_disabled ) {
			my $nr		= ( $next_run - time + 1 ) * 1000;
			&debug_out(qq{_sub_reset_market_buttons(): Next run = "$next_run" seconds - round about at } . localtime(($next_run + 1)));
			$resetter	= $esi_reader->after($nr, $_sub_reset_market_buttons);
			}

		return(1);
		};

	$_sub_rebuild_db		= sub {
		my $target	= shift;	# all, markets, start
		my($status_updater);

		# Disable all
		&{$_sub_change_state}(0);

		# Disable refresh buttons
		#$rfsh_mrkts->configure(	-state	=> "disabled");
		$rfsh_all->configure(	-state	=> "disabled");

		# Set start tag
		$main_knot->shlock;
		$transport{run_update}	= $target;
		$main_knot->shunlock;

		# Updater of progress bar and start for _sub_reset_market_buttons()
		$status_updater	= sub {
			$main_knot->shlock;

			# Check $transport{progress_text} for "ERROR=" and what is the problem
			if ( $transport{progress_text} =~ m/^ERROR\=(.+)$/ || !( kill(0 => $update_agent) ) ) {
				my $error	= $1; # "ERROR=Character token expired" or "ERROR=Character not found - update failed"
				my $bgeo	= $esi_reader->geometry();
				my $err_width	= 400;
				my $err_height	= 300;
				my $err_x	= "+0";
				my $err_y	= "+0";
				my $desc	= "";

				if ( ( !( defined($error) ) || !$error ) && !( kill(0 => $update_agent) ) ) {
					$error	= qq{D-Reaper attacked!};
					}

				# Calculate central placing geometry string
				if ( $bgeo =~ m/^([0-9]+)x([0-9]+)([+-][0-9]+)([+-][0-9]+)$/ ) {
					my $bw	= $1;
					my $bh	= $2;
					my $bx	= $3;
					my $by	= $4;
	
					$err_x	= sprintf("%+d", sprintf("%.0f", ( $bx + $bw / 2 ) - $err_width / 2));
					$err_y	= sprintf("%+d", sprintf("%.0f", ( $by + $bh / 2 ) - $err_height / 2));
					}
				else {
					&debug_out("status_updater(): can't distungish ESI-Readers geometry as \"$bgeo\"");
					return(0);
					}

				$main_knot->shlock;
				$err_window	= $esi_reader->Toplevel(
					%def_TL,
					-title	=> "${MainTitle}$transport{CharacterName} - $error",
					);
				$main_knot->shunlock;

				$err_window->geometry("${err_width}x${err_height}${err_x}${err_y}");
				$err_window->resizable(0, 0);

				# Force quitting program
				$err_window->protocol("WM_DELETE_WINDOW", sub {
					$err_window->destroy();
					$esi_reader->destroy();
					(tied(%transport))->remove;
					&pprop_exit();
					});

				# Build window and show error message, then $esi_reader->destroy on closing this new window
				my $header		= $err_window->Label(
					%def_lab,
					-font		=> "* 10",
					-text		=> $error,
					-justify	=> "center",
					-wraplength	=> $err_window->reqwidth - 20,
					-padx		=> 10,
					-pady		=> 10,
					)->pack(
						-side	=> "top",
						#-fill	=> "both",
						#-expand	=> 1,
						);

				my $body		= $err_window->Label(
					%def_lab,
					-textvariable	=> \$desc,
					-justify	=> "left",
					-wraplength	=> $err_window->reqwidth - 20,
					-padx		=> 10,
					-pady		=> 10,
					)->pack(
						%def_lab_pack,
						);

				# Decide, what is written in the window
				if ( $error eq "Character token expired" ) {
					$desc		= 
						qq{This happens, when a character wasn't logged in for to long time. CCP changes the update token to enforce you / the application to sign in again.\n} .
						qq{If you have multiple characters signed into ESI Reader go to\n} .
						qq{[Extras] -> [Add character].\n} .
						qq{Otherwhise the application will behave like on this start.};
					}
				elsif ( $error eq "Character not found - update failed" ) {
					$desc		=
						qq{Something really wired happened. Maybe you should consider this as an bug and report to the programmer on GitHub: Domasprogrammer.\n} .
						qq{Further connection details are at\n[Extras] -> [About].};
					}
				elsif ( $error eq "D-Reaper attacked!" ) {
					$desc		=
						qq{The update agent died. Report to development, and supply debug and error messages if possible!\n} .
						qq{You find output files at /tmp/esi-reader.out , /tmp/esi-reader.err and /tmp/esiR_debug.log\n} .
						qq{To get everything running again you usually need only to restart ${app_name}. ;-)};
					}

				$esi_reader->withdraw();
				return(1);
				}

			$prog_perc	= sprintf("%.2f", $transport{progress_percent} * 100);
			$prog_ltext	= $prog_pen->motion() . "  " . $transport{progress_text};

			# Get run_update what was set after start
			if ( $target eq "start" && $transport{run_update} && $target ne $transport{run_update} ) {
				$target	= $transport{run_update};
				}
			
			# If reached 100 %
			if ( $transport{progress_percent} >= 1 ) {
				# If run update was reset by agent
				if ( !$transport{run_update} ) {
					$transport{progress_percent}	= 0.00;
					$transport{progress_text}	= "Starting...";
					$main_knot->shunlock;
					&debug_out(qq{status_updater(): Finished!});

					my $last	= [ &access_DB("SELECT last_update_all, last_update_markets FROM characters WHERE id == " . &quote_DB($character_id) . " ;") ];
					if ( scalar(@{$last}) == 1 ) {
						$last	= ( $last->[0]->{last_update_all} > $last->[0]->{last_update_markets} ) ? localtime($last->[0]->{last_update_all}) : localtime($last->[0]->{last_update_markets});
						}
					else {
						$last	= localtime();
						}

					$prog_perc	= 0.00;
					$prog_ltext	= "Last update: $last";

					# Method to reset the buttons
					&{$_sub_reset_market_buttons}();

					# Update main table
					&{$_sub_update_main_table}();

					# Enable window again
					&{$_sub_change_state}(1);

					$esi_reader->after(4_900, sub {	# 4,9 sec
						$main_knot->shlock;
						if ( ! $transport{run_update} ) {
							$transport{run_update}	= "perm";
							}
						$main_knot->shunlock;
						return(1);
						});
					}
				else {
					$main_knot->shunlock;
					&debug_out(qq{status_updater(): Finished, but master fork is doing afterwork - restarting myself});
					$esi_reader->after(251, $status_updater);
					}
				}
			else {
				$main_knot->shunlock;
				&debug_out(qq{status_updater(): Not finished yet - restarting myself});
				$esi_reader->after(251, $status_updater);
				}
			};
		$esi_reader->after(251, $status_updater);	# Prime number
		return(1);
		};

	# BrowseEntries
	$_sub_apply_selection	= sub {
		my $working_lst	= shift;	# e.g. \%filtered_types
		my $error_ref	= shift;	# e.g. \$type_err

		# Handed over from -browse2cmd
		shift;		# not needed object
		my $index_pos	= shift;
		
		if ( defined($index_pos) && $index_pos =~ m/^[0-9]+$/ && $index_pos >= 0 && defined($working_lst->{real_list}->[$index_pos]) ) {
			&debug_out(qq{_sub_apply_selection(): Saving selection: "$index_pos"});
			$working_lst->{choice}	= $working_lst->{real_list}->[$index_pos];
			${$error_ref}		= "";

			# Clear entry from tree symbols
			$working_lst->{entry}	=~ s/^[
				\s
				$Signs{junction}
				$Signs{branch}
				$Signs{turnoff}
				$Signs{cord}
				]+//xxg;

			# WORK add a file for checking and resetting the entry, to prevent false results if the entry field was changed without _sub_apply_selection
			$working_lst->{entry_old}	= $working_lst->{entry};
			}

		return(1);
		};

	# BrowseEntries
	$_sub_build_select_list	= sub {
		my $working_obj	= shift;	# e.g. \$type_BEF
		my $base_list	= shift;	# e.g. \@fl_types
		my $working_lst	= shift;	# e.g. \%filtered_types
		my $error_ref	= shift;	# e.g. \$type_err
		my @hr_list	= ();

		#&debug_out("${$working_obj}, @{$base_list}, $working_lst, $error_ref = ${$error_ref}\n");

=begin debug_sbsl
		&debug_out("\@base_list start");
		foreach my $hash ( @{$base_list} ) {
			foreach ( sort(keys(%{$hash})) ) {
				&debug_out("$_ = $hash->{$_}\n");
				}
			&debug_out(" ");
			}
		&debug_out("\@base_list end");

		foreach my $key ( sort(keys(%{$working_lst})) ) {
			&debug_out("_sub_build_select_list(): working_lst{$key}	= ${$working_lst}{$key}\n");
			}
=end debug_sbsl
=cut

		# Remove whitspaces at front and end
		$working_lst->{entry}	=~ s/^\s+|\s+$//g;

		# Counter without ANY whitespaces
		my $length		= $working_lst->{entry};
		$length			=~ s/\s+//g;
		$length			= length($length);

		# No search entry
		if ( $working_lst->{entry} eq "" && defined($error_ref) ) {

			# Report for user
			${$error_ref}	= "Filter empty";
			$esi_reader->after(30000, sub {
				${$error_ref}	= "";
				});
			return(0);
			}
		# To short filter entry - not counting whitespaces
		elsif ( $length < 3 && defined($error_ref) ) {

			# Report for user
			${$error_ref}	= "Enter at least three characters!";
			$esi_reader->after(30000, sub {
				${$error_ref}	= "";
				});
			return(0);
			}

		# Empty list in any case
		${$working_obj}->delete(0, "end");

		# Real filter
		# Types
		if ( !$working_lst->{herachy} ) {
			# Columns: id, name
			$working_lst->{real_list}		= [ grep { $_->{name} =~ m/$working_lst->{entry}/i } @{$base_list} ];
			if ( @{$working_lst->{real_list}} ) {
				&debug_out("_sub_build_select_list(): real_list is not empty");
				$working_lst->{real_list}	= [ sort { CORE::fc($a->{name}) cmp CORE::fc($b->{name}) } @{$working_lst->{real_list}} ];
				foreach my $entry ( @{$working_lst->{real_list}} ) {
					&debug_out(qq{_sub_build_select_list(): Added "$entry->{name}" to \@hr_list"});
					push(@hr_list, $entry->{name});
					}
				#return(1);
				}
			else {	# Nothing found
				&debug_out("_sub_build_select_list(): real_list is empty");
				if ( defined($error_ref) ) {
					${$error_ref}	= "No matches";
					$esi_reader->after(30000, sub {
						${$error_ref}	= "";
						});
					}
				return(0);
				}
			}
		# Locations
		else {
			&debug_out("_sub_build_select_list(): Requested herachy");
			my @matches	= ();
			my @match_buf	= ();
			my @buffer	= ( @{$base_list} );
			my %passed	= (
				location	=> 0,
				system		=> 0,
				constellation	=> 0,
				);
			my $_sub_make_unique	= sub {		# Make unique by column
				my $column	= shift;
				my @input = @_;
				my %seen;
				@input = grep { ! $seen{$_->{$column}} ++ } @input; # makes the array-entries unique
				return(@input);
				};

			# Sort method over mutliple columns
			my $_sub_multi_column	= sub {
				CORE::fc($a->{region})			cmp CORE::fc($b->{region})		||
				CORE::fc($a->{constellation})		cmp CORE::fc($b->{constellation})	||
				CORE::fc($a->{system})			cmp CORE::fc($b->{system})		||
				CORE::fc($a->{structure_station})	cmp CORE::fc($b->{structure_station})
				};

  			# Columns: ss_id, structure_station, sys_id, system, const_id, constellation, region_id, region

			# Regions
			@matches	= grep { $_->{region} =~ m/$working_lst->{entry}/i } @buffer;			# Get all matching regions
			@matches	= &{$_sub_make_unique}("region_id", @matches);
			foreach my $match ( @matches ) {
				$match->{tier}	= "R";									# Mark as [R]egion
				@buffer	= grep { $_->{region_id} != $match->{region_id} } @buffer;			# Remove all elements from buffer, which are from the same region

				&debug_out(qq{_sub_build_select_list(): Region matched: "$match->{region}"});
				}

			# Constellations
			@match_buf	= grep { $_->{constellation} =~ m/$working_lst->{entry}/i } @buffer;
			@match_buf	= &{$_sub_make_unique}("const_id", @match_buf);
			foreach my $match ( @match_buf ) {
				$match->{tier}	= "C";
				@buffer	= grep { $_->{const_id} != $match->{const_id} } @buffer;
				&debug_out(qq{_sub_build_select_list(): Constelation matched: "$match->{constellation}"});
				}
			push(@matches, @match_buf);

			# Systems
			@match_buf	= grep { $_->{system} =~ m/$working_lst->{entry}/i } @buffer;
			@match_buf	= &{$_sub_make_unique}("sys_id", @match_buf);
			foreach my $match ( @match_buf ) {
				$match->{tier}	= "S";
				@buffer	= grep { $_->{sys_id} != $match->{sys_id} } @buffer;
				&debug_out(qq{_sub_build_select_list(): System matched: "$match->{system}"});
				}
			push(@matches, @match_buf);

			# Locations (Stations/Structures)
			@match_buf	= grep { $_->{structure_station} =~ m/$working_lst->{entry}/i } @buffer;
			@match_buf	= &{$_sub_make_unique}("ss_id", @match_buf);
			foreach my $match ( @match_buf ) {
				$match->{tier}	= "L";
				&debug_out(qq{_sub_build_select_list(): Station/structure matched: "$match->{structure_station}"});
				}
			push(@matches, @match_buf);
			@match_buf	= ();

			# Nothing found
			if ( !@matches ) {
				${$error_ref}	= "No matches";
				$esi_reader->after(30000, sub {
					${$error_ref}	= "";
					});
				&debug_out("_sub_build_select_list(): No matches");
				return(0);
				}

			# Build list for all later shown elements
  			# Columns: ss_id, structure_station, sys_id, system, const_id, constellation, region_id, region
			@buffer		= ();
			while ( my $match = shift(@matches) ) {
				if ( $match->{tier} eq "L" ) {
					&debug_out("_sub_build_select_list(): Using tier L");
					push(@buffer, $match);
					}
				elsif ( $match->{tier} eq "S" ) {
					&debug_out("_sub_build_select_list(): Using tier S");
					push(@buffer, grep { $_->{sys_id} == $match->{sys_id} } @{$base_list});		# Get all childs from matches
					}
				elsif ( $match->{tier} eq "C" ) {
					&debug_out("_sub_build_select_list(): Using tier C");
					push(@buffer, grep { $_->{const_id} == $match->{const_id} } @{$base_list});	# Get all childs from matches
					}
				elsif ( $match->{tier} eq "R" ) {
					&debug_out("_sub_build_select_list(): Using tier R");
					push(@buffer, grep { $_->{region_id} == $match->{region_id} } @{$base_list});
					}
				else {
					print STDERR "FATAL ERROR: This must not happen!\n";
					exit(127);
					}
				}

			# Sort correctly with full list
			@buffer		= sort { &{$_sub_multi_column} } @buffer;	# Order through multiple columns
			&debug_out("_sub_build_select_list(): Elements found: " . &human_readable(scalar(@buffer)));

			# Extend list in both directions
			$working_lst->{real_list}	= [];	# Empty list
			for ( my $index = 0 ; $index < scalar(@buffer) ; $index++ ) {
				my @tiers	= ();
				# Same system
				if ( $index != 0 && $buffer[$index]->{sys_id} == $buffer[$index - 1]->{sys_id} ) {
					@tiers	= qw(      L);
					}
				# Same constellation
				elsif ( $index != 0 && $buffer[$index]->{const_id} == $buffer[$index - 1]->{const_id} ) {
					@tiers	= qw(    S L);
					}
				# Same region
				elsif ( $index != 0 && $buffer[$index]->{region_id} == $buffer[$index - 1]->{region_id} ) {
					@tiers	= qw(  C S L);
					}
				# New region & start
				else {
					@tiers	= qw(R C S L);
					}

				&debug_out(qq{_sub_build_select_list(): \@tiers = "@tiers"});

				foreach my $tier ( @tiers ) {
					#&debug_out(qq{_sub_build_select_list(): Current tier = "$buffer[$index]->{tier}"\nDesignated tier = "$tier"});
					my $copy	= { %{$buffer[$index]} };
					$copy->{tier}	= $tier;
					&debug_out(qq{_sub_build_select_list(): New tier: "$copy->{tier}"});
					push(@{$working_lst->{real_list}}, $copy);
					}
				}
=begin debug_list1
			&debug_out("_sub_build_select_list(): \$working_lst->{real_list} start");
			foreach my $element ( @{$working_lst->{real_list}} ) {
				foreach my $key ( sort(keys(%{$element})) ) {
					&debug_out(qq{_sub_build_select_list(): \$working_lst->{real_list}->[\$i]->{$key}		= "$element->{$key}"});
					}
				&debug_out(" ");
				}
			&debug_out("_sub_build_select_list(): \$working_lst->{real_list} end");
=end debug_list1
=cut

			# Build hr_list from bottom to top
  			# Columns: ss_id, structure_station, sys_id, system, const_id, constellation, region_id, region
			for ( my $i = scalar(@{$working_lst->{real_list}}) - 1 ; $i >= 0 ; $i-- ) {
				my $edit_copy	= $working_lst->{real_list}->[$i];

				# Location
				if ( $edit_copy->{tier} eq "L" ) {
					$edit_copy		=
						(( $passed{constellation} ) ? $Signs{cord} : " ") . " " .
						(( $passed{system} ) ? $Signs{cord} : " ") . " " .
						(( $passed{location} ) ? $Signs{junction} : $Signs{turnoff}) . $Signs{branch} .
						$edit_copy->{structure_station};

					$passed{location}	= 1;
					&debug_out("_sub_build_select_list(): Build Location string");
					}
				# System
				elsif ( $edit_copy->{tier} eq "S" ) {
					$edit_copy		=
						(( $passed{constellation} ) ? $Signs{cord} : " ") . " " .
						(( $passed{system} ) ? $Signs{junction} : $Signs{turnoff}) . $Signs{branch} .
						$edit_copy->{system};

					$passed{system}		= 1;
					$passed{location}	= 0;
					&debug_out("_sub_build_select_list(): Build System string");
					}
				# Constellation
				elsif ( $edit_copy->{tier} eq "C" ) {
					$edit_copy		=
						(( $passed{constellation} ) ? $Signs{junction} : $Signs{turnoff}) . $Signs{branch} .
						$edit_copy->{constellation};

					$passed{constellation}	= 1;
					$passed{system}		= 0;
					$passed{location}	= 0;
					&debug_out("_sub_build_select_list(): Build Constellation string");
					}
				# Region
				else { # tier R
					$edit_copy		= $edit_copy->{region};
					# Reset everything
					$passed{constellation}	= 0;
					&debug_out("_sub_build_select_list(): Build Region string");
					}

				unshift(@hr_list, $edit_copy);
				}
			#return(1);
  			}

		# Insert into list
		foreach my $match ( @hr_list ) {
			&debug_out(qq{_sub_build_select_list(): Added "$match" to hr_list});
			${$working_obj}->insert("end", $match);
			}

		return(1);
		};

	# Status bar
	my $stat_bar	= $esi_reader->Frame(
		-background	=> $def_bg_hex,
		-borderwidth	=> 2,
		)->pack(
			-side	=> "bottom",
			-fill	=> "x",
			#-expand	=> 1,
			-padx	=> 2,
			-pady	=> 2,
			);

	# Progress bar in status bar
	my $prog_bar	= $stat_bar->ProgressBar(
		%def_pgB,
		-length		=> 700,		# WORK
		-width		=> 15,
		-variable	=> \$prog_perc,
		)->pack(
			#-fill	=> "x",
			-side	=> "left",
			-anchor => "w",
			);

	# Label for progress bar in status bar
	$prog_label	= $stat_bar->Label(	# Already created for _sub_add_ignore()
		%def_lab,
		-textvariable	=> \$prog_ltext,
		-padx		=> 5,
		)->pack(
			-side	=> "left",
			-anchor => "w",
			);

	$stat_bar->Label(
		%def_lab,
		-textvariable	=> \$match_counter,
		-padx		=> 5,
		)->pack(
			-side	=> "right",
			-anchor	=> "e",
			);

	$interactive	= $esi_reader->Frame(
		-background	=> $def_bg_hex,
		)->pack(
			-side	=> "right",
			-fill	=> "y",
			-padx	=> 10,		# WORK
			-pady	=> 10,		# WORK
			#-expand	=> 1,
			);

	my $entries	= $interactive->Frame(
		-background	=> $def_bg_hex,
		#-label		=> "Filter",	# WORK
		)->pack(
			-side	=> "top",
			#-fill	=> "both",
			#-expand	=> 1,
			);

	# Type
	$entries->Label(
		%def_lab,
		-text		=> "Type: ",
		-justify	=> "right"
		)->grid(
			-column	=> 0,
			-row	=> $row{type},
			-sticky	=> "e",
			);

	$entries->Label(
		%def_lab,
		-textvariable	=> \$type_err,
		-foreground	=> $Colors{red},
		)->grid(
			-column		=> 1,
			-row		=> $row{type} + 1,
			-columnspan	=> 2,
			-sticky		=> "nw",
			);

	$type_BEF	= $entries->BrowseEntry(
		%def_BE,
		-variable		=> \$filtered_types{entry},
		-listcmd		=> sub {
			&{$_sub_build_select_list}( \$type_BEF, \@fl_types, \%filtered_types, \$type_err ); 			# Generate list for dropdown
			},
		-browse2cmd		=> sub {
			my $unneeded_object	= shift;
			my $index_position	= shift;

			&debug_out(qq{esi_reader(): index pos = "$index_position"});

			&{$_sub_apply_selection}( \%filtered_types, \$type_err, $unneeded_object, $index_position );		# If you select something
			},
		)->grid(
			-column	=> 1,
			-row	=> $row{type},
			-sticky	=> "w",
			);
	$type_BEF->bind('<FocusIn>' => sub {
		$type_BEF->selectionClear();
		$type_BEF->selectionRange(0, "end");
		});
	$type_BEF->bind('<ButtonRelease-1>' => sub {
		$type_BEF->selectionClear();
		$type_BEF->selectionRange(0, "end");
		});

	# Hide runs
	$entries->Checkbutton(
		%def_cbtn,
		-variable	=> \$cbtn_auto_remru,
		-text		=> "Remove runs (orders with more than\nfive of the same buy order)",
		-anchor		=> "n",
		-pady		=> 0,
		)->grid(
			-column		=> 3,
			-columnspan	=> 3,
			#-row		=> $row{cbtn_brun},
			-row		=> $row{type},
			-rowspan	=> 2,
			-sticky		=> "n",
			);

	# From
	$entries->Label(
		%def_lab,
		-text		=> "Pickup location: ",
		)->grid(
			-column	=> 0,
			-row	=> $row{from},
			-sticky	=> "e",
			);

	$entries->Label(
		%def_lab,
		-textvariable	=> \$from_err,
		-foreground	=> $Colors{red},
		)->grid(
			-column		=> 1,
			-row		=> $row{from} + 1,
			-columnspan	=> 2,
			-sticky		=> "nw",
			);

	$from_BEF	= $entries->BrowseEntry(
		%def_BE,
		-variable		=> \$filtered_from{entry},
		-listcmd		=> sub {
			&{$_sub_build_select_list}( \$from_BEF, \@fl_locations, \%filtered_from, \$from_err );		# Generate list for dropdown
			},
		-browse2cmd		=> sub {
			my $unneeded_object	= shift;
			my $index_position	= shift;

			&{$_sub_apply_selection}( \%filtered_from, \$from_err, $unneeded_object, $index_position );	# If you select something
			},
		)->grid(
			-column	=> 1,
			-row	=> $row{from},
			-sticky	=> "w",
			);
	$from_BEF->bind('<FocusIn>' => sub {
		$from_BEF->selectionClear();
		$from_BEF->selectionRange(0, "end");
		});
	$from_BEF->bind('<ButtonRelease-1>' => sub {
		$from_BEF->selectionClear();
		$from_BEF->selectionRange(0, "end");
		});

	# To
	$entries->Label(
		%def_lab,
		-text		=> "Drop-off location: ",
		)->grid(
			-column	=> 3,
			-row	=> $row{to},
			-sticky	=> "e",
			);

	$entries->Label(
		%def_lab,
		-textvariable	=> \$to_err,
		-foreground	=> $Colors{red},
		)->grid(
			-column		=> 4,
			-row		=> $row{to} + 1,
			-columnspan	=> 2,
			-sticky		=> "nw",
			);

	$to_BEF		= $entries->BrowseEntry(
		%def_BE,
		-variable		=> \$filtered_to{entry},
		-listcmd		=> sub {
			&{$_sub_build_select_list}( \$to_BEF, \@fl_locations, \%filtered_to, \$to_err );	# Generate list for dropdown
			},
		-browse2cmd		=> sub {
			my $unneeded_object	= shift;
			my $index_position	= shift;

			&{$_sub_apply_selection}( \%filtered_to, \$to_err, $unneeded_object, $index_position );					# If you select something
			},
		)->grid(
			-column	=> 4,
			-row	=> $row{to},
			-sticky	=> "w",
			);
	$to_BEF->bind('<FocusIn>' => sub {
		$to_BEF->selectionClear();
		$to_BEF->selectionRange(0, "end");
		});
	$to_BEF->bind('<ButtonRelease-1>' => sub {
		$to_BEF->selectionClear();
		$to_BEF->selectionRange(0, "end");
		});

	# Maximal investment
	$entries->Label(
		%def_lab,
		-text		=> "Investment: ",
		)->grid(
			-column	=> 0,
			-row	=> $row{inv},
			-sticky	=> "e",
			);

	$entries->Label(
		%def_lab,
		-textvariable	=> \$inv_err,
		-foreground	=> $Colors{red},
		)->grid(
			-column		=> 1,
			-row		=> $row{inv} + 1,
			-columnspan	=> 2,
			-sticky		=> "nw",
			);

	$inv_ETY	= $entries->Entry(
		%def_ety,
		-textvariable		=> \$hr_invest,                     
        	-validate		=> "key",                        
        	-validatecommand	=> sub {
			my $entry	= shift;
			&{$_sub_num_validation}( \$inv_err, $entry );
			},
		-justify		=> "right",
		)->grid(
			-column	=> 1,
			-row	=> $row{inv},
			-sticky	=> "we",
			);
	$inv_ETY->bind('<FocusIn>'	=> sub {
		&{$_sub_entry_preparation}( $inv_ETY, $hr_invest );
		});
	$inv_ETY->bind('<FocusOut>'	=> sub {
		&{$_sub_entry_postprocessing}( $inv_ETY, { dp => 2, min => 1, }, $hr_invest );	
		});

	$entries->Label(
		%def_lab,
		-text		=> "ISK",
		)->grid(
			-column	=> 2,
			-row	=> $row{inv},
			-sticky	=> "w",
			);

	# Minimal profit
	$entries->Label(
		%def_lab,
		-text		=> "Expected profit: ",
		)->grid(
			-column	=> 3,
			-row	=> $row{prof},
			-sticky	=> "e",
			);

	$entries->Label(
		%def_lab,
		-textvariable	=> \$prof_err,
		-foreground	=> $Colors{red},
		)->grid(
			-column		=> 4,
			-row		=> $row{prof} + 1,
			-columnspan	=> 2,
			-sticky		=> "nw",
			);

	$prof_ETY	= $entries->Entry(
		%def_ety,
		-textvariable		=> \$hr_profit,                     
        	-validate		=> "key",                        
        	-validatecommand	=> sub {
			my $entry	= shift;
			&{$_sub_num_validation}( \$prof_err, $entry );
			},
		-justify		=> "right",
		)->grid(
			-column	=> 4,
			-row	=> $row{prof},
			-sticky	=> "we",
			);
	$prof_ETY->bind('<FocusIn>'	=> sub {
		my $entry	= shift;
		&{$_sub_entry_preparation}( $prof_ETY, $hr_profit );
		});
	$prof_ETY->bind('<FocusOut>'	=> sub {
		&{$_sub_entry_postprocessing}( $prof_ETY, { dp => 2, min => 0, }, $hr_profit);
		});

	$entries->Label(
		%def_lab,
		-text		=> "ISK",
		)->grid(
			-column	=> 5,
			-row	=> $row{prof},
			-sticky	=> "w",
			);

	# Maximal cargo
	$entries->Label(
		%def_lab,
		-text		=> "Cargo: ",
		)->grid(
			-column	=> 0,
			-row	=> $row{cargo},
			-sticky	=> "e",
			);

	$entries->Label(
		%def_lab,
		-textvariable	=> \$cargo_err,
		-foreground	=> $Colors{red},
		)->grid(
			-column		=> 1,
			-row		=> $row{cargo} + 1,
			-columnspan	=> 2,
			-sticky		=> "nw",
			);

	$cargo_ETY	= $entries->Entry(
		%def_ety,
		-textvariable		=> \$hr_cargo,                     
        	-validate		=> "key",                        
        	-validatecommand	=> sub {
			my $entry	= shift;
			&{$_sub_num_validation}( \$cargo_err, $entry );
			},
		-justify		=> "right",
		)->grid(
			-column	=> 1,
			-row	=> $row{cargo},
			-sticky	=> "we",
			);
	$cargo_ETY->bind('<FocusIn>'	=> sub {
		&{$_sub_entry_preparation}( $cargo_ETY, $hr_cargo );
		});
	$cargo_ETY->bind('<FocusOut>'	=> sub {
		&{$_sub_entry_postprocessing}( $cargo_ETY, { dp => 1, min => 1, }, $hr_cargo );
		});

	$entries->Label(
		%def_lab,
		-text		=> "m³",
		)->grid(
			-column	=> 2,
			-row	=> $row{cargo},
			-sticky	=> "w",
			);

	# Tax + Broker fee percent
	$entries->Label(
		%def_lab,
		-text		=> "Tax + broker fee: ",
		)->grid(
			-column	=> 3,
			-row	=> $row{tax},
			-sticky	=> "e",
			);

	$entries->Label(
		%def_lab,
		-textvariable	=> \$tax_err,
		-foreground	=> $Colors{red},
		)->grid(
			-column		=> 4,
			-row		=> $row{tax} + 1,
			-columnspan	=> 2,
			-sticky		=> "nw",
			);

	$tax_ETY	= $entries->Entry(
		%def_ety,
		-textvariable		=> \$tax,                     
        	-validate		=> "key",                        
        	-validatecommand	=> sub {
			my $entry	= shift;
			&{$_sub_num_validation}( \$tax_err, $entry );
			},
		-justify		=> "right",
		)->grid(
			-column	=> 4,
			-row	=> $row{tax},
			-sticky	=> "we",
			);
	$tax_ETY->bind('<FocusIn>'	=> sub {
		&{$_sub_entry_preparation}( $tax_ETY, $tax );
		});
	$tax_ETY->bind('<FocusOut>'	=> sub {
		&{$_sub_entry_postprocessing}( $tax_ETY, { dp => 1, max => 50, min => 0, }, $tax );
		});

	$entries->Label(
		%def_lab,
		-text		=> "%",
		)->grid(
			-column	=> 5,
			-row	=> $row{tax},
			-sticky	=> "w",
			);

	# Minimal system security status
	$entries->Label(
		%def_lab,
		-text		=> "Min. security status: ",
		)->grid(
			-column	=> 0,
			-row	=> $row{mins},
			-sticky	=> "e",
			);

	$entries->Label(
		%def_lab,
		-textvariable	=> \$mins_err,
		-foreground	=> $Colors{red},
		)->grid(
			-column		=> 1,
			-row		=> $row{mins} + 1,
			-columnspan	=> 2,
			-sticky		=> "nw",
			);

	$mins_ETY	= $entries->Entry(
		%def_ety,
		-textvariable		=> \$min_sec,                     
        	-validate		=> "key",                        
        	-validatecommand	=> sub {
			my $entry	= shift;
			&{$_sub_num_validation}( \$mins_err, $entry );
			},
		-justify		=> "right",
		)->grid(
			-column	=> 1,
			-row	=> $row{mins},
			-sticky	=> "we",
			);
	$mins_ETY->bind('<FocusIn>'	=> sub {
		&{$_sub_entry_preparation}( $mins_ETY, $min_sec );
		});
	$mins_ETY->bind('<FocusOut>'	=> sub {
		&{$_sub_entry_postprocessing}( $mins_ETY, { dp => 1, max => $max_sec, min => -1.0 }, $min_sec );
		});

	$entries->Label(
		%def_lab,
		#-text		=> "m³",
		)->grid(
			-column	=> 2,
			-row	=> $row{mins},
			-sticky	=> "w",
			);

	# Maximal system security status
	$entries->Label(
		%def_lab,
		-text		=> "Max. security status: ",
		)->grid(
			-column	=> 3,
			-row	=> $row{maxs},
			-sticky	=> "e",
			);

	$entries->Label(
		%def_lab,
		-textvariable	=> \$maxs_err,
		-foreground	=> $Colors{red},
		)->grid(
			-column		=> 4,
			-row		=> $row{maxs} + 1,
			-columnspan	=> 2,
			-sticky		=> "nw",
			);

	$maxs_ETY	= $entries->Entry(
		%def_ety,
		-textvariable		=> \$max_sec,                     
        	-validate		=> "key",                        
        	-validatecommand	=> sub {
			my $entry	= shift;
			&{$_sub_num_validation}( \$maxs_err, $entry );
			},
		-justify		=> "right",
		)->grid(
			-column	=> 4,
			-row	=> $row{maxs},
			-sticky	=> "we",
			);
	$maxs_ETY->bind('<FocusIn>'	=> sub {
		&{$_sub_entry_preparation}( $maxs_ETY, $max_sec );
		});
	$maxs_ETY->bind('<FocusOut>'	=> sub {
		&{$_sub_entry_postprocessing}( $maxs_ETY, { dp => 1, max => sprintf("%.1f", 1), min => $min_sec, }, $max_sec );
		});

	$entries->Label(
		%def_lab,
		#-text		=> "%",
		)->grid(
			-column	=> 5,
			-row	=> $row{maxs},
			-sticky	=> "w",
			);

	# Route type option
	$entries->Label(
		%def_lab,
		-text		=> "Prefered route: ",
		)->grid(
			-column		=> 0,
			-row		=> $row{route_opts},
			-sticky		=> "e",
			);

	$entries->Optionmenu(
		%def_OptMenu,
		-variable	=> \$route_option,
		-options	=> \@route_options,
		-textvariable	=> \$route_option_helper,
		)->grid(
			-column		=> 1,
			-columnspan	=> 4,
			-row		=> $row{route_opts},
			-sticky		=> "we",
			);

	$entries->Label(
		%def_lab,
		-text		=> " ",
		)->grid(
			-column		=> 1,
			-row		=> $row{route_opts} + 1,
			);
		

	# Sort order option
	$entries->Label(
		%def_lab,
		-text		=> "Sort by: ",
		)->grid(
			-column		=> 0,
			-row		=> $row{sort_opts},
			-sticky		=> "e",
			);

	$entries->Optionmenu(
		%def_OptMenu,
		-variable	=> \$sort_option,
		-options	=> \@sort_options,
		-textvariable	=> \$sort_option_helper,
		)->grid(
			-column		=> 1,
			-columnspan	=> 4,
			-row		=> $row{sort_opts},
			-sticky		=> "we",
			);

	foreach my $int_row ( 0..21 ) {
		$entries->gridRowconfigure($int_row, -weight => 1);
		}

	foreach my $int_col ( 0..5 ) {
		$entries->gridColumnconfigure($int_col, -weight => 1);
		}

	my $btns	= $interactive->Frame(
		-background	=> $def_bg_hex,
		)->pack(
			-side	=> "bottom",
			-padx	=> 20,
			-pady	=> 20,
			-fill	=> "x",
			#-expand	=> 1,
			);

	$apply		= $btns->Button(
		%def_btn,
		-text		=> "Apply & reload",
		-command	=> sub {
			&{$_sub_change_state}(0, $apply);
			$apply->configure(
				-foreground		=> $def_btn{-foreground},
				-background		=> $def_btn{-background},
				-activebackground	=> $def_btn{-activebackground},
				-activeforeground	=> $def_btn{-activeforeground},
				);
			&{$_sub_update_main_table}();
			&{$_sub_change_state}(1);
			},
		)->grid(
			-padx		=> 5,
			-pady		=> 5,
			-row		=> 0,
			-column		=> 0,
			#-column		=> 0,
			#-columnspan	=> 2,
			-sticky		=> "nswe",
			);

	$extras		= $btns->Menubutton(
		%def_mb,
		-direction	=> "above",
		-text		=> "Extras",
		-menuitems	=> [
			[
				command		=> "DUMMY",
				],
			],
		)->grid(
			-padx		=> 5,
			-pady		=> 5,
			-row		=> 0,
			-column		=> 1,
			#-columnspan	=> 2,
			-sticky		=> "nswe",
			);

	$rfsh_mrkts	= $btns->Button(
		%def_btn,
		-text		=> "Stop market updates",
		-command	=> sub {
			$main_knot->shlock;
			if ( $transport{run_update} eq "perm" ) {
				$transport{run_update}	= "";
				$main_knot->shunlock;
				$rfsh_mrkts->configure(
					-text		=> "Start market updates",
					);
				}
			elsif ( $transport{run_update} eq "" ) {
				$transport{run_update}	= "perm";
				$main_knot->shunlock;
				$rfsh_mrkts->configure(
					-text			=> "Stop market updates",
					-background		=> $def_btn{-background},
					-foreground		=> $def_btn{-foreground},
					-activebackground	=> $def_btn{-activebackground},
					-activeforeground	=> $def_btn{-activeforeground},
					);
				}
			else {
				$main_knot->shunlock;
				}
			},
		)->grid(
			-padx		=> 5,
			-pady		=> 5,
			-row		=> 1,
			-column		=> 0,
			#-column		=> 0,
			#-columnspan	=> 2,
			-sticky		=> "nswe",
			);

	$rfsh_all	= $btns->Button(
		%def_btn,
		-text		=> "Refresh all",
		-state		=> "disabled",
		-command	=> sub {

			# Block multiple calls (we don't know how long shlock and access_DB are blocking until _sub_change_state() is called by _sub_rebuild_db()
			&{$_sub_change_state}(0);

			# Time to set $force_update if used
			Time::HiRes::sleep(0.1);

			if ( $force_update ) {

				# Disable force
				$force_update		= 0;

				# Reset update times for character
				&priority_lock(1);
				&access_DB("UPDATE characters SET last_update_all = 0, last_update_markets = 0, done_regions = 0, done_constellations = 0, done_systems = 0, done_stargates = 0, done_stations = 0, done_structures = 0, done_types = 0, done_jumps = 0 WHERE id = " . &quote_DB($character_id) . ";", "decontrol");

				# Empty denied structurs list
				&access_DB("DELETE FROM denied_structures WHERE character_id == " . &quote_DB($character_id) . " ;", "decontrol");

				# Empty routes tables
				&access_DB("DELETE FROM routes_impassable ;", "decontrol");
				&access_DB("DELETE FROM routes_jumps ;", "decontrol");
				&priority_lock(0);

				# Run database update from start
				&{$_sub_rebuild_db}("start");
				}
			else {
				&{$_sub_rebuild_db}("all");
				}

			return(1);
			},
		)->grid(
			-padx		=> 5,
			-pady		=> 5,
			-row		=> 1,
			-column		=> 1,
			#-columnspan	=> 2,
			-sticky		=> "nswe",
			);
	$rfsh_all->bind("<Control-Shift-ButtonRelease-1>", sub {
		$force_update		= 1;
		});

	# Square # WORK not working?!
	foreach my $btns_grid ( 0, 1 ) {
		$btns->gridRowconfigure($btns_grid, -weight => 1);
		$btns->gridColumnconfigure($btns_grid, -weight => 1);
		}

	# Info section
	my $info_frame	= $interactive->Frame(
		-background	=> $def_bg_hex,
		)->pack(
			-side	=> "top",
			-padx	=> 20,
			-pady	=> 20,
			-fill	=> "x",
			-expand	=> 1,
			-anchor	=> "center",
			);

	my %def_lab_ext		= (
		%def_lab,
		-padx		=> 10,
		-pady		=> 5,
		-justify	=> "left",
		-anchor		=> "w",
		);

	my %def_lab_ext_labels_only	= (
		%def_lab_ext,
		-width		=> 12,
		);

	my $sticky		= "w";

	# Pickup
	my $pickup_info		= $info_frame->Labelframe(
		%def_labelframe,
		-text		=> "Pickup location",
		)->pack(
			-side	=> "top",
			-pady	=> 10,
			-expand	=> 1,
			-anchor	=> "nw",
			-fill	=> "both",
			);

	# Pickup region label
	$pickup_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "Region",
		)->grid(
			-row	=> $info_sec_rows{region},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Pickup region
	$pickup_info->Label(
		%def_lab_ext,
		-textvariable	=> \$pickup_region,
		)->grid(
			-row	=> $info_sec_rows{region},
			-column	=> 1,
			-columnspan	=> 2,
			-sticky	=> $sticky,
			);

	# Pickup constellation label
	$pickup_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "Constellation",
		)->grid(
			-row	=> $info_sec_rows{constellation},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Pickup constellation
	$pickup_info->Label(
		%def_lab_ext,
		-textvariable	=> \$pickup_constellation,
		)->grid(
			-row	=> $info_sec_rows{constellation},
			-column	=> 1,
			-columnspan	=> 2,
			-sticky	=> $sticky,
			);

	# Pickup system label
	$pickup_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "System",
		)->grid(
			-row	=> $info_sec_rows{system},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Pickup system
	$pickup_info->Label(
		%def_lab_ext,
		-textvariable	=> \$pickup_system,
		)->grid(
			-row	=> $info_sec_rows{system},
			-column	=> 1,
			-sticky	=> $sticky,
			);

	# Pickup system security
	$pickup_sys_sec_label	= $pickup_info->Label(
		%def_lab_ext,
		-textvariable	=> \$pickup_sys_sec,
		-padx		=> 0,
		)->grid(
			-row	=> $info_sec_rows{system},
			-column	=> 2,
			-sticky	=> $sticky,
			);

	# Pickup station label
	$pickup_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "Station",
		)->grid(
			-row	=> $info_sec_rows{sta_str},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Pickup station
	$pickup_info->Label(
		%def_lab_ext,
		-textvariable	=> \$pickup_sta_str,
		)->grid(
			-row	=> $info_sec_rows{sta_str},
			-column	=> 1,
			-columnspan	=> 2,
			-sticky	=> $sticky,
			);

	# Pickup buy price label
	$pickup_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "Price",
		)->grid(
			-row	=> $info_sec_rows{price},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Pickup buy price
	$pickup_buy_price_obj	= $pickup_info->Label(
		%def_lab_ext,
		-textvariable	=> \$pickup_buy_price,
		-anchor		=> "e",
		-justify	=> "right",
		)->grid(
			-row	=> $info_sec_rows{price},
			-column	=> 1,
			-columnspan	=> 2,
			-sticky	=> $sticky,
			);

	$pickup_info->gridColumnconfigure(2, -weight => 1);

	# Drop-off
	my $drop_off_info		= $info_frame->Labelframe(
		%def_labelframe,
		-text		=> "Drop-off location",
		)->pack(
			-side	=> "top",
			-pady	=> 10,
			-expand	=> 1,
			-anchor	=> "nw",
			-fill	=> "both",
			);

	# Drop-off region label
	$drop_off_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "Region",
		)->grid(
			-row	=> $info_sec_rows{region},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Drop-off region
	$drop_off_info->Label(
		%def_lab_ext,
		-textvariable	=> \$drop_off_region,
		)->grid(
			-row	=> $info_sec_rows{region},
			-column	=> 1,
			-columnspan	=> 2,
			-sticky	=> $sticky,
			);

	# Drop-off constellation label
	$drop_off_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "Constellation",
		)->grid(
			-row	=> $info_sec_rows{constellation},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Drop-off constellation
	$drop_off_info->Label(
		%def_lab_ext,
		-textvariable	=> \$drop_off_constellation,
		)->grid(
			-row	=> $info_sec_rows{constellation},
			-column	=> 1,
			-columnspan	=> 2,
			-sticky	=> $sticky,
			);

	# Drop-off system label
	$drop_off_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "System",
		)->grid(
			-row	=> $info_sec_rows{system},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Drop-off system
	$drop_off_info->Label(
		%def_lab_ext,
		-textvariable	=> \$drop_off_system,
		)->grid(
			-row	=> $info_sec_rows{system},
			-column	=> 1,
			-sticky	=> $sticky,
			);

	# Drop-off system security
	$drop_off_sys_sec_label	= $drop_off_info->Label(
		%def_lab_ext,
		-textvariable	=> \$drop_off_sys_sec,
		-padx		=> 0,
		)->grid(
			-row	=> $info_sec_rows{system},
			-column	=> 2,
			-sticky	=> $sticky,
			);

	# Drop-off station label
	$drop_off_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "Station",
		)->grid(
			-row	=> $info_sec_rows{sta_str},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Drop-off station
	$drop_off_info->Label(
		%def_lab_ext,
		-textvariable	=> \$drop_off_sta_str,
		)->grid(
			-row	=> $info_sec_rows{sta_str},
			-column	=> 1,
			-columnspan	=> 2,
			-sticky	=> $sticky,
			);

	# Drop-off sell price label
	$drop_off_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "Price",
		)->grid(
			-row	=> $info_sec_rows{price},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Drop-off sell price
	$drop_off_sell_price_obj = $drop_off_info->Label(
		%def_lab_ext,
		-textvariable	=> \$drop_off_sell_price,
		-anchor		=> "e",
		-justify	=> "right",
		)->grid(
			-row	=> $info_sec_rows{price},
			-column	=> 1,
			-columnspan	=> 2,
			-sticky	=> $sticky,
			);

	$drop_off_info->gridColumnconfigure(2, -weight => 1);

	# Cargo
	my $cargo_info		= $info_frame->Labelframe(
		%def_labelframe,
		-text		=> "Cargo",
		)->pack(
			-side	=> "top",
			-pady	=> 10,
			-expand	=> 1,
			-anchor	=> "nw",
			-fill	=> "both",
			);

	# Cargo object label
	$cargo_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "Type",
		)->grid(
			-row	=> $info_sec_rows{object},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Cargo object
	$cargo_info->Label(
		%def_lab_ext,
		-textvariable	=> \$cargo_object,
		)->grid(
			-row	=> $info_sec_rows{object},
			-column	=> 1,
			-sticky	=> $sticky,
			);

	# Cargo quantity label
	$cargo_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "Quantity",
		)->grid(
			-row	=> $info_sec_rows{quantity},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Cargo quantity
	$cargo_info->Label(
		%def_lab_ext,
		-textvariable	=> \$cargo_quantity,
		)->grid(
			-row	=> $info_sec_rows{quantity},
			-column	=> 1,
			-sticky	=> $sticky,
			);

	# Cargo investment label
	$cargo_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "Investment",
		)->grid(
			-row	=> $info_sec_rows{investment},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Cargo investment
	$cargo_investment_obj	= $cargo_info->Label(
		%def_lab_ext,
		-textvariable	=> \$cargo_investment,
		-anchor		=> "e",
		-justify	=> "right",
		)->grid(
			-row	=> $info_sec_rows{investment},
			-column	=> 1,
			-sticky	=> $sticky,
			);

	# Cargo profit label
	$cargo_info->Label(
		%def_lab_ext_labels_only,
		-text		=> "Profit",
		)->grid(
			-row	=> $info_sec_rows{profit},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Cargo profit
	$cargo_profit_obj	= $cargo_info->Label(
		%def_lab_ext,
		-textvariable	=> \$cargo_profit,
		-anchor		=> "e",
		-justify	=> "right",
		)->grid(
			-row	=> $info_sec_rows{profit},
			-column	=> 1,
			-sticky	=> $sticky,
			);

	$cargo_info->gridColumnconfigure(2, -weight => 1);

	# Purchase and Leftover info
	my $pl_info		= $info_frame->Frame(
		-background	=> $def_bg_hex,
		)->pack(
			-side	=> "top",
			-pady	=> 10,
			-expand	=> 1,
			-anchor	=> "nw",
			-fill	=> "both",
			);

	# Purchase info
	my $purchase_info	= $pl_info->Labelframe(
		%def_labelframe,
		-text		=> "Purchase amounts",
		)->grid(
			-row	=> 0,
			-column	=> 0,
			-sticky	=> "nswe",
			);

	# Purchase profit total label
	$purchase_info->Label(
		%def_lab_ext_labels_only,
		-width		=> 15,
		-text		=> "Profit total",
		)->grid(
			-row	=> $info_sec_rows{pur_amnt}->{profit},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Purchase profit total
	$purchase_info->Label(
		%def_lab_ext,
		-textvariable	=> \$pur_amnt{profit},
		)->grid(
			-row	=> $info_sec_rows{pur_amnt}->{profit},
			-column	=> 1,
			-sticky	=> $sticky,
			);

	# Purchase revenue total label
	$purchase_info->Label(
		%def_lab_ext_labels_only,
		-width		=> 15,
		-text		=> "Revenue total",
		)->grid(
			-row	=> $info_sec_rows{pur_amnt}->{revenue},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Purchase revenue total
	$purchase_info->Label(
		%def_lab_ext,
		-textvariable	=> \$pur_amnt{revenue},
		)->grid(
			-row	=> $info_sec_rows{pur_amnt}->{revenue},
			-column	=> 1,
			-sticky	=> $sticky,
			);

	# Purchase needed space total label
	$purchase_info->Label(
		%def_lab_ext_labels_only,
		-width		=> 15,
		-text		=> "Cargo space total",
		)->grid(
			-row	=> $info_sec_rows{pur_amnt}->{nspace},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Purchase needed space total
	$purchase_info->Label(
		%def_lab_ext,
		-textvariable	=> \$pur_amnt{space},
		)->grid(
			-row	=> $info_sec_rows{pur_amnt}->{nspace},
			-column	=> 1,
			-sticky	=> $sticky,
			);

	# Purchase investment total label
	$purchase_info->Label(
		%def_lab_ext_labels_only,
		-width		=> 15,
		-text		=> "Investment total",
		)->grid(
			-row	=> $info_sec_rows{pur_amnt}->{invest},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Purchase investment total
	$purchase_info->Label(
		%def_lab_ext,
		-textvariable	=> \$pur_amnt{investment},
		)->grid(
			-row	=> $info_sec_rows{pur_amnt}->{invest},
			-column	=> 1,
			-sticky	=> $sticky,
			);

	# Purchase profit per m³ average label
	$purchase_info->Label(
		%def_lab_ext_labels_only,
		-width		=> 15,
		-text		=> "Average profit/m³",
		)->grid(
			-row	=> $info_sec_rows{pur_amnt}->{prof_qm},
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Purchase profit per m³ average
	$purchase_info->Label(
		%def_lab_ext,
		-textvariable	=> \$pur_amnt{profit_qm},
		)->grid(
			-row	=> $info_sec_rows{pur_amnt}->{prof_qm},
			-column	=> 1,
			-sticky	=> $sticky,
			);

	$purchase_info->gridColumnconfigure(1, -weight => 1);

	## Space between colums
	$pl_info->Frame(
		-background	=> $def_bg_hex,
		-width		=> 30,
		)->grid(
			-row	=> 0,
			-column	=> 1,
			-sticky	=> $sticky,
			);

	# Leftover info
	my $leftover_info	= $pl_info->Labelframe(
		%def_labelframe,
		-text		=> "Leftover",
		)->grid(
			-row	=> 0,
			-column	=> 2,
			-sticky	=> "nwe",
			);

	# Leftovers money label
	$leftover_info->Label(
		%def_lab_ext_labels_only,
		-width		=> 5,
		-text		=> "Money"
		)->grid(
			-row	=> 0,
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Leftovers money
	$leftover_info->Label(
		%def_lab_ext,
		-textvariable	=> \$remains{investment},
		-justify	=> "left",
		)->grid(
			-row		=> 0,
			-column		=> 1,
			-sticky		=> $sticky,
			);

	# Leftovers space label
	$leftover_info->Label(
		%def_lab_ext_labels_only,
		-width		=> 5,
		-text		=> "Cargo"
		)->grid(
			-row	=> 1,
			-column	=> 0,
			-sticky	=> $sticky,
			);

	# Leftovers space
	$leftover_info->Label(
		%def_lab_ext,
		-textvariable	=> \$remains{space},
		-justify	=> "left",
		)->grid(
			-row		=> 1,
			-column		=> 1,
			-sticky		=> $sticky,
			);

	$leftover_info->gridColumnconfigure(1, -weight => 1);

	foreach my $c ( 0, 2 ) {
		$pl_info->gridColumnconfigure($c, -weight => 1);
		}

	$mode_bar	= $esi_reader->Frame(
		-background	=> $def_bg_hex,
		)->pack(
			-side	=> "top",
			-fill	=> "x",
			#-expand	=> 1,
			);

	my %mode_rdbtn	= (	
		%def_rdbtn,
		-variable		=> \$base_table,
		-indicatoron		=> 0,
		);

	$rdm_haul	= $mode_bar->Radiobutton(	# RaDiobutton Mode bar (=rdm)
		%mode_rdbtn,
		-command	=> sub {
			&{$_sub_change_state}(0, $rdm_haul);
			&{$_sub_update_main_table}(),
			&{$_sub_change_state}(1);

			# Set colors new
			$rdm_haul->configure(	-foreground	=> $def_bg_hex, );
			$rdm_sales->configure(	-foreground	=> $def_fg_hex, );
			$rdm_buys->configure(	-foreground	=> $def_fg_hex, );
			},
		-text		=> "Hauling",
		-foreground	=> $def_bg_hex,
		-value		=> "hauls",
		)->grid(
			-column	=> 0,
			-row	=> 0,
			-sticky	=> "nsew",
			);

	$rdm_sales	= $mode_bar->Radiobutton(	# RaDiobutton Mode bar (=rdm)
		%mode_rdbtn,
		-command	=> sub {
			&{$_sub_change_state}(0, $rdm_sales);
			&{$_sub_update_main_table}(),
			&{$_sub_change_state}(1);

			# Set colors new
			$rdm_haul->configure(	-foreground	=> $def_fg_hex, );
			$rdm_sales->configure(	-foreground	=> $def_bg_hex, );
			$rdm_buys->configure(	-foreground	=> $def_fg_hex, );
			},
		-text		=> "Sellers",
		-value		=> "orders_sells",
		)->grid(
			-column	=> 1,
			-row	=> 0,
			-sticky	=> "nsew",
			);

	$rdm_buys	= $mode_bar->Radiobutton(	# RaDiobutton Mode bar (=rdm)
		%mode_rdbtn,
		-command	=> sub {
			&{$_sub_change_state}(0, $rdm_buys);
			&{$_sub_update_main_table}(),
			&{$_sub_change_state}(1);

			# Set colors new
			$rdm_haul->configure(	-foreground	=> $def_fg_hex, );
			$rdm_sales->configure(	-foreground	=> $def_fg_hex, );
			$rdm_buys->configure(	-foreground	=> $def_bg_hex, );
			},
		-text		=> "Buyers",
		-value		=> "orders_buys",
		)->grid(
			-column	=> 2,
			-row	=> 0,
			-sticky	=> "nsew",
			);

	foreach my $column ( 0..2 ) {
		$mode_bar->gridColumnconfigure($column, -weight => 1);
		}

	&{$_sub_update_entries}("start");

	$first_update	= $esi_reader->after(250, sub {
		&{$_sub_change_state}(0);
		$machine	= 0;
		&{$_sub_rebuild_db}("start");

		#$esi_reader->after(9_800, sub {
			#$main_knot->shlock;
			#$transport{run_update}	= "perm";
			#$main_knot->shunlock;
			#});
		$esi_reader->after(10_000, $_sub_perma_status_updater);
		});

	$esi_reader->MainLoop();
	}

# Start setup if database doesn't exist
else {
	$dsn			.= $database;
	&win_setup("start");
	}

# What happens after close?
if ( $run_setup ) {
	&pprop_exit(1);
	&win_setup("man_appIdKey");
	exit(0);
	}
else {
	(tied(%transport))->remove;
	&pprop_exit();
	}


### Subfunctions

sub win_setup {
	my $source		= shift;
	my $xpos		= shift;
	my $ypos		= shift;
	my $ww			= 800;
	my $wh			= 600;
	my @accCodes		= ();
	my %cols		= (
		#0		=> 0,
		1		=> 250,
		2		=> 300,
		3		=> 120,
		);
	my %rows		= (
		0		=> 25,
		1		=> 25,
		2		=> 100,
		);

	## Threads
	# For login
	$main_knot->shlock;
	my $Client_ID			= "";
	$transport{Client_ID}		= "";
	my $Secret_Key			= "";
	$transport{Secret_Key}		= "";
	my $access_code			= "";
	$transport{access_code}		= "";
	$transport{login_return}	= 0;	# 0=nothing done, 1=success, 2=logon failure, 3=network error
	$transport{login_start}		= 0;
	$transport{jdata_access}	= "";
	$transport{jdata_acc_time}	= 0;
	$transport{jdata_character}	= "";
	$transport{prog_start}		= 0;
	$transport{prog_counter}	= 0;
	$transport{prog_ltext}		= "Starting...";
	$main_knot->shunlock;

	my $char_downlaoder	= fork;
	# Parent
	if ( defined($char_downlaoder) && $char_downlaoder ) {
		push(@childs, $char_downlaoder);
		&debug_out(
			"Started child $char_downlaoder",
			);
		}
	# Child
	elsif ( defined($char_downlaoder) ) {
		srand();
		local $SIG{INT} 	 = \&cprop_exit;
		local $SIG{HUP} 	 = \&cprop_exit;

		my $setup_dl_knot	= tie(my %download_carrier, 'IPC::Shareable', $transID);

		while ( kill(0 => $ppid) ) {
			$setup_dl_knot->shlock;
			if ( $download_carrier{login_start} ) {
				my $cmd			= "$cURL " .
					"$cURL_options " .
					"-XPOST " .
					"-H \"Content-Type:application/json\" " .
					"-H \"Authorization:Basic " .
					encode_base64($download_carrier{Client_ID} . ":" . $download_carrier{Secret_Key}, '') . "\" " .
					"-d '{\"grant_type\":\"authorization_code\", " .
					"\"code\":\"" . $download_carrier{access_code} . "\"}' " .
					"${lsburl}/oauth/token";
				&debug_out(
					"Access code: \"" . $download_carrier{access_code} . "\"",
					"Trying to download token...",
					$cmd,
					);
				$setup_dl_knot->shunlock;
				chomp(my $access		= qx($cmd));
				if ( $access ) {
					&debug_out(
						"Got: $access",
						);
					$access		= &test_json($access);
					$setup_dl_knot->shlock;
					$download_carrier{jdata_acc_time}	= time;
					$download_carrier{jdata_access}		= $access;
					$setup_dl_knot->shunlock;
					&debug_out("Written to download_carrier");
					}

=begin comment
				# This will be returned
				Key [access_token]:     = '[censored]'
				Key [expires_in]:       = '1199'                                 
				Key [refresh_token]:    = '[censored]'
				Key [token_type]:       = 'Bearer'
=end comment
=cut

				# Extract access token

				$cmd			= "$cURL " .
					"$cURL_options " .
					"-XGET " .
					"-H 'Authorization: $access->{token_type} $access->{access_token}' " .
					"${lsburl}/oauth/verify";
				&debug_out(
					"Trying to download character data...",
					$cmd,
					);

=begin comment
				# This will be returned
				{"CharacterID":93125899,"CharacterName":"Corra Raifen","ExpiresOn":"2020-04-15T12:03:57","Scopes":"esi-universe.read_structures.v1 esi-markets.structure_markets.v1","TokenType":"Character","CharacterOwnerHash":"0M0jubpteLTBbPpPDo+sXGvYlXM=","IntellectualProperty":"EVE"}
				Key [CharacterID]:		= '[censored]'
				Key [CharacterName]:		= '[censored]'
				Key [CharacterOwnerHash]:	= '[censored]'
				Key [ExpiresOn]:		= '2018-05-03T23:01:58'
				Key [IntellectualProperty]:	= 'EVE'
				Key [Scopes]:			= 'esi-universe.read_structures.v1 esi-markets.structure_markets.v1'
				Key [TokenType]:		= 'Character'
=end comment
=cut

				chomp(my $jdata_character	= qx($cmd));	# WORK check returns?
				$setup_dl_knot->shlock;
				&debug_out(
					"Got data:\n" .
					"\tTime:	" . $download_carrier{jdata_acc_time},
					"\tJSON data:	$jdata_character",
					);
				if ( $access && $jdata_character ) {
					&debug_out("Reading received data...");
					my $Character	= &test_json($jdata_character);
					$download_carrier{jdata_character}	= $Character;
					$download_carrier{CharacterID}		= $Character->{CharacterID};
					$download_carrier{CharacterName}	= $Character->{CharacterName};
					$download_carrier{login_return}		= 1;
					$setup_dl_knot->shunlock;
					}
				else {
					# if for ping??
					$download_carrier{login_return}		= 2;
					}
				$download_carrier{login_start}			= 0;	# finished
				$setup_dl_knot->shunlock;
				&debug_out("Done getting user data");
				}
			else {
				$setup_dl_knot->shunlock;
				Time::HiRes::sleep(0.2);
				}
			}
		&debug_out(
			"Parent $ppid seems to be dead",
			);
		exit(0);
		}
	else {
		&debug_out(
			"Can't fork",
			);
		(tied(%transport))->remove;
		exit(1);
		}

	my $maximum		= 225 + 25;		# WORK 23 elements until now and 50 for the insert
	my $build_DB		= fork;
	# Parent
	if ( defined($build_DB) && $build_DB ) {
		push(@childs, $build_DB);
		&debug_out(
			"Started child $build_DB",
			);
		}
	# Child
	elsif ( defined($build_DB) ) {
		srand();
		local $SIG{INT} 	= \&cprop_exit;
		local $SIG{HUP} 	= \&cprop_exit;

		my $setup_db_knot	= tie(my %build_carrier, 'IPC::Shareable', $transID);

		while ( kill(0 => $ppid) ) {
			$setup_db_knot->shlock;
			if ( $build_carrier{prog_start} ) {
				$setup_db_knot->shunlock;
				&debug_out("Starting to build database");

				# Create configs folder
				if ( !-d (fileparse($database))[1] ) {
					make_path((fileparse($database))[1]);
					}

				# Generate tables array
				my $last_line		= 1;
				chomp(my @tables	= <DATA>);
				close(DATA);
				@tables			= split(/;/, join("\n", @tables));

=begin no_longer_needed_line_processor
				sql_line:
				while ( my $line = <DATA> ) {
					# If last line of table add a new empty string to append to
					if ( $line eq "" || $line =~ m/^\s*$/ ) {
						next(sql_line);
						}
					elsif ( $last_line ) {
						push(@tables, "");
						$last_line	= 0;
						}

					# Replacements
					$line			=~ s/<\[APP_VERSION\]>/$app_version/g;	

					# Remove last newline
					if ( $line =~ m/;/ ) {
						chomp($line);
						$last_line	= 1;
						}

					# Add to current table
					$tables[-1]		.= $line;
					}
				close(DATA);
=end no_longer_needed_line_processor
=cut

				## Building the database
				$setup_db_knot->shlock;
				$build_carrier{prog_ltext}		= "Creating database";
				$setup_db_knot->shunlock;
				foreach my $statement ( grep { $_ !~ m/^\s*$/ } @tables ) {
					$setup_db_knot->shlock;
					$build_carrier{prog_counter}	+= 225 / scalar(@tables);					# WORK
					$setup_db_knot->shunlock;

					# Replacements
					$statement			=~ s/\Q<[APP_VERSION]>\E/$app_version/g;	

					# Create
					&access_DB("$statement;");						# ; lost while splitting
					}
					
				## Insert already collected data
				$setup_db_knot->shlock;
				my $Character				= $build_carrier{jdata_character};
				my $access				= $build_carrier{jdata_access};

				&debug_out(
					"Hash array test for lines 970-980:\n$Character->{CharacterName}",
					);

				$build_carrier{prog_counter}		+= 25;					# WORK
				my %bc_helper				= (
					Client_ID			=> $build_carrier{Client_ID},
					Secret_Key			=> $build_carrier{Secret_Key},
					jdata_acc_time			=> $build_carrier{jdata_acc_time},
					);
				$setup_db_knot->shunlock;
				&access_DB(
					"REPLACE INTO characters " .
					"(id, name, owner_hash, app_client_id, app_secret_key, token_refresh, token_access, token_acc_duration, done_regions, done_constellations, done_systems, done_stargates, done_stations, done_structures, done_types, done_jumps, token_acc_time) VALUES\n" .
					"(" .
						&quote_DB($Character->{CharacterID}) . ", " .			# id
						&quote_DB($Character->{CharacterName}) . ", " .			# name
						&quote_DB($Character->{CharacterOwnerHash}) . ", " .		# owner_hash
						&quote_DB($bc_helper{Client_ID}) . ", " .			# app_client_id
						&quote_DB($bc_helper{Secret_Key}) . ", " .			# app_secret_key
						&quote_DB($access->{refresh_token}) . ", " .			# token_refresh
						&quote_DB($access->{access_token}) . ", " .			# token_access
						&quote_DB($access->{expires_in}) . ", " .			# token_acc_duration
						"0, " .
						"0, " .
						"0, " .
						"0, " .
						"0, " .
						"0, " .
						"0, " .
						"0, " .
						&quote_DB($bc_helper{jdata_acc_time}) .				# token_acc_time
						");"
					);

				$setup_db_knot->shlock;
				$build_carrier{prog_start}		= 0;
				$setup_db_knot->shunlock;
				}
			else {
				$setup_db_knot->shunlock;
				Time::HiRes::sleep(0.2);
				}
			}
		&debug_out(
			"Parent $ppid seems to be dead",
			);
		exit(0);
		}
	else {
		&debug_out(
			"setup(): Can't fork",
			);
		&pprop_exit();
		}

	# Set up main window
	my $mw	= MainWindow->new(
		%def_TL,
		-title		=> "${MainTitle}Setup",
		);
	# Check if monitor has enough px
	&check_ssize(2, $mw, $ww, $wh);
	$xpos		= ( $xpos ) ? $xpos : "+" . int(($mw->screenwidth - $ww)  / 2);
	$ypos		= ( $ypos ) ? $ypos : "+" . int(($mw->screenheight - $wh) / 2);

	&debug_out(
		"sub win_setup invoked with",
		"target			=: \"$source\"",
		"xpos				=: \"$xpos\"",
		"ypos				=: \"$ypos\"",
		);

	# Set window size and position
	$mw->geometry("${ww}x${wh}${xpos}${ypos}");
	$mw->resizable(0, 0);

	# Title text
	my $HeaderLabel		= $mw->Label(
		%def_lab,
		-justify	=> "left",
		)->pack(
			%def_lab_pack,
			-pady	=> 20,
			);
	sub set_header {
		my $target	= shift;
		my $header	= shift;
		my $subheader	= shift;
		$target->configure(
		-text		=> "\t$header\n" .
			"\t    $subheader",
			);
		}

	# Buttons (Cancel, Next, Back)
	my $BMainFrame		= $mw->Frame(
		-background	=> $def_bg_hex,
		)->pack(
			-fill	=> "none",
			-pady	=> 10,
			-side	=> "bottom",
			-anchor	=> "e",
			);

	my $btn_Cancel		= $BMainFrame->Button(
		%def_btn,
		-text		=> "Cancel",
		-width		=> 6,
		-command	=> sub {
			$mw->destroy();
			},
		)->pack(
			-fill	=> "none",
			-padx	=> 30,
			-side	=> "right",
			);

	my $btn_Next	= $BMainFrame->Button(
		%def_btn,
		-text		=> "Next",
		-width		=> 6,
		)->pack(
			-fill	=> "none",
			-side	=> "right",
			);

	my $btn_Back	= $BMainFrame->Button(
		%def_btn,
		-text		=> "Back",
		-width		=> 6,
		)->pack(
			-fill	=> "none",
			-padx	=> 1,
			-side	=> "right",
			);

	# Top seperator
	$mw->Frame(
		-background	=> $def_sep_hex,
		-height		=> 2,
		)->pack(
			-fill	=> "x",
			-anchor	=> "n",
			-padx	=> 5,
			-pady	=> 5,
			);

	# Subfunction defined frame
	my $ContentFrame	= $mw->Frame(
		-background	=> $def_bg_hex,
		)->pack(
			-fill	=> "both",
			-expand	=> 1,
			);


	# Bottom seperator
	$mw->Frame(
		-background	=> $def_sep_hex,
		-height		=> 2,
		)->pack(
			-fill	=> "x",
			-side	=> "bottom",
			-anchor	=> "s",
			-padx	=> 5,
			-pady	=> 5,
			);

	my($_sub_setup_content);	# Nested subfunction
	$_sub_setup_content		= sub {
		my $main	= shift;
		my $head	= shift;
		my $frame	= shift;
		my $back	= shift;
		my $next	= shift;
		my $target	= shift;
		my $source	= shift;
		my $xp		= 0;
		my $yp		= 0;
	
		if ( $main->geometry =~ m/^[0-9]+x[0-9]+([+-][0-9]+)([+-][0-9]+)$/ ) {
			$xp	= $1;
			$yp	= $2;
			}
		else {
			&debug_out(
				"\$main->geometry has a bad value \"" . $main->geometry . "\"",
				);
			(tied(%transport))->remove;
			exit(123);
			}

		if ( $target eq "start" ) {
			&set_header(
				$head,
				"Welcome!",
				"Let's start to set up $app_name!"
				);

			my $intro	= $frame->Label(
				%def_lab,
				-justify	=> "left",
				-text		=> "\t    Thank you for choosing $app_name.\n\n" .
					"\t    Setup will guide you through the intitializing process.\n" .
					"\t    Login will only be done on authentic EVE Online pages.\n" .
					"\t    Successful authentication is required for accessing station markets.\n\n" .
					"\t    During the initializing process we will do the following things:\n\n" .
					"\t\t$Signs{circle} inform you about the license of this application\n" .
					"\t\t$Signs{circle} register an application for authorization at $dev_url\n" .
					"\t\t$Signs{circle} logon on specific local URL to get the access code\n" .
					"\t\t$Signs{circle} set up database for further use (will be done by $app_name automatically)\n\n" .
					"\t    Details will be shown when needed.",
				)->pack(
					%def_lab_pack,
					-pady	=> 20,
					);
			
			$back->configure(
				-state		=> "disabled",
				);

			$next->configure(
				-command	=> sub {
					$intro->destroy;
					#undef($intro);
					$back->configure(
						-state	=> "normal",
						);
					&{$_sub_setup_content}(
						$main,
						$head,
						$frame,
						$back,
						$next,
						"license",
						$source
						);
					},
				);

			}
		elsif ( $target eq "license" ) {
			# Header text
			&set_header(
				$head,
				"License",
				"Read the license carefully before you agree!"
				);

			# License text
			my $lscroll	= $frame->Scrollbar(
				%def_scr,
				)->pack(
					-side	=> "right",
					-fill	=> "y",
					);

			$frame->pack(
				-padx		=> 30,
				);
			my $ltext	= $frame->Text(
				%def_txt,
				-wrap		=> "word",
				-yscrollcommand	=> [
					set	=> $lscroll,
					],
				)->pack(
					-side	=> "left",
					-expand	=> 1,
					-fill	=> "both",
					);

			$lscroll->configure(
				-command	=> [
					yview	=> $ltext,
					],
				);

			$ltext->insert("end", "
$app_name - get market data in a very good maner from EVE Online
Copyright (C) 2018 Author: https://github.com/DomAsProgrammer

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

- get market data in a very good maner from EVE Online Copyright (C) 2018 Author:
https://github.com/DomAsProgrammer

This program is free software: you can redistribute it and/or modify it under the terms of the GNU
Affero General Public License as published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero
General Public License for more details.

You should have received a copy of the GNU Affero General Public License along with this program.  If
not, see <https://www.gnu.org/licenses/>.


GNU AFFERO GENERAL PUBLIC LICENSE

Version 3, 19 November 2007

Copyright © 2007 Free Software Foundation, Inc. <https://fsf.org/>
Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.
Preamble

The GNU Affero General Public License is a free, copyleft license for software and other kinds of works, specifically designed to ensure cooperation with the community in the case of network server software.

The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, our General Public Licenses are intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users.

When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.

Developers that use our General Public Licenses protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License which gives you legal permission to copy, distribute and/or modify the software.

A secondary benefit of defending all users' freedom is that improvements made in alternate versions of the program, if they receive widespread use, become available for other developers to incorporate. Many developers of free software are heartened and encouraged by the resulting cooperation. However, in the case of software used on network servers, this result may fail to come about. The GNU General Public License permits making a modified version and letting the public access it on a server without ever releasing its source code to the public.

The GNU Affero General Public License is designed specifically to ensure that, in such cases, the modified source code becomes available to the community. It requires the operator of a network server to provide the source code of the modified version running there to the users of that server. Therefore, public use of a modified version, on a publicly accessible server, gives the public access to the source code of the modified version.

An older license, called the Affero General Public License and published by Affero, was designed to accomplish similar goals. This is a different license, not a version of the Affero GPL, but Affero has released a new version of the Affero GPL which permits relicensing under this license.

The precise terms and conditions for copying, distribution and modification follow.
TERMS AND CONDITIONS
0. Definitions.

\"This License\" refers to version 3 of the GNU Affero General Public License.

\"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.

\"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations.

To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work.

A \"covered work\" means either the unmodified Program or a work based on the Program.

To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.

To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.

An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.
1. Source Code.

The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work.

A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.

The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.

The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.

The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.

The Corresponding Source for a work in source code form is that same work.
2. Basic Permissions.

All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.

You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.

Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.
3. Protecting Users' Legal Rights From Anti-Circumvention Law.

No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.

When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.
4. Conveying Verbatim Copies.

You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.

You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.
5. Conveying Modified Source Versions.

You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified it, and giving a relevant date.
    b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\".
    c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it.
    d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so.

A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.
6. Conveying Non-Source Forms.

You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:

    a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange.
    b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge.
    c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b.
    d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements.
    e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d.

A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.

A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.

\"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.

If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).

The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.

Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.
7. Additional Terms.

\"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.

When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.

Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or
    b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or
    c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or
    d) Limiting the use for publicity purposes of names of licensors or authors of the material; or
    e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or
    f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors.

All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.

If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.

Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.
8. Termination.

You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).

However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.

Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.

Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.
9. Acceptance Not Required for Having Copies.

You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.
10. Automatic Licensing of Downstream Recipients.

Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.

An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.

You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.
11. Patents.

A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\".

A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.

Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.

In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.

If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.

If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.

A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.

Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.
12. No Surrender of Others' Freedom.

If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.
13. Remote Network Interaction; Use with the GNU General Public License.

Notwithstanding any other provision of this License, if you modify the Program, your modified version must prominently offer all users interacting with it remotely through a computer network (if your version supports such interaction) an opportunity to receive the Corresponding Source of your version by providing access to the Corresponding Source from a network server at no charge, through some standard or customary means of facilitating copying of software. This Corresponding Source shall include the Corresponding Source for any work covered by version 3 of the GNU General Public License that is incorporated pursuant to the following paragraph.

Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the work with which it is combined will remain governed by version 3 of the GNU General Public License.
14. Revised Versions of this License.

The Free Software Foundation may publish revised and/or new versions of the GNU Affero General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU Affero General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU Affero General Public License, you may choose any version ever published by the Free Software Foundation.

If the Program specifies that a proxy can decide which future versions of the GNU Affero General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.

Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.
15. Disclaimer of Warranty.

THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
16. Limitation of Liability.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
17. Interpretation of Sections 15 and 16.

If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.

END OF TERMS AND CONDITIONS
");
			$ltext->configure(
				-state	=> "disabled",
				);

			# Button functions
			$back->configure(
				-text		=> "Decline",
				-command	=> sub {
					unlink($0);
					&debug_out(
						"License declined",
						"\"$0\" deleted"
						);
					$main->destroy;
					},
				);

			$next->configure(
				-text		=> "Aggree",
				-command	=> sub {
					&debug_out(
						"License was accepted",
						);
					$lscroll->destroy;
					$ltext->destroy;
					$frame->pack(
						-padx		=> 0,
						);
					$back->configure(
						-text		=> "Back",
						-command	=> "",
						);
					$next->configure(
						-text		=> "Next",
						-command	=> "",
						);
					&{$_sub_setup_content}(
						$main,
						$head,
						$frame,
						$back,
						$next,
						"man_appIdKey",
						$source
						);
					},
				);
			}
		elsif ( $target eq "man_appIdKey" ) {
			&set_header(
				$head,
				"Creating application keys",
				"Here will be shown, what is needed to get the needed keys."
				);

			my $intro	= $frame->Label(
				%def_lab,
				-justify	=> "left",
				-text		=>
					"\t    Firstly we need an authorized application. To get one, you have to register an app using a specific configuration and\n" .
					"\t    insert the needed fields in $app_name in order to connect them to each other.\n\n" . 
					"\t    Now let's start. Go to $url_dev_apps and click \"manage applications\".\n" .
					"\t    Here you find \"create new application\".\n" .
					"\t    Click this and enter the following details:\n\n" .
					"\t\t$Signs{circle} Connection type: Authentication & API Access\n" .
					"\t\t$Signs{circle} Permissions:\n\t\t    " .
							join("\n\t\t    ", @scopes) .
							"\n" .
					"\t\t$Signs{circle} Callback url: $callback_url\n" .
					"\t\t$Signs{circle} Be creative in what you are using for the Name and Description fields. 😉\n\n" .
					"\t    You will be redirected to the \"your applications\" site after clicking \"create application\". Find further information\n" .
					"\t    by clicking the \"view application\" button.\n" .
					"\t    In this tab (\"View Details\") you find the needed entries. Copy-paste to the empty fields below",
				)->pack(
					%def_lab_pack,
					-pady	=> 20,
					);

			# Frame for grid label and input fields
			my $inputF	= $frame->Frame(
				-background	=> $def_bg_hex,
				-height		=> 100,
				)->pack(
					-side	=> "bottom",
					-fill	=> "x",
					#-expand	=> 1,
					);

			# WORK Label "Go to: "
			# WORK Protected entry field "developer.eveonline.com"

			# WORK Label "Callback url: "
			# WORK Protected entry field "..localhost..."

			my $aId_Label	= $inputF->Label(
				%def_lab,
				-anchor		=> "e",
				-text		=> "Client ID: ",
				)->grid(
					-column	=> 1,
					-row	=> 0,
					-sticky	=> "e",
					);

			my $aId_entry	= $inputF->Entry(
				%def_ety,
				-textvariable	=> \$Client_ID,
				-width		=> 50,
				)->grid(
					-column	=> 2,
					-row	=> 0,
					-sticky	=> "w",
					);

			my $aId_return	= $inputF->Label(
				%def_lab,
				)->grid(
					-column		=> 3,
					-row		=> 0,
					-sticky		=> "ew",
					);

			my $aSec_Label	= $inputF->Label(
				%def_lab,
				-anchor		=> "e",
				-text		=> "Secret Key: ",
				)->grid(
					-column	=> 1,
					-row	=> 1,
					-sticky	=> "e",
					);
			my $aSec_entry	= $inputF->Entry(
				%def_ety,
				-textvariable	=> \$Secret_Key,
				-width		=> 50,
				)->grid(
					-column	=> 2,
					-row	=> 1,
					-sticky	=> "w",
					);

			my $aSec_return	= $inputF->Label(
				%def_lab,
				)->grid(
					-column		=> 3,
					-row		=> 1,
					-sticky		=> "ew",
					);

			foreach my $key ( keys(%cols) ) {
				$inputF->gridColumnconfigure(
					$key,
					-minsize	=> $cols{$key},
					);
				}

			foreach my $key ( keys(%rows) ) {
				$inputF->gridRowconfigure(
					$key,
					-minsize	=> $rows{$key},
					);
				}

			$back->configure(
				-command	=> sub {
					$intro->destroy;
					$inputF->destroy;
					$back->configure(
						-command	=> "",
						);
					&{$_sub_setup_content}(
						$main,
						$head,
						$frame,
						$back,
						$next,
						"license",
						$source
						);
					},
				);

			$next->configure(
				-command	=> sub {
					my $miss	= 0;

					$Client_ID	=~ s/\s//g;
					$Secret_Key	=~ s/\s//g;

					if ( !$Client_ID ) {
						$aId_return->configure(
							-text		=> "$Signs{cross} missing entry",
							-foreground	=> $Colors{red},
							);
						$miss	+= 1;
						&debug_out(
							"Missing \"Client ID\"",
							);
						}
					else {
						$aId_return->configure(
							-text		=> "",
							);
						}

					if ( !$Secret_Key ) {
						$aSec_return->configure(
							-text		=> "$Signs{cross} missing entry",
							-foreground	=> $Colors{red},
							);
						$miss	+= 1;
						&debug_out(
							"Missing \"Secret Key\"",
							);
						}
					else {
						$aSec_return->configure(
							-text		=> "",
							);
						}

					if ( $miss ) {
						&debug_out(
							"Exit $miss",
							);
						return($miss);
						}
					else {
						$main_knot->shlock;
						$transport{Client_ID}	= $Client_ID;
						$transport{Secret_Key}	= $Secret_Key;
						&debug_out(
							"Client ID:	" . $transport{Client_ID},
							"Secret Key:	" . $transport{Secret_Key},
							);
						$main_knot->shunlock;
						$next->configure(
							-command	=> "",
							);
						$intro->destroy;
						$inputF->destroy;
						&{$_sub_setup_content}(
							$main,
							$head,
							$frame,
							$back,
							$next,
							"get_Acc_code",
							$source
							);
						}
					},
				);

			}
		elsif ( $target eq "get_Acc_code" ) {
			&set_header(
				$head,
				"Access code",
				"Retrive access code for character authentication"
				);

			my $intro	= $frame->Label(
				%def_lab,
				-justify	=> "left",
				-text		=>
					"\t    We must now authenticate your character. To do so copy the following link into your favorite web browser and\n" .
					"\t    press <RETURN>.\n" .
					"\t    You'll end up at a failure page. You will see an error message like \"Can't connect to server\". This is\n" .
					"\t    expected, because supposedly you don't run a web server on your computer (localhost) where it redirects you to.\n\n" .
					"\t    Please insert the part after \"...code=\"",
				)->pack(
					%def_lab_pack,
					-pady	=> 20,
					);

			my $inputF	= $frame->Frame(
				-background	=> $def_bg_hex,
				-height		=> 100,
				)->pack(
					-side	=> "bottom",
					-fill	=> "x",
					#-expand	=> 1,
					);

			my $link_Label	= $inputF->Label(
				%def_lab,
				-anchor		=> "e",
				-text		=> "This is the link to insert\n" .
					"into your browser: ",
				)->grid(
					-column	=> 1,
					-row	=> 0,
					-sticky	=> "e",
					);

			my $link_Text	= $inputF->Text(
				%def_ety,
				-height		=> 4,
				-width		=> 50,
				)->grid(
					-column	=> 2,
					-row	=> 0,
					-sticky	=> "w",
					);
			$main_knot->shlock;
			$link_Text->insert("end",
				"$lsburl/oauth/authorize?response_type=code" .
				"&redirect_uri=${callback_url}" .
				"&client_id=" . $transport{Client_ID} .
				"&scope=" . join('%20', @scopes),
				);
			$main_knot->shunlock;
			$link_Text->configure(
				-state		=> "disabled",
				);

			my $copied_string	= "";
			my $link_return	= $inputF->Label(
				%def_lab,
				-textvariable	=> \$copied_string,
				)->grid(
					-column		=> 3,
					-row		=> 0,
					-sticky		=> "ew",
					);
			$link_Text->bind(
				"<ButtonRelease-1>",
				sub {
					$link_Text->SelectionClear;
					$link_Text->tagAdd(
						"sel",
						"1.0",
						"end",
						);

					$link_Text->clipboardAppend($link_Text->SelectionGet);

					$copied_string	= "Copied to clipboard";
					$link_return->after(5000, sub {
						$copied_string	= "";
						});
					},
				);

			my $getA_Label	= $inputF->Label(
				%def_lab,
				-anchor		=> "e",
				-text		=> "http://localhost/oauth-callback?code=",
				)->grid(
					-column	=> 1,
					-row	=> 1,
					-sticky	=> "e",
					);

			my $getA_Entry	= $inputF->Entry(
				%def_ety,
				-textvariable	=> \$access_code,
				-width		=> 50,
				)->grid(
					-column	=> 2,
					-row	=> 1,
					-sticky	=> "w",
					);

			my $getA_return	= $inputF->Label(
				%def_lab,
				)->grid(
					-column		=> 3,
					-row		=> 1,
					-sticky		=> "ew",
					);

			my $shw_ChrTag	= $inputF->Label(
				%def_lab,
				-anchor		=> "e",
				-text		=> "Character: ",
				)->grid(
					-column	=> 1,
					-row	=> 2,
					-sticky	=> "e",
					);

			my $shw_ChrName	= $inputF->Label(
				%def_lab,
				-anchor		=> "w",
				)->grid(
					-column	=> 2,
					-row	=> 2,
					-sticky	=> "w",
					);

			foreach my $key ( keys(%cols) ) {
				$inputF->gridColumnconfigure(
					$key,
					-minsize	=> $cols{$key},
					);
				}


			foreach my $key ( keys(%rows) ) {
				$inputF->gridRowconfigure(
					$key,
					-minsize	=> $rows{$key},
					);
				}
			$back->configure(
				-command	=> sub {
					$back->configure(
						-state		=> "enabled",
						-command	=> "",
						);
					$next->configure(
						-state		=> "enabled",
						-command	=> "",
						);
					$inputF->destroy;
					$intro->destroy;
					&{$_sub_setup_content}(
						$main,
						$head,
						$frame,
						$back,
						$next,
						"man_appIdKey",
						$source
						);
					},
				);
			$next->configure(
				-command	=> sub {
					$next->configure(
						-state	=> "disabled",
						);
					$back->configure(
						-state	=> "disabled",
						);
					$getA_Entry->configure(
						-state	=> "disabled",
						);

					$access_code	=~ s/\s//g;
					$access_code	=~ s/^http:\/\/localhost\/oauth-callback\?code=//;

					# Entry field must not be empty
					$main_knot->shlock;
					if ( !$access_code ) {
						$main_knot->shunlock;
						$getA_return->configure(
							-text		=> "$Signs{cross} missing entry",
							-foreground	=> $Colors{red},
							);
						&debug_out(
							"Acces code field empty",
							);
						$next->configure(
							-state	=> "normal"
							);
						$back->configure(
							-state	=> "normal"
							);
						$getA_Entry->configure(
							-state	=> "normal",
							);
						return(1);
						}
					# Check if already running
					elsif ( $transport{login_start} ) {
						$main_knot->shunlock;
						&debug_out(
							"Tried to start login again",
							);
						return(2);
						}
					# Access codes can be used only one time
					elsif ( grep(/$access_code/, @accCodes) ) {
						$main_knot->shunlock;
						$getA_return->configure(
							-text		=> "$Signs{cross} already used",
							-foreground	=> $Colors{red},
							);
						&debug_out(
							"Access code \"$access_code\" was used multiple times",
							);
						$next->configure(
							-state	=> "normal"
							);
						$back->configure(
							-state	=> "normal"
							);
						$getA_Entry->configure(
							-state	=> "normal",
							);
						return(3);
						}
					else {
						my $pen_text		= "working";
						my $pending		= pending->new($Signs{ball});
						my $circle		= "";
						push(@accCodes, $access_code);
						$main_knot->shlock;
						$transport{access_code}	= $access_code;
						$main_knot->shunlock;

						my $_sub_check_login_status	= sub {
							$getA_return->configure(
								-text		=> $pending->motion . " $pen_text",
								);
							$main_knot->shlock;
							if ( $transport{login_return} == 1 ) {
								$circle->cancel;
								$getA_return->configure(
									-text		=> "$Signs{tick} success",
									-foreground	=> $Colors{green},
									);
								$shw_ChrName->configure(
									-text		=> $transport{CharacterName},
									);
								$main_knot->shunlock;
								
								$mw->after(
									2000,
									sub {
										$main_knot->shlock;
										$transport{login_return}	= 0;
										$main_knot->shunlock;

										$back->configure(
											-state		=> "normal",
											-command	=> "",
											);
										$next->configure(
											-state		=> "normal",
											-command	=> "",
											);
										$intro->destroy;
										$inputF->destroy;
										&{$_sub_setup_content}(
											$main,
											$head,
											$frame,
											$back,
											$next,
											"progress",
											$source
											);
										},
									);
								}
							elsif ( $transport{login_return} == 2 ) {
								$getA_return->configure(
									-text		=> "$Signs{cross} failed",
									-foreground	=> $Colors{red},
									);
								$next->configure(
									-state	=> "normal"
									);
								$back->configure(
									-state	=> "normal"
									);
								$getA_Entry->configure(
									-state	=> "normal",
									);
								$transport{login_return}	= 0;
								$main_knot->shunlock;
								$circle->cancel;
								}
							else {
								$main_knot->shunlock;
								}
							};

						$getA_return->configure(
							-text		=> $pending . " $pen_text",
							-foreground	=> $Colors{blue},
							);

						# Start and check for success
						$circle	= $mw->repeat(
							300		=> \$_sub_check_login_status,
							);
						$main_knot->shlock;
						$transport{login_start}			= 1;
						$main_knot->shunlock;
						# Continues immediately
						}
					},
				);
			}
		# Build database and other environment
		elsif ( $target eq "progress" ) {
			&set_header(
				$head,
				"Setting up",
				"Applying the entered data and needed configurations for use.",
				);

			$next->configure(
				-state		=> "disabled",
				);

			$back->configure(
				-state		=> "disabled",
			);

			$frame->pack(
				-padx		=> 100,
				-pady		=> 100,
				);

			my $prog_bar	= $frame->ProgressBar(
				%def_pgB,
				-blocks		=> $maximum,
				-to		=> $maximum,
				-value		=> 0,
				)->pack(
					-fill	=> "both",
					-anchor	=> "center",
					);

			$main_knot->shlock;
			my $prog_label	= $frame->Label(
				%def_lab,
				-text	=> $transport{prog_ltext},
				)->pack(
					%def_lab_pack,
					-pady	=> 5,
					);
			$main_knot->shunlock;

			my $circle		= "";
			my $prog_ltext_old	= "";
			my $_sub_check_build_status	= sub {
				$main_knot->shlock;
				while ( ($prog_bar->configure("-value"))[4] <= $transport{prog_counter} ) {
					$main_knot->shunlock;

					$prog_bar->configure(
						-value		=> ($prog_bar->configure("-value"))[4] + 1,
						);

					$main_knot->shlock;
					if ( $transport{prog_ltext} ne $prog_ltext_old ) {
						$prog_label->configure(
							-text		=> $transport{prog_ltext},
							);
						$prog_ltext_old		= $transport{prog_ltext};
						}
					$main_knot->shunlock;

					$mw->update;

					if ( ($prog_bar->configure("-value"))[4] >= $maximum ) {
						$prog_label->configure(
							-text		=> "Done",
							);
						$mw->update;
						$circle->cancel;
						$mw->after(
							1500,
							sub {
								$next->configure(
									-state		=> "normal",
									);
								$back->configure(
									-state		=> "normal",
									);
								$frame->pack(
									-padx		=> 0,
									-pady		=> 0,
									);
								$prog_bar->destroy;
								$prog_label->destroy;
								&{$_sub_setup_content}(
									$main,
									$head,
									$frame,
									$back,
									$next,
									"finish",
									$source
									);
								},
							);
						return(1);
						}
					else {
						$main_knot->shlock;
						}
					}
				$main_knot->shunlock;
				};

			$circle		= $mw->repeat(
				250		=> \$_sub_check_build_status,
				);
			$main_knot->shlock;
			$transport{prog_start}	= 1;
			$main_knot->shunlock;
			}
		# Finish
		elsif ( $target eq "finish" ) {
			$setup_finished	= 1;
			&set_header(
				$head,
				"Finished",
				"Program is set up and shoud be ready to use.",
				);

			my $intro	= $frame->Label(
				%def_lab,
				-justify	=> "left",
				-text		=>
					"\t    Setup is done.\n" .
					"\t    You can start the program if you want by setting the tick and clicking \"Finished\", but be aware:\n" .
					"\t    On first startup there will be a huge update. This means a lot of data will be downloaded and stored into the\n" .
					"\t    database. Unless this isn't done, no hauling opportunities can be shown!",
				)->pack(
					%def_lab_pack,
					-pady	=> 20,
					);

			my $tick	= $frame->Checkbutton(
				%def_cbtn,
				-text		=> "Start $app_name after finish",
				-anchor		=> "s",
				-variable	=> \$tick_exec_after,
				)->pack(
					-pady	=> 100,
					);

			$next->configure(
				-text		=> "Finish",
				-command	=> sub {
					$mw->destroy;
					},
				);
			$back->configure(
				-state		=> "disabled",
				);
			$btn_Cancel->configure(
				-state		=> "disabled",
				);

			}
		else {
			&err_msg(
				3,
				$MainTitle,
				"FATAL ERROR #3",
				);
			}
		};

	# Window content
	&{$_sub_setup_content}(
		$mw,
		$HeaderLabel,
		$ContentFrame,
		$btn_Back,
		$btn_Next,
		$source,
		$source,
		);

	$mw->MainLoop;	# END
	
	# Exit childs
	&pprop_exit(1);

	if ( $tick_exec_after && $setup_finished ) {
		my $cmd		= "\"" . realpath($0) . "\" @argv_backup";
		&debug_out(
			"User set tick to start main app after setup",
			"Executing \$($cmd)",
			);
		(tied(%transport))->remove;
		exec($cmd) or die "Failed to start program: $?\n";
		}
	elsif ( $setup_finished ) {
		&debug_out(
			"User set tick not to start after setup",
			"Exiting...",
			);
		}
	else {
		(tied(%transport))->remove;
		}
	exit(0);
	}

sub helper {
	if ( $help ) {
		print "Usage: $0 [option] [argument]\n\n",
			"\toption		argument		descritpion\n",
			"\t-d|--debug				get many output of what is happening\n",
			"\t-D|--database	/path/to/sqlite.db	set path for database manually\n",
			"\t-h|--help				show this help and exit\n\n";
		(tied(%transport))->remove;
		exit(0);
		}
	else {
		return(1);
		}
	}

sub check_version {
	my @versions		= &access_DB("SELECT version FROM characters ;");

	# Upgrade procedures
	my @updates		= (
		{
			version => "v1.8",
			update => sub {
				&debug_out(qq{Your database is to old! Database upgrades are supported since version 1.8, not before.\n} .
					qq{Delete your database and let us create a new one. (Database file: "$database")});
				print STDERR qq{Your database is to old! Database upgrades are supported since version 1.8, not before.\n} .
					qq{Delete your database and let us create a new one. (Database file: "$database"};
				return(0);
				},
			},
		#{
			#version => "v1.",
			#update => sub {
				#},
			#},
		);

	# Make numbers version conform
	foreach ( @versions, @updates ) { $_->{version} =~ s/^v?/v/i; }
	my $app_version		= "$app_version";
	$app_version		=~ s/^v?/v/i;

	upgrade_from_newest:
	foreach my $db_version ( sort { version->parse($b->{version}) <=> version->parse($a->{version}) } @versions ) {
		my $db_version	= $db_version->{version};	# Easier access

		if ( version->parse($db_version) < version->parse($app_version) ) {

			&debug_out(qq{Updating $db_version database...});
			foreach my $new ( sort { version->parse($a->{version}) <=> version->parse($b->{version}) } @updates ) {
				if ( version->parse($db_version) < version->parse($new->{version}) ) {
					if ( &{$new->{update}}() ) {	# Apply changes
						&debug_out("Update succeded!");
						&access_DB("UPDATE characters SET version = " . &quote_DB($new->{version}) . " ;");	# Database upgrades apply to all users
						$db_version	= $new->{version};
						}
					else {
						&debug_out("Update failed!");
						return(0);
						}
					}
				}
			}
		elsif ( version->parse($app_version) < version->parse($db_version) ) {
			&debug_out(qq{Your database is to new: $db_version, while your're running $app_name $app_version .\n} .
				qq{This is not a good idea and will lead to program crashes. Make sure you started $app_name from correct file or check online for updates!});
			print STDERR qq{Your database is to new: $db_version, while your're running $app_name $app_version .\n} .
				qq{This is not a good idea and will lead to program crashes. Make sure you started $app_name from correct file or check online for updates!};
			return(0);
			}

		last(upgrade_from_newest);	# We want only check the newest entry
		}

	return(1);
	}

sub compare_hash {
	my $h1		= shift;
	my $h2		= shift;
	my $diffs	= 0;

	if ( scalar(keys(%{$h1})) != scalar(keys(%{$h2})) ) {
		$diffs	= scalar(keys(%{$h1})) - scalar(keys(%{$h2}));
		if ( $diffs < 0 ) {
			$diffs	*= -1;
			}
		}
	else {
		foreach my $key ( sort(keys(%{$h1})) ) {
			if ( !( defined($h2->{$key}) && $h1->{$key} eq $h2->{$key} ) ) {
				$diffs++;
				}
			}
		}
	
	if ( $diffs ) {
		&debug_out("compare_hash(): Found $diffs differences");
		}
	return($diffs);
	}

sub err_msg {
	my $level	= shift;
	my $name	= shift;
	my $text	= join(" ", @_);
	my $window	= "";
	my %init	= (
		-title		=> "${MainTitle}ERROR",
		-background	=> $def_bg_hex,
		);

	$window	= MainWindow->new(
		%init,
		);

	my $w	= 300;
	my $h	= 120;
	$window->geometry("${w}x${h}+" . int(($window->screenwidth - $w) / 2) . "+" . int(($window->screenheight - $h) / 2));
	$window->resizable(0, 0);

	if ( !$text ) {
		$text	= "FATAL ERROR $level";
		}
	elsif ( length($text) > 115 ) {
		print STDERR "\n\nText is to long for window!!!\n\n";
		exit(123);
		}
	else {
		$text	=~ s/(.){35,40}\K /\n/g;
		}

	$window->Label(
		%def_lab,
		-text		=> "\n$text\n",
		-padx		=> 20,
		)->pack(
			-fill	=> "none",
			-expand	=> 1,
			);
	$window->Button(
		%def_btn,
		-text		=> "Quit",
		-command	=> sub {
			$window->destroy();
			},
		)->pack(
			-fill	=> "none",
			-expand	=> 1,
			-side	=> "bottom",
			-padx	=> 5,
			-pady	=> 10,
			);

	$window->MainLoop;
	exit($level);
	}

sub check_ssize {
	my $errlvl	= shift;
	my $window	= shift;
	my $width	= shift;
	my $height	= shift;

	if ( $window->screenwidth - $width < 0 || $window->screenheight - $height < 0 ) {
		my $w	= 300;
		my $h	= 120;
		$window->geometry("${w}x${h}+" . int(($window->screenwidth - $w) / 2) . "+" . int(($window->screenheight - $h) / 2));
		$window->resizable(0, 0);
		$window->Label(
			%def_lab,
			-text		=> "\nYour monitor is to small!\n" .
				"The window needs at least ${width}x$height px",
			-padx		=> 20,
			)->pack(
				-fill	=> "none",
				-expand	=> 1,
				);
		$window->Button(
			%def_btn,
			-text		=> "Quit",
			-command	=> sub {
				$window->destroy();
				},
			)->pack(
				-fill	=> "none",
				-expand	=> 1,
				-padx	=> 5,
				-pady	=> 10,
				);
			

		$window->MainLoop;
		exit($errlvl);
		}
	else {
		return(1);
		}
	}

# Use location id of structure or station for distungishing which it is exactly
sub is_ccp_station {
	my $num		= shift;

	# Id from 60.000.000 to 64.000.000 are CCP stations
	if ( $num >= 60_000_000 && $num <= 64_000_000 ) {
		return(1);
		}
	# Orders of stations from 1_021_010_937_882 to 1_032_811_159_323 are the current structures generated by players (stand 2020-03-27)
	else {
		return(0);
		}
	}

sub get_security_color_hex {
	my $security_status	= shift;

	&debug_out(qq{get_security_color_hex(): got value "$security_status"});

	if ( defined($Colors{security}->{sprintf("%.1f", $security_status)}) ) {
		return($Colors{security}->{sprintf("%.1f", $security_status)});
		}
	elsif ( $security_status == 1 ) {
		return($Colors{security}->{1});
		}
	else {
		return($Colors{security}->{0});
		}
	}

sub pprop_exit {
	my $no_exit	= shift;

	# Inform children
	foreach my $child ( @childs ) {
		&debug_out("pprop_exit(): Ask $child to hang up");
		# WORK Ask if child is still living
		if ( kill(0 => $child) ) {
			kill(HUP => $child);
			}
		}

	# Wait for children
	while ( grep { kill(0 => $_) } @childs ) {
		&debug_out("pprop_exit(): Waiting for children to hang up");
		sleep(1);
		}

	if ( defined($no_exit) && $no_exit ) {
		return(1);
		}
	else {
		&up_lock(0);
		&db_lock(1);
		cp($database, "$database.tmp") or print STDERR "Can't create backup file!\n";
		move("$database.tmp", "$database.bak") or print STDERR "Can't create backup file!\n";
		&db_lock(0);
		(tied(%transport))->remove;
		exit(0);
		}
	}

sub cprop_exit {
	&debug_out("cprop_exit(): Received an INT or HUP");
	exit(0);
	}

sub get_count_of_CPUs {
	my $cpuinfo	= "/proc/cpuinfo";
	my $CPUs	= 2;

	if ( ! defined($_CPU_count) ) {

		if ( -e $cpuinfo ) {
			if ( open(my $proc_h, "<", $cpuinfo) ) {
				$CPUs	= scalar(grep { m/^processor\s*:\s*[0-9]+/ } <$proc_h>);
				close($proc_h);
				}
			}

		if ( $CPUs > 0 ) {
			$_CPU_count	= $CPUs;
			}
		}

	return($_CPU_count);
	}

# Quote for database
sub quote_DB {
	my $content	= shift;

	# If it is null
	if ( ( defined($content) && $content =~ m/^NULL$/i ) || !( defined($content) ) ) {
		return("NULL");
		}
	# If it is an integer or floating number or numeric boolean
	elsif ( $content =~ m/^-?[0-9]+(\.[0-9]+)?$/ ) {
		return($content);
		}
	# If it is boolean
	elsif ( $content =~ m/^(TRUE|FALSE)$/i ) {
		if ( $content =~ m/^TRUE$/i ) {
			return(1);
			}
		else {
			return(0);
			}
		}
	# If it is a string
	else {
		$content =~ s/'|`|´/''/g;	# quote ' and `
		$content =~ s/^|$/'/g;		# encapsulate the whole string in '
		return($content);
		}
	}

sub up_lock {	# user's pid
	my $lock_requested	= shift;
	my $lock_knot		= tie(my %lock_hash, 'IPC::Shareable', $transID);
	my $running		= 0;
	$lock_knot->shlock;
	my $cid			= $lock_hash{CharacterID};
	$lock_knot->shunlock;

	if ( $$ != $ppid ) {
		&debug_out("up_lock(): This function may only used by parent!");
		return(0);
		}

	my $pid		= [ &access_DB("SELECT in_use FROM characters WHERE id == " . &quote_DB($cid) . " ;") ];

	if ( ref($pid->[0]) ) {
		$pid		= $pid->[0]->{in_use};
		}
	else {
		&debug_out("up_lock(): Couldn't distungish database data!");
		return(0);
		}

	# Lock
	if ( $lock_requested ) {
		&debug_out("up_lock(): Lock was requested");

		# Already locked for this pid
		if ( $pid == $ppid ) {
			&debug_out("up_lock(): Is already locked...");
			return(1);
			}
		# Locked by different pid
		elsif ( $pid ) {
			my $user	= "";
			if ( $ENV{USER} ) {
				$user	= $ENV{USER};
				}
			else {
				chomp($user	= qx(whoami));
				}
			open(my $ph, "-|", qq{"$pgrep" -u $user "} . (fileparse($0))[0] . qq{"}) or die "up_lock(): Can't run pgrep\n";
				while ( my $running_pid	= <$ph> ) {
					chomp($running_pid);

					if ( $running_pid == $pid && kill(0 => $running_pid) ) {
						$running	= 1;
						}
					}
				close($ph);

			if ( $running ) {
				&debug_out(qq{up_lock(): $app_name already running on this character on PID $pid});
				return(0);
				}
			else {
				&debug_out(qq{up_lock(): $pid is saved, but not running; forcefully unlocking and relocking...});
				&access_DB("UPDATE characters SET in_use = " . &quote_DB(0) . " WHERE id == " . &quote_DB($cid) . " ;") or do {
					&debug_out("up_lock(): unable to unlock!");
					return(0);
					};
				return(&up_lock(1));
				}
			}
		# $pid == 0 => nothing is set, we can lock
		else {
			&access_DB("UPDATE characters SET in_use = " . &quote_DB($ppid) . " WHERE id == " . &quote_DB($cid) . " ;");
			&debug_out("up_lock(): Locked!");
			return(1);
			}
		}
	# Unlock
	else {
		&debug_out("up_lock(): Unlock was requested");
		if ( $pid == $ppid ) {
			&access_DB("UPDATE characters SET in_use = " . &quote_DB(0) . " WHERE id == " . &quote_DB($cid) . " ;");
			&debug_out("up_lock(): Unlocked!");
			return(1);
			}
		else {
			&debug_out("up_lock(): We're not going to unlock different processes while running!");
			return(0);
			}
		}
	}

sub dl_lock {
	my $lock_requested	= shift;	# 1 = please lock, 0 = please unlock
	my $lock_knot		= tie(my %lock_hash, 'IPC::Shareable', $transID);

	if ( $lock_requested ) {
		while ( 1 ) {
			$lock_knot->shlock;
			if ( !$lock_hash{dl_locked} ) {
				$lock_hash{dl_locked}	= 1;
				$lock_knot->shunlock;
				&debug_out("dl_lock(): Locked!");
				$lock_hash{dl_locked}	= 1;
				return(1);
				}
			else {
				$lock_knot->shunlock;
				Time::HiRes::sleep(0.1);
				}
			}
		}
	else {
		$lock_knot->shlock;
		$lock_hash{dl_locked}		= 0;
		$lock_knot->shunlock;
		&debug_out("dl_lock(): Unlocked!");
		return(1);
		}
	}

sub priority_lock {
	my $lock_requested	= shift;	# 1 = please lock, 0 = please unlock
	my $lock_knot		= tie(my %lock_hash, 'IPC::Shareable', $transID);

	if ( $lock_requested ) {
		while ( 1 ) {
			$lock_knot->shlock;
			if ( !$lock_hash{pt_locked} ) {
				$lock_hash{pt_locked}	= 1;
				$lock_knot->shunlock;
				&debug_out("priority_lock(): Locked!");
				return(1);
				}
			else {
				$lock_knot->shunlock;
				Time::HiRes::sleep(0.1);
				}
			}
		}
	else {
		$lock_knot->shlock;
		$lock_hash{pt_locked}		= 0;
		$lock_knot->shunlock;
		&debug_out("priority_lock(): Unlocked!");
		return(1);
		}
	}

sub db_lock {
	my $lock_requested	= shift;	# 1 = please lock, 0 = please unlock
	my $pt_switch		= shift;	# PrioriTy switch
	my $lock_knot		= tie(my %lock_hash, 'IPC::Shareable', $transID);

	if ( defined($pt_switch) ) {
		$pt_switch		= ( $pt_switch eq "decontrol" ) ? 1 : 0;
		}
	else {
		$pt_switch		= 0;
		}

	if ( $lock_requested ) {
		while ( 1 ) {
			$lock_knot->shlock;
			if ( !$lock_hash{db_locked} && !-s "$database-journal" && !-s "$database.tmp" && ( !$lock_hash{pt_locked} || $pt_switch ) ) {
				$lock_hash{db_locked}	= 1;
				$lock_knot->shunlock;
				&debug_out("db_lock(): Locked!");
				return(1);
				}
			else {
				$lock_knot->shunlock;
				Time::HiRes::sleep(0.1);
				}
			}
		}
	else {
		$lock_knot->shlock;
		$lock_hash{db_locked}		= 0;
		$lock_knot->shunlock;
		&debug_out("db_lock(): Unlocked!");
		return(1);
		}
	}

sub db_token {
	my $request		= shift;
	my $prio		= shift;
	my $lock_knot		= tie(my %lock_hash, 'IPC::Shareable', $transID);

	if ( $request ) {
		$lock_knot->shlock;
		my $ticket_num	= $lock_hash{ticket};
		$lock_hash{ticket}++;
		$lock_knot->shunlock;

		while ( 1 ) {
			$lock_knot->shlock;
			if ( $ticket_num <= $lock_hash{rqn} ) {
				$lock_knot->shunlock;
				&db_lock(1, $prio);
				return(1);
				}
			else {
				$lock_knot->shunlock;
				Time::HiRes::sleep(0.1);
				}
			}
		}
	else {
		&db_lock(0, $prio);
		$lock_knot->shlock;
		$lock_hash{rqn}++;
		$lock_knot->shunlock;
		}
	}

# Run SQL statements
sub access_DB {
	my $statement	= shift;
	my $pt_switch	= shift;
	my $is_select	= 0;
	my $is_vaccum	= 0;
	my $db_knot	= tie(my %DB_carrier, 'IPC::Shareable', $transID);

	if ( $statement !~ m/;(?:\s|\s--.+)*$/p ) {
		&debug_out(
			"access_DB(): Bad statement:\n\t$statement",
			"access_DB(): Only one statement allowed!",
			);
		return(0);
		}
	elsif ( $statement =~ m/^\s*SELECT/i ) {
		$is_select	= 1;
		&debug_out("access_DB(): Statement is only a select");
		}
	elsif ( $statement =~ m/^VACUUM;?$/i ) {
		$is_vaccum	= 1;
		&debug_out("access_DB(): Statement requests to VACUUM");
		}

	$statement	=~ s/;(?:\s|\s--.+)*$//; 

	my $_sub_stop_on_create = sub {
		&debug_out(
			"access_DB(): $DBI::errstr",
			);
		kill(HUP => $ppid);
		$db_knot->shlock;
		$DB_carrier{error_stmt}	= $DBI::errstr;	# Report about error in statement
		$db_knot->shunlock;
		if ( ! $is_select ) {
			&db_token(0, $pt_switch);
			}
		return(0);
		};

	# Connect to DB
	if ( ! $is_select ) {
		&db_token(1, $pt_switch);
		}
	my $dbh		= DBI->connect(
		$dsn,
		$user_id,
		$password,
		{
			RaiseError	=> 0,
			ReadOnly	=> $is_select,	# Bad??
			AutoCommit	=> 1, #$is_select,
			},
		) or do {
			&{$_sub_stop_on_create}();
			return(0);
			};
	&debug_out(qq{access_DB(): established connection to: "$dsn"});

	my $_sub_stop = sub {
		&debug_out("access_DB(): " . $dbh->errstr);
		print STDERR qq{access_DB(): Error on statment "$statement": } . $dbh->errstr . qq{\n};
		if ( ! $is_select ) {
			$dbh->rollback();
			}
		$dbh->disconnect();
		$db_knot->shlock;
		$DB_carrier{error_stmt}	= $dbh->errstr;	# Report about error in statement
		$db_knot->shunlock;
		if ( ! $is_select ) {
			&db_token(0, $pt_switch);
			}
		return(1);
		};

	# Set proper exit
	local $SIG{HUP}	= \$_sub_stop;
	local $SIG{INT}	= \$_sub_stop;

	my $_sub_vacuum	= sub {
    		local $dbh->{AutoCommit} = 1;
    		$dbh->do("VACUUM");
    		return(1);
		};

	# Enforce foreign key check for write access
	if ( $is_vaccum ) {
		#$dbh->commit();
		&{$_sub_vacuum}();
		#$dbh->commit();
		$dbh->disconnect();
		&db_token(0, $pt_switch);
		return(1);
		}
	elsif ( ! $is_select ) {
		$dbh->do("PRAGMA foreign_keys = ON;") or do {
			&{$_sub_stop}();
			return(0);
			};

#=begin problem5
		$dbh->do("PRAGMA journal_mode = MEMORY;") or do {
			&{$_sub_stop}();
			return(0);
			};
#=end problem5
#=cut
		}
	elsif ( $is_select ) {
		$dbh->do("PRAGMA temp_store = MEMORY;") or do {
			&{$_sub_stop}();
			return(0);
			};
		}

	&debug_out("access_DB(): issuing statment:\n$statement");
	if ( $is_select ) {
		my $sth		= $dbh->prepare($statement) or do {
			&{$_sub_stop}();
			return(0);
			};
		my $rcode	= $sth->execute() or do {
			&{$_sub_stop}();
			return(0);
			};

		if ( !defined($rcode) || $rcode < 0 ) {
			&debug_out("access_DB(): failure with return code $rcode (error code)");
			&{$_sub_stop}();
			return(0);
			}
		elsif ( $rcode ) {
			my @sel_out	= ();
			my $columns	= $sth->{NAME};
			while ( my $row = $sth->fetchrow_arrayref() ) {
				my %tmp	= ();
				for ( my $i = 0 ; $i < scalar(@{$columns}) ; $i++ ) {
					$tmp{$columns->[$i]}	= $row->[$i];
					}
				push(@sel_out, { %tmp });
				}
			$dbh->disconnect();
			&debug_out("access_DB(): successfully selected " . &human_readable(scalar(@sel_out)) . " record" . ( ( scalar(@sel_out) != 1 ) ? "s" : "" ) );
			return(@sel_out);
			}
		else {
			return(0);
			}
		}
	else {
		my $rcode	= $dbh->do($statement) or print STDERR "$statement failed: " . $dbh->errstr;

		#$dbh->commit();
		$dbh->disconnect();
		if ( ! $is_select ) {
			&db_token(0);
			}
		if ( defined($rcode) ) {
			&debug_out("access_DB(): success with return code $rcode (affected records)");
			}
		else {
			&debug_out("access_DB(): Statement failed!");
			}
		return($rcode);
		}
	}

sub main_table_perl_join {
	my $character_id	= shift;
	my @characters_table	= &access_DB("SELECT * FROM characters   WHERE           id == $character_id ;");
	my @leftovers_table	= &access_DB("SELECT * FROM leftovers    WHERE character_id == $character_id ;");
	#my @purchased_table	= &access_DB("SELECT * FROM purchased    WHERE character_id == $character_id ;");
	my @sells_table		= &access_DB("SELECT * FROM orders_sells WHERE character_id == $character_id AND id NOT IN ( SELECT sell_id FROM purchased WHERE character_id == $character_id ) ;");	# Security and ignores are done
	my %buys_table		= (); 
	my @done_hauls_table	= ();	# This table will be returned
	my @jumps_list		= ();	# SELECT comes later, when the WHERE clause is known
	my @jumps_where_clause	= ();
	my $cargo_maximum	= 0;
	my $investment_maximum	= 0;
	my $profit_minimum	= 0;
	my $route_security	= 0;
	my $tax			= 1;

	&priority_lock(0);

	if ( scalar(@leftovers_table) == 1 && scalar(@characters_table) == 1 ) {
		$cargo_maximum		= $leftovers_table[0]->{cargo};
		$investment_maximum	= $leftovers_table[0]->{money};
		$profit_minimum		= $characters_table[0]->{profit_minimum};
		$route_security		= $characters_table[0]->{route_security};
		$tax			= $characters_table[0]->{tax};
		}
	else {
		return(0);
		}

	# Prepare buys_table
	foreach my $buy_record ( &access_DB("SELECT * FROM orders_buys  WHERE character_id == $character_id AND id NOT IN ( SELECT buy_id FROM purchased WHERE character_id == $character_id ) ;") ) { # Security and ignores are done 
		if ( $buy_record->{packaged_volume} <= $cargo_maximum ) {
			#if ( !( grep { $buy_record->{id} == $_->{buy_id} } @purchased_table ) ) {
				if ( ! defined($buys_table{$buy_record->{type_id}}) ) {
					$buys_table{$buy_record->{type_id}}	= [];
					}

				push(@{$buys_table{$buy_record->{type_id}}}, $buy_record);
				#}
			}
		}

	foreach my $sell_order ( @sells_table ) {	# WORK Filter against purchased_table (sell_id)!
		if ( $sell_order->{price} <= $investment_maximum && $sell_order->{packaged_volume} <= $cargo_maximum ) {
			#if ( !( grep { $sell_order->{id} == $_->{sell_id} } @purchased_table ) ) {

				# Sells and general columns
				my %line_helper	= (
					sell_id			=> $sell_order->{id},
					character_id		=> $sell_order->{character_id},
					type_id			=> $sell_order->{type_id},
					route_security		=> $route_security,
					good			=> $sell_order->{good},
					packaged_volume		=> $sell_order->{packaged_volume},
					from_location		=> qq{$sell_order->{region} > $sell_order->{constellation} > $sell_order->{system} > $sell_order->{location}},
					from_region		=> $sell_order->{region},
					from_rid		=> $sell_order->{region_id},
					from_constellation	=> $sell_order->{constellation},
					from_cid		=> $sell_order->{constellation_id},
					from_system		=> $sell_order->{system},
					from_sid		=> $sell_order->{system_id},
					from_sys_security	=> $sell_order->{security_status},
					from_structure_station	=> $sell_order->{location},
					from_ssid		=> $sell_order->{location_id},
					sell_issued		=> $sell_order->{issued},
					from_ss_variety		=> $sell_order->{source_table},
					sell_price		=> $sell_order->{price},
					);

				my $max_by_invest			= floor($investment_maximum / $sell_order->{price});
				my $max_by_cargo			= floor($cargo_maximum / $sell_order->{packaged_volume});

				# Only work on buy orders of same type, buy price which is higher as sell price, but check percent, of increase before using it
				foreach my $buy_order ( @{$buys_table{$sell_order->{type_id}}} ) {
					if ( $buy_order->{price} > $sell_order->{price} && ($buy_order->{price} * (1 - $tax / 100)) > $sell_order->{price} ) {
						# purchased table is consolidated on build of %buys_table

						# Calculate smallest quantity
						$line_helper{quantity}		= ( $buy_order->{volume_remain} < $sell_order->{volume_remain} )	? $buy_order->{volume_remain}	: $sell_order->{volume_remain};
						$line_helper{quantity}		= ( $max_by_invest < $line_helper{quantity} )				? $max_by_invest		: $line_helper{quantity};
						$line_helper{quantity}		= ( $max_by_cargo < $line_helper{quantity} )				? $max_by_cargo			: $line_helper{quantity};

						&debug_out("main_table_perl_join(): quantities for sell order $sell_order->{id} and buy order $buy_order->{id}: invest: $max_by_invest, cargo: $max_by_cargo, buys remaining: $buy_order->{volume_remain}, sells remaining: $sell_order->{volume_remain}, used qantity: $line_helper{quantity}");

						if ( $line_helper{quantity} ) {

							# Check if profit is enough
							$line_helper{profit}			= ($buy_order->{price} * $line_helper{quantity} * (1 - $tax / 100)) - $sell_order->{price} * $line_helper{quantity};
							if ( $line_helper{profit} >= $profit_minimum ) {

								# Buys columns
								$line_helper{investment}		= $sell_order->{price} * $line_helper{quantity};
								$line_helper{revenue}			= $buy_order->{price} * $line_helper{quantity} * (1 - $tax / 100);
								$line_helper{needed_space}		= $sell_order->{packaged_volume} * $line_helper{quantity};
								$line_helper{profit_qm}			= ($buy_order->{price} * (1 - $tax / 100) - $sell_order->{price}) / $sell_order->{packaged_volume};
								$line_helper{buy_id}			= $buy_order->{id};
								$line_helper{buy_issued}		= $buy_order->{issued};
								$line_helper{to_location}		= qq{$buy_order->{region} > $buy_order->{constellation} > $buy_order->{system} > $buy_order->{location}};
								$line_helper{to_region}			= $buy_order->{region};
								$line_helper{to_rid}			= $buy_order->{region_id};
								$line_helper{to_constellation}		= $buy_order->{constellation};
								$line_helper{to_cid}			= $buy_order->{constellation_id};
								$line_helper{to_system}			= $buy_order->{system};
								$line_helper{to_sid}			= $buy_order->{system_id};
								$line_helper{to_sys_security}		= $buy_order->{security_status};
								$line_helper{to_structure_station}	= $buy_order->{location};
								$line_helper{to_ssid}			= $buy_order->{location_id};
								$line_helper{to_ss_variety}		= $buy_order->{source_table};
								$line_helper{buy_price}			= $buy_order->{price};

							if ( !( grep { qq{( $line_helper{from_sid} == origin AND $line_helper{to_sid} == destination )} eq $_ || qq{( $line_helper{to_sid} == origin AND $line_helper{from_sid} == destination )} eq $_ } @jumps_where_clause ) ) {	# WORK To slow?
								push(@jumps_where_clause, qq{( $line_helper{from_sid} == origin AND $line_helper{to_sid} == destination )});
								&debug_out(qq{Added "( $line_helper{from_sid} == origin AND $line_helper{to_sid} == destination )" to \@jumps_where_clause})
								}

							push(@done_hauls_table, { %line_helper });
							&debug_out("Haul $line_helper{sell_id} - $line_helper{buy_id} was added with an profit of " . &human_readable($line_helper{profit}) . " ISK");
							}
						}
					}
				}
			#}
		}
	}

	&priority_lock(1);
	&db_lock(1, "decontrol");	# Wait for exclusive access on next &access_DB()
	&db_lock(0);

	# Apply jumps to records
	@jumps_list	= &access_DB(qq{SELECT origin, destination, jumps_all AS "all", jumps_high AS "high", jumps_low AS "low" FROM routes_jumps WHERE } . join(qq{ OR }, @jumps_where_clause) . qq{ ;});
	foreach my $record ( @done_hauls_table ) {
		my @matched_routes	= grep { ( $_->{origin} == $record->{to_sid} && $_->{destination} == $record->{from_sid} ) || ( $_->{origin} == $record->{from_sid} && $_->{destination} == $record->{to_sid} ) } @jumps_list;

		if ( @matched_routes ) {
			$record->{jumps}			= $matched_routes[0]->{$record->{route_security}};
			if ( $record->{jumps} ) {	# Prevent division by zero
				$record->{profit_jump}		= $record->{profit} / $record->{jumps};
				$record->{profit_qm_jump}	= $record->{profit_qm} / $record->{jumps};
				}
			else {
				$record->{profit_jump}		= $record->{profit};
				$record->{profit_qm_jump}	= $record->{profit_qm};
				}
			}
		}

	return(grep { defined($_->{jumps}) } @done_hauls_table);
	}

sub downloader {
	my $privileged		= shift;	# boolean
	my $target		= shift;	# link (e.g. "/universe/regions/") 
	my $opts		= shift;	# { order_type => "all", order_type => "sell", order_type => "buy", }
	my $cmd			= "";

	my $ds_knot		= tie(my %downsub_carrier, 'IPC::Shareable', $transID);
	$ds_knot->shlock;
	my $character_id	= $downsub_carrier{CharacterID};
	$ds_knot->shunlock;

	# Build object with server
	&dl_lock(1);
	my $dlh			= REST::Client->new({host => $dlburl});
	&dl_lock(0);

	# Add header
	$dlh->addHeader(Accept	=> "application/json");
	if ( $privileged ) {

		&db_token(1);
		my $access_details		= [ &access_DB(
			"SELECT token_access\n" .
			"  FROM characters\n" .
			"  WHERE id == " . &quote_DB($character_id) . ";",
			) ];
		&db_token(0);

		if ( ! ref($access_details->[0]) ) {
			if ( $finite_counter++ >= 100 ) {
				return();
				}
			else {
				&debug_out("downloader(): WARNING: failed to gather access_details, restarting...");
				Time::HiRes::sleep(0.6);
				return(&downloader($privileged, $target, $opts));
				}
			}
	
		if ( scalar(@{$access_details}) > 1 ) {
			&debug_out(
				"downloader(): WARNING: Got more than one character",
				"downloader(): We will use the first one!",
				);
			}
		elsif ( scalar(@{$access_details}) == 0 ) {
			&debug_out("downloader(): FATAL ERROR: Got no character");
			}
		else {
			$access_details		= $access_details->[0];
			}

		$dlh->addHeader(Authorization => "Bearer $access_details->{token_access}",);
		&debug_out("downloader(): Using token \"$access_details->{token_access}\" for character " . $character_id);
		}

	# Error prevention
	$target			=~ s/\/*$/\//;		# a SINGLE slash is needed at the end
	if ( $opts && ref($opts) eq "HASH" && %{$opts} ) {
		my $opts_helper	= "";
		my $init	=  1;

		foreach my $key ( keys(%{$opts}) ) {
			if ( $init ) {
				$init		=    0;
				$opts_helper	.= "?";
				}
			else {
				$opts_helper	.= "&";
				}
			$opts_helper		.= "${key}=$opts->{$key}";
			}

		$opts		= $opts_helper;
		}
	else {
		$opts		= "";
		};
	&debug_out(qq{downloader(): reqested for target "${target}$opts"});

	# Execute
	#&dl_lock(1);		# WORK Maybe sleeps for Downloads can be omitted now
	$dlh->GET($target . $opts);
	#&dl_lock(0);

	&debug_out(qq{GET is done});

	# Collect data
	my $return_code	= $dlh->responseCode();
	my $jdata	= $dlh->responseContent();
	my $x_pages	= $dlh->responseHeader("x-pages");

	&debug_out("downloader(): got response code $return_code");

	# Error exceeded handling
	if ( $return_code >= 500 && $return_code < 600 ) {
		my $_infinite_blocker	= 3;
		sleep(10);

		do {
			&debug_out(qq{downloader(): $_infinite_blocker tries left});


			$dlh->GET($target . $opts);
			sleep(1);

			$return_code	= $dlh->responseCode();
			$jdata		= $dlh->responseContent();
			$x_pages	= $dlh->responseHeader("x-pages");
			
			} while ( $_infinite_blocker-- && $return_code >= 500 && $return_code < 600 );
		}

	if ( $return_code == 420 ) {
		sleep(60);

		$dlh->GET($target . $opts);

		$return_code	= $dlh->responseCode();
		$jdata		= $dlh->responseContent();
		$x_pages	= $dlh->responseHeader("x-pages");

		&debug_out("downloader(): Retry got response code $return_code");
		}

	# Return handling
	if ( $return_code == 200 ) {

		# If this is a multiple page document
		if ( defined($x_pages) && $x_pages > 1 ) {
			# Download all pages, first page came by default if no page was given
			my $inf_blocker	= 0;
			page:
			for ( my $page = 2 ; $page <= $x_pages ; $page++ ) {
				$dlh->GET($target . ( ( $opts ) ? "${opts}&" : "?" ) . "page=$page" );

				&debug_out("downloader(): got response code " . $dlh->responseCode());

				if ( $dlh->responseCode() == 200 ) {
					$inf_blocker	= 0;
					$jdata	.= $dlh->responseContent();
					}
				elsif ( $inf_blocker >= 5 ) {
					$inf_blocker	= 0;
					&debug_out("downloader(): Five tries for page $page on \"${target}$opts\" were missed; skipping this page");
					next(page);
					}
				else {
					$inf_blocker++;
					sleep(1);
					redo(page);
					}
				}
			$jdata	=~ s/\[\s*\]//g;	# Remove empty arrays
			$jdata	=~ s/\]\[/,/g;		# While appended arrays will be just placed together, so we must reset it to comma separated values on connection points
			}

		&debug_out("downloader(): Got data: $jdata");

		if ( !$jdata ) {
			return();
			}
		else {
			$jdata	= &test_json($jdata);
			if ( $jdata ) {
				$finite_counter	= 0;
				if ( ref($jdata) eq "ARRAY" ) {
					return(@{$jdata});
					}
				elsif ( ref($jdata) eq "HASH" ) {
					return(%{$jdata});
					}
				elsif ( ref($jdata) eq "SCALAR" ) {
					return(${$jdata});
					}
				else {
					return($jdata);
					}
				}
			else {
				if ( $finite_counter++ >= 6 ) {
					return();
					}
				else {
					&debug_out("downloader(): WARNING: failed to download $target, restarting...");
					sleep(2);
					return(&downloader($privileged, $target));
					}
				}
			}
		}
	else {
		&debug_out("downloader(): Download for $target exited with $return_code");
		Time::HiRes::sleep(6.01);	# The 10th run (10 requests/min x 10 agents = 100 requests/min) happens after 60.1 seconds. The Errors are reset to 99 after at least 60 seconds
		return("fail", $return_code);
		}
	}

sub wait_children {
	my $left	= shift;
	my $childs	= shift;
	my $wait_time	= shift;	# seconds
	my $waiting	= 0;
	my $lock_test	= 0;
	CORE::state @old_c	= ();

	if ( $left < 1 ) {
		$left	= 1;
		}

	if ( defined($wait_time) && $wait_time && $wait_time =~ m/^[0-9]+(?:\.[0-9]+)?$/ ) {
		$wait_time	= ceil($wait_time / 0.25);
		}
	else {
		$wait_time	= 10 ; #ceil(2.5 / 0.25); # 2.5 sec
		}

	while ( scalar(@{$childs}) >= $left ) {
		$waiting	= 1;
		&debug_out("wait_children(): Waiting for @{$childs}");
		Time::HiRes::sleep(0.25);
		@{$childs}	= grep { kill(0 => $_) } @{$childs};


		# Release locks if no agent is gone after $wait_time seconds
		if ( $lock_test > $wait_time ) {
			my $knot	= tie(my %tester, 'IPC::Shareable', $transID);
			$lock_test	= 0;

			# Check lock states and if both are == 0 -> increase check time!
			$knot->shlock;
			$tester{rqn}++;
			if ( $tester{db_locked} == 0 && $tester{dl_locked} == 0 ) {
				$knot->shunlock;
				$wait_time	= ceil($wait_time * 1.2);
				&debug_out("wait_children(): Counter ended - nothing to unlock - setting counter to $wait_time");
				}
			else {
				$knot->shunlock;
				&debug_out("wait_children(): releasing locks!");
				&dl_lock(0);
				&db_lock(0);
				}
			}
		# If anything has changed
		elsif ( grep { my $known = $_; not grep { $known == $_ } @childs } @old_c || grep { my $known = $_; not grep { $known == $_ } @old_c } @childs ) {
			&debug_out("wait_children(): updating list");
			$lock_test	= 0;
			@old_c		= ( @{$childs} );
			}
		else {
			$lock_test++;
			&debug_out("wait_children(): new lock counter: $lock_test");
			}
		}

	return($waiting);
	}

sub infinite_lock_protector {
	my $childs	= shift;
	my $wait_time	= shift;	# seconds
	my $request_time		= time;
	CORE::state $old_request_time	= time;
	CORE::state @old_c		= ();

	if ( ! @{$childs} ) {
		$old_request_time	= $request_time;
		return("0E0");
		}

	if ( defined($wait_time) && $wait_time && $wait_time =~ m/^[0-9]+(?:\.[0-9]+)?$/ ) {
		$wait_time	= ceil($wait_time / 0.25);
		}
	else {
		$wait_time	= 10 ; #ceil(2.5 / 0.25); # 2.5 sec
		}

	# Release locks if no agent is gone after $wait_time seconds
	if ( ( $request_time - $old_request_time ) > ( $wait_time * 0.25 ) ) {
		my $knot	= tie(my %tester, 'IPC::Shareable', $transID);

		# Check lock states and if both are == 0 -> increase check time!
		$knot->shlock;
		$tester{rqn}++;
		if ( $tester{db_locked} == 0 && $tester{dl_locked} == 0 ) {
			$knot->shunlock;
			&debug_out("infinite_lock_protector(): Counter ended - nothing to unlock");
			}
		else {
			$knot->shunlock;
			&debug_out("infinite_lock_protector(): releasing locks!");
			&dl_lock(0);
			&db_lock(0);
			}
		}
	# If anything has changed
	elsif ( grep { my $known = $_; not grep { $known == $_ } @childs } @old_c || grep { my $known = $_; not grep { $known == $_ } @old_c } @childs ) {
		&debug_out("infinite_lock_protector(): updating list");
		$old_request_time	= $request_time;
		@old_c			= ( @{$childs} );
		}
	else {
		&debug_out("infinite_lock_protector(): new lock counter: ". ( $request_time - $old_request_time ));
		}

	return(scalar(@{$childs}));
	}

sub test_json {
	my $jstring	= shift;

	# JSON module handles false as 1 as well as true (1) -> wrong data
	# This is a manual workaround
	#$jstring	=~ s/\":true/":"true"/ig;
	#$jstring	=~ s/\":false/":"false"/ig;

	#&debug_out(qq{test_json(): requested to decrypt "$jstring"});
	eval{ $jstring = decode_json($jstring) };
	my $jreturn	= $@;

	# Fail with error message
	if ( $jreturn ) {
		&debug_out(
			"test_json(): got $jstring",
			"test_json(): returned with $jreturn from JSON module",
			);
		return(0);
		}
	# Success
	else {
		&debug_out(qq{test_json(): successfully decoded JSON data});
		return($jstring);
		}
	}

sub make_unique {
	my @input = @_;
	my %seen;
	&debug_out("make_unique(): requested for " . &human_readable(scalar(@input)) . " elements");
	@input = grep { ! $seen{$_} ++ } @input; # makes the array-entries unique
	&debug_out("make_unique(): " . &human_readable(scalar(@input)) . " elements left");
	return(@input);
	}

sub gen_random {
	my $count	= shift;
	my @hex		= ( 0..9, "a".."f" );
	my $string	= "";

	if ( $count !~ m/^[0-9]+$/ ) {
		die("Wrong data!\n");
		}

	while ( $count-- ) {
		$string	.= $hex[POSIX::lround(rand(15))];
		}
	$string		= join("", shuffle( split('', $string)));
	return($string);
	}

sub debug_out {
	my @text	= @_;

	if ( ! $debug_mode ) {
		return(0);
		} # Faster than >else<

	if ( $debug_mode ) {
		my $unit	= ( $$ != $ppid ) ? "C" : "P";
		my @out		= ();
		foreach my $line ( @text ) {
			push(@out, split(/\n/, $line));
			}

		foreach	my $real_line ( @out ) {
			open(my $fh, ">>:encoding(UTF-8)", $debug_file);
				print $fh localtime(time) . " (${unit}$$)  $real_line\n";
				close($fh);
			}
		return(1);
		}
	else {
		return(0);
		}

	}

sub human_readable {                                                   
	my $num = shift;                                         

	# If it is floating with three or more places
	if ( $num =~ m/^[0-9]+\.[0-9]{3,}$/ ) {
		$num		= sprintf("%.2f", $num);
		}

	# If it is a integer or floating
	if ( $num =~ m/^([0-9]+)(\.[0-9]+)?$/ ) {
		my $front	= $1;
		my $end		= ( defined($2) ) ? $2 : "";
		$num		= reverse(join(" ", unpack("(A3)*", reverse($front)))) . $end;
		}
	# Date for issued: 2020-08-15T07:14:20Z
	elsif ( $num =~ m/^([0-9]{4})-([0-9]{2})-([0-9]{2}).([0-9]{2}):([0-9]{2}):([0-9]{2}).$/ ) {
		my %time	= (
			year	=> $1,
			month	=> $2,
			day	=> $3,
			hour	=> $4,
			minute	=> $5,
			second	=> $6,
			);

		$num		= sprintf("%04d-%02d-%02d %02d:%02d", $time{year}, $time{month}, $time{day}, $time{hour}, $time{minute});
		}

	return($num);
	}


package pending;

sub new {
	my $class	= shift;
	my $self	= {
		char		=> shift,
		direction	=> "-",
		position	=>  1 ,
		};

	bless($self, $class);

	return($self);
	}

sub motion {
	my $self	= shift;

	if ( $self->{position} == 1 && $self->{direction} eq "-" ) {
		$self->{direction}	= "+";
		$self->{position}	=  0 ;
		return("$self->{char}  ");
		}
	elsif ( $self->{position} == 1 && $self->{direction} eq "+" ) {
		$self->{direction}	= "-";
		$self->{position}	=  2 ;
		return("  $self->{char}");
		}
	else {
		$self->{position}	=  1 ;
		return(" $self->{char} ");
		}
	}

package main;

__DATA__

-- Types of objects and goods
CREATE TABLE types (
  id INTEGER NOT NULL,
  name TEXT NOT NULL,
  volume REAL NOT NULL,
  packaged_volume REAL NOT NULL,
  capacity REAL,
  mass REAL,
  PRIMARY KEY (id)
  );

-- Information about character, including login data
CREATE TABLE characters (
  id INTEGER NOT NULL,
  name TEXT NOT NULL,
  cargo_maximum REAL NOT NULL DEFAULT 500.0,
  investment_maximum REAL NOT NULL DEFAULT 10000.00,
  tax REAL NOT NULL DEFAULT 5.0,	                         -- 5.0 %
  profit_minimum REAL NOT NULL DEFAULT 1000.00,
  owner_hash TEXT NOT NULL,
  app_client_id TEXT NOT NULL,
  app_secret_key TEXT NOT NULL,
  token_refresh TEXT NOT NULL,
  token_access TEXT NOT NULL,
  token_acc_duration INTEGER NOT NULL,
  token_acc_time INTEGER NOT NULL,
  security_maximum REAL NOT NULL DEFAULT 1.0,
  security_minimum REAL NOT NULL DEFAULT 0.5,
  last_update_all INTEGER NOT NULL DEFAULT 0,
  done_regions BOOLEAN NOT NULL DEFAULT 1,
  done_constellations BOOLEAN NOT NULL DEFAULT 1,
  done_systems BOOLEAN NOT NULL DEFAULT 1,
  done_stargates BOOLEAN NOT NULL DEFAULT 1,
  done_stations BOOLEAN NOT NULL DEFAULT 1,
  done_structures BOOLEAN NOT NULL DEFAULT 1,
  done_types BOOLEAN NOT NULL DEFAULT 1,
  done_jumps BOOLEAN NOT NULL DEFAULT 1,
  last_update_markets INTEGER NOT NULL DEFAULT 0,
  in_use INTEGER NOT NULL DEFAULT 0,                             -- program is used by this user by PID saved in this field
  update_running INTEGER NOT NULL DEFAULT 0,                     -- restart updates if interrupted
  geometry TEXT NOT NULL DEFAULT 0,                              -- remember last window position and size
  sort_method TEXT NOT NULL CHECK(sort_method IN ( 'profit' , 'qm' , 'jumps' , 'jumps_qm' )) DEFAULT 'profit',                    -- profit, qm, jumps, jumps_qm
  route_security TEXT NOT NULL CHECK(route_security IN ( 'high' , 'low' , 'all' )) DEFAULT 'high',                   -- high, low, all
  language TEXT NOT NULL DEFAULT 'en-us',
  version TEXT NOT NULL DEFAULT '<[APP_VERSION]>', -- for updating the database, if needed in any script update function
  PRIMARY KEY (id)
  );

-- Regions
CREATE TABLE locations_regions (
  id INTEGER NOT NULL,
  name TEXT NOT NULL,
  PRIMARY KEY (id)
  );

-- Constellations
CREATE TABLE locations_constellations (
  id INTEGER NOT NULL,
  name TEXT NOT NULL,
  region_id INTEGER NOT NULL,
  PRIMARY KEY (id),
  FOREIGN KEY (region_id) REFERENCES locations_regions(id) ON UPDATE CASCADE ON DELETE CASCADE
  );

-- Systems
CREATE TABLE locations_systems (
  id INTEGER NOT NULL,
  name TEXT NOT NULL,
  security_status REAL NOT NULL,
  security_class TEXT,
  constellation_id INTEGER NOT NULL,
  PRIMARY KEY (id),
  FOREIGN KEY (constellation_id) REFERENCES locations_constellations(id) ON UPDATE CASCADE ON DELETE CASCADE
  );

-- System's neighbour systems
CREATE TABLE locations_stargates ( -- connected systems (allocation table, n,m)
  id INTEGER NOT NULL,
  system_id INTEGER NOT NULL,
  neighbour_id INTEGER NOT NULL,
  UNIQUE(system_id, neighbour_id),
  PRIMARY KEY (id),
  FOREIGN KEY (system_id) REFERENCES locations_systems(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (neighbour_id) REFERENCES locations_systems(id) ON UPDATE CASCADE ON DELETE CASCADE
  );

-- Stations
CREATE TABLE locations_stations (
  id INTEGER NOT NULL,
  name TEXT NOT NULL,
  system_id INTEGER NOT NULL,
  PRIMARY KEY (id),
  FOREIGN KEY (system_id) REFERENCES locations_systems(id) ON UPDATE CASCADE ON DELETE CASCADE
  );

-- Structures (similar to stations, but user built)
CREATE TABLE locations_structures (
  id INTEGER NOT NULL,
  name TEXT NOT NULL,
  solar_system_id INTEGER NOT NULL,
  character_id INTEGER NOT NULL,
  PRIMARY KEY (id, character_id),
  FOREIGN KEY (solar_system_id) REFERENCES locations_systems(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (character_id) REFERENCES characters(id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- List to remember which structures deny access
CREATE TABLE denied_structures (
  structure_id INTEGER NOT NULL,
  character_id INTEGER NOT NULL,
  PRIMARY KEY (structure_id, character_id),
  FOREIGN KEY (character_id) REFERENCES characters(id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- List to remember which structures deny access to MARKETS
CREATE TABLE denied_structures_markets (
  structure_id INTEGER NOT NULL,
  character_id INTEGER NOT NULL,
  detected INTEGER NOT NULL,
  PRIMARY KEY (structure_id, character_id),
  FOREIGN KEY (character_id) REFERENCES characters(id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- Orders of stations
CREATE TABLE orders_stations (
  id INTEGER NOT NULL,
  volume_total INTEGER NOT NULL CHECK(volume_total > 0),
  volume_remain INTEGER NOT NULL CHECK(volume_remain > 0),
  min_volume INTEGER NOT NULL,
  price REAL NOT NULL,
  duration INTEGER NOT NULL,
  issued TEXT NOT NULL,
  range TEXT NOT NULL,
  is_buy_order BOOLEAN NOT NULL,
  type_id INTEGER NOT NULL,
  location_id INTEGER NOT NULL,
  PRIMARY KEY (id),
  FOREIGN KEY (type_id) REFERENCES types(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (location_id) REFERENCES locations_stations(id) ON UPDATE CASCADE ON DELETE CASCADE
  );

-- Orders of structures
CREATE TABLE orders_structures (
  id INTEGER NOT NULL,
  volume_total INTEGER NOT NULL CHECK(volume_total > 0),
  volume_remain INTEGER NOT NULL CHECK(volume_remain > 0),
  min_volume INTEGER NOT NULL,
  price REAL NOT NULL,
  duration INTEGER NOT NULL,
  issued TEXT NOT NULL,
  range TEXT NOT NULL,
  is_buy_order BOOLEAN NOT NULL,
  type_id INTEGER NOT NULL,
  location_id INTEGER NOT NULL,
  character_id INTEGER NOT NULL,
  PRIMARY KEY (id, character_id),
  FOREIGN KEY (type_id) REFERENCES types(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (location_id, character_id) REFERENCES locations_structures(id, character_id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (character_id) REFERENCES characters(id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- Jumps for routes
CREATE TABLE routes_jumps (
  origin INTEGER NOT NULL,
  destination INTEGER NOT NULL,
  jumps_all INTEGER NOT NULL,
  jumps_high INTEGER NOT NULL DEFAULT -1,
  jumps_low INTEGER NOT NULL DEFAULT -1,
  PRIMARY KEY (origin, destination),
  FOREIGN KEY (origin) REFERENCES locations_systems(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (destination) REFERENCES locations_systems(id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- Routes which are impassable
CREATE TABLE routes_impassable (
  origin INTEGER NOT NULL,
  destination INTEGER NOT NULL,
  PRIMARY KEY (origin, destination),
  FOREIGN KEY (origin) REFERENCES locations_systems(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (destination) REFERENCES locations_systems(id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- List for ids of structures for afterprocessing
CREATE VIEW missing_structures AS
  SELECT DISTINCT os.location_id, os.character_id
    FROM orders_structures os
      WHERE os.location_id NOT IN (
        SELECT DISTINCT lst.id
          FROM locations_structures lst
            WHERE lst.character_id == os.character_id
            );

CREATE VIEW locations_neighbours AS
  SELECT lg.system_id, lg.neighbour_id, ls.security_status sys_sec, ls.security_class sys_class, "ln".security_status neig_sec, "ln".security_class neig_class
    FROM locations_stargates lg
    INNER JOIN locations_systems ls
      ON ls.id == lg.system_id
    INNER JOIN locations_systems "ln"
      ON "ln".id == lg.neighbour_id;

CREATE VIEW locations_systems_with_stargates AS
  SELECT system_id id
    FROM locations_stargates
UNION
  SELECT neighbour_id
    FROM locations_stargates;

-- Routs which don't have jumps calculated and saved in routes_jumps
CREATE VIEW missing_jumps AS
  SELECT s1.id origin, s2.id destination
    FROM locations_systems s1
    INNER JOIN locations_systems s2
      ON s1.id != s2.id
    LEFT JOIN routes_jumps rj
      ON ( s1.id == rj.origin AND s2.id == rj.destination )
      OR ( s2.id == rj.origin AND s1.id == rj.destination )
    LEFT JOIN routes_impassable ri
      ON ( s1.id == ri.origin AND s2.id == ri.destination )
      OR ( s2.id == ri.origin AND s1.id == ri.destination )
    WHERE rj.jumps_all IS NULL
    AND ri.origin IS NULL
    AND s1.id <= s2.id
UNION
  SELECT s2.id origin, s1.id destination
    FROM locations_systems s1
    INNER JOIN locations_systems s2
      ON s1.id != s2.id
    LEFT JOIN routes_jumps rj
      ON ( s1.id == rj.origin AND s2.id == rj.destination )
      OR ( s2.id == rj.origin AND s1.id == rj.destination )
    LEFT JOIN routes_impassable ri
      ON ( s1.id == ri.origin AND s2.id == ri.destination )
      OR ( s2.id == ri.origin AND s1.id == ri.destination )
    WHERE rj.jumps_all IS NULL
    AND ri.origin IS NULL
    AND s1.id > s2.id;

--CREATE VIEW missing_impassable_routes AS
CREATE VIEW missing_impassable_routes AS
  SELECT mj.*
    FROM missing_jumps mj
    LEFT JOIN routes_impassable ri
      ON ( mj.origin == ri.origin AND mj.destination == ri.destination )
      OR ( mj.destination == ri.origin AND mj.origin == ri.destination )
    WHERE ( mj.origin NOT IN ( SELECT system_id FROM locations_stargates )
      OR mj.destination NOT IN ( SELECT system_id FROM locations_stargates ) )
    AND ri.origin IS NULL;

--CREATE VIEW missing_impassable_routes AS
CREATE VIEW missing_impassable_routes_wrong AS
  SELECT mj.*
    FROM missing_jumps mj
    LEFT JOIN locations_stargates ls
      ON mj.origin == ls.system_id
      OR mj.destination == ls.neighbour_id
    LEFT JOIN routes_impassable ri
      ON ( mj.origin == ri.origin AND mj.destination == ri.destination )
      OR ( mj.destination == ri.origin AND mj.origin == ri.destination )
    WHERE ls.system_id IS NULL
    AND ri.origin IS NULL;

-- Orders bought or going to be so
CREATE TABLE purchased (
  sell_id INTEGER NOT NULL,
  buy_id INTEGER NOT NULL,
  character_id INTEGER NOT NULL,
  type_id INTEGER NOT NULL,
  investment REAL NOT NULL,
  profit REAL NOT NULL,
  profit_qm REAL NOT NULL,
  profit_jump REAL NOT NULL,
  profit_qm_jump REAL NOT NULL,
  revenue REAL NOT NULL,
  good TEXT NOT NULL,
  from_location TEXT NOT NULL,
  sell_price REAL NOT NULL,
  quantity INTEGER NOT NULL,
  to_location TEXT NOT NULL,
  buy_price REAL NOT NULL,
  needed_space REAL NOT NULL,
  sell_issued TEXT NOT NULL,
  buy_issued TEXT NOT NULL,
  jumps INTEGER NOT NULL,
  PRIMARY KEY (sell_id, buy_id, character_id, type_id),
  FOREIGN KEY (character_id) REFERENCES characters(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (type_id) REFERENCES types(id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- Purchase summery
CREATE VIEW purchase_amounts AS
  SELECT
      COALESCE(SUM(p.investment), 0) AS sum_investment,
      COALESCE(SUM(p.profit), 0) AS sum_profit,
      COALESCE(SUM(p.revenue), 0) AS sum_revenue,
      COALESCE(SUM(p.needed_space), 0) AS sum_needed_space,
      COALESCE(AVG(p.profit_qm), 0) AS avg_profit_qm,
      p.character_id AS character_id
    FROM purchased p
  GROUP BY character_id;

-- Types
CREATE TABLE ignores_types (
  type_id INTEGER NOT NULL,
  character_id INTEGER NOT NULL,
  PRIMARY KEY (type_id, character_id),
  FOREIGN KEY (character_id) REFERENCES characters(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (type_id) REFERENCES types(id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- Regions
CREATE TABLE ignores_regions (
  region_id INTEGER NOT NULL,
  character_id INTEGER NOT NULL,
  PRIMARY KEY (region_id, character_id),
  FOREIGN KEY (character_id) REFERENCES characters(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (region_id) REFERENCES locations_regions(id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- Constellations
CREATE TABLE ignores_constellations (
  constellation_id INTEGER NOT NULL,
  character_id INTEGER NOT NULL,
  PRIMARY KEY (constellation_id, character_id),
  FOREIGN KEY (character_id) REFERENCES characters(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (constellation_id) REFERENCES locations_constellations(id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- Systems
CREATE TABLE ignores_systems (
  system_id INTEGER NOT NULL,
  character_id INTEGER NOT NULL,
  PRIMARY KEY (system_id, character_id),
  FOREIGN KEY (character_id) REFERENCES characters(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (system_id) REFERENCES locations_systems(id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- Stations
CREATE TABLE ignores_stations (
  station_id INTEGER NOT NULL,	-- range from 60_000_000 to 64_000_000
  character_id INTEGER NOT NULL,
  PRIMARY KEY (station_id, character_id),
  FOREIGN KEY (character_id) REFERENCES characters(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (station_id) REFERENCES locations_stations(id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- Structures
CREATE TABLE ignores_structures (
  structure_id INTEGER NOT NULL,
  character_id INTEGER NOT NULL,
  PRIMARY KEY (structure_id, character_id),
  FOREIGN KEY (character_id) REFERENCES characters(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (structure_id, character_id) REFERENCES locations_structures(id, character_id) ON UPDATE CASCADE ON DELETE CASCADE
  ) WITHOUT ROWID;

-- Full list of all ignored types/objects for listing
CREATE VIEW ignored_types_overview AS
  SELECT it.type_id id, t.name, t.packaged_volume, it.character_id
    FROM types t
    INNER JOIN ignores_types it
      ON it.type_id = t.id
ORDER BY t.name;

-- Full list of all ignored locations for ignores listing
CREATE VIEW ignores_overview AS
  SELECT lr.id id, lr.name name, ir.character_id, 'Region' list
    FROM ignores_regions ir
    INNER JOIN locations_regions lr
      ON ir.region_id = lr.id
UNION ALL
  SELECT lc.id id, lc.name name, ic.character_id, 'Constellation' list
    FROM ignores_constellations ic
    INNER JOIN locations_constellations lc
      ON ic.constellation_id = lc.id
UNION ALL
  SELECT ls.id id, ls.name name, igs.character_id, 'System' list
    FROM ignores_systems igs
    INNER JOIN locations_systems ls
      ON igs.system_id = ls.id
UNION ALL
  SELECT lst.id id, lst.name name, ist.character_id, 'Station' list
    FROM ignores_stations ist
    INNER JOIN locations_stations lst
      ON ist.station_id = lst.id
UNION ALL
  SELECT lsr.id id, lsr.name name, isr.character_id, 'Structure' list
    FROM ignores_structures isr
    INNER JOIN locations_structures lsr
      ON isr.structure_id = lsr.id
ORDER BY id, name;	-- id is increasing same way as the unions are build

-- Locations index, find all depending elements together in one view
CREATE VIEW locations_indices AS
  SELECT sta.id ss_id, sta.name structure_station, sys.id sys_id, sys.name system, const.id const_id, const.name constellation, r.id region_id, r.name region, 'station' ss_variety, ROUND(sys.security_status, 1) AS sys_sec
    FROM locations_regions r
    INNER JOIN locations_constellations const
      ON const.region_id == r.id
    INNER JOIN locations_systems sys
      ON sys.constellation_id == const.id
    INNER JOIN locations_stations sta
      ON sta.system_id == sys.id
UNION
  SELECT str.id ss_id, str.name structure_station, sys.id sys_id, sys.name system, const.id const_id, const.name constellation, r.id region_id, r.name region, 'structure' ss_variety, ROUND(sys.security_status, 1) AS sys_sec
    FROM locations_regions r
    INNER JOIN locations_constellations const
      ON const.region_id == r.id
    INNER JOIN locations_systems sys
      ON sys.constellation_id == const.id
    INNER JOIN locations_structures str
      ON str.solar_system_id == sys.id;
--ORDER BY region, constellation, system, structure_station  -- done in perl, because better case handling

-- Index for dropdown of types
CREATE VIEW market_types AS
  SELECT t.id, t.name
    FROM orders_structures os
    INNER JOIN types t
      ON os.type_id == t.id
UNION
  SELECT t.id, t.name
    FROM orders_stations os
    INNER JOIN types t
      ON os.type_id == t.id;

-- All ignored locations as station id list
CREATE VIEW all_ignores AS
  SELECT idx.ss_id location_id, c.id character_id
    FROM locations_indices idx
    INNER JOIN characters c
    INNER JOIN ignores_regions ir
      ON idx.region_id == ir.region_id
      AND c.id == ir.character_id
UNION
  SELECT idx.ss_id location_id, c.id character_id
    FROM locations_indices idx
    INNER JOIN characters c
    INNER JOIN ignores_constellations ic
      ON idx.const_id == ic.constellation_id
      AND c.id == ic.character_id
UNION
  SELECT idx.ss_id location_id, c.id character_id
    FROM locations_indices idx
    INNER JOIN characters c
    INNER JOIN ignores_systems iy
      ON idx.sys_id == iy.system_id
      AND c.id == iy.character_id
UNION
  SELECT idx.ss_id location_id, c.id character_id
    FROM locations_indices idx
    INNER JOIN characters c
    INNER JOIN ignores_stations isa
      ON idx.ss_id == isa.station_id
      AND c.id == isa.character_id
UNION
  SELECT idx.ss_id location_id, c.id character_id
    FROM locations_indices idx
    INNER JOIN characters c
    INNER JOIN ignores_structures isr
      ON idx.ss_id == isr.structure_id
      AND c.id == isr.character_id;

-- Calculate what's left after purchases
CREATE VIEW leftovers AS
  SELECT c.id character_id, (c.investment_maximum - COALESCE(spend.money, 0)) money, (c.cargo_maximum - COALESCE(spend.cargo, 0)) cargo
  FROM characters c
   LEFT JOIN (
    SELECT
      character_id,
      COALESCE(SUM(p.sell_price * p.quantity), 0) money,
      COALESCE(SUM((SELECT t.packaged_volume FROM types t WHERE p.type_id == t.id) * p.quantity), 0) cargo
      FROM purchased p
      GROUP BY character_id
    ) spend
    ON c.id == spend.character_id;

CREATE VIEW quantities_helper_sells AS
  SELECT os.id, os.volume_total, os.volume_remain, os.price, os.duration, os.issued, os.range,
   os.character_id,
   os.type_id,
   os.location_id,
   'structure' source_table
   FROM orders_structures os
   WHERE is_buy_order == 0
UNION ALL
  SELECT os.id, os.volume_total, os.volume_remain, os.price, os.duration, os.issued, os.range,
   c.id,
   os.type_id,
   os.location_id,
   'station' source_table
   FROM orders_stations os
   INNER JOIN characters c
   WHERE is_buy_order == 0 ;

CREATE VIEW quantities_helper_buys AS
  SELECT os.id, os.volume_total, os.volume_remain, os.price, os.duration, os.issued, os.range,
   os.character_id,
   os.type_id,
   os.location_id,
   'structure' source_table
   FROM orders_structures os
   WHERE is_buy_order == 1
UNION ALL
  SELECT os.id, os.volume_total, os.volume_remain, os.price, os.duration, os.issued, os.range,
   c.id,
   os.type_id,
   os.location_id,
   'station' source_table
   FROM orders_stations os
   INNER JOIN characters c
   WHERE is_buy_order == 1 ;

-- Sell orders
CREATE VIEW orders_sells AS
  SELECT os.id, os.volume_total, os.volume_remain, os.price, os.duration, os.issued, os.range,
   c.id character_id,
   t.id type_id, t.name good, t.packaged_volume,
   li.ss_id location_id, structure_station location,
   li.sys_id system_id, li.system system, ROUND(li.sys_sec, 1) AS security_status,
   li.const_id constellation_id, li.constellation constellation,
   li.region_id region_id, li.region region,
   li.ss_variety source_table
    FROM quantities_helper_sells os
    INNER JOIN characters c
      ON os.character_id == c.id
    INNER JOIN locations_indices li
      ON li.sys_sec BETWEEN c.security_minimum and c.security_maximum
      AND li.ss_id == os.location_id
    INNER JOIN types t
      ON os.type_id == t.id
    LEFT JOIN all_ignores ai
      ON ai.character_id == os.character_id
      AND ai.location_id == os.location_id
    LEFT JOIN ignores_types it
      ON it.character_id == os.character_id
      AND it.type_id == os.type_id
  WHERE ai.location_id IS NULL
    AND it.type_id IS NULL
ORDER BY os.price, os.volume_remain DESC ;

-- Buys orders
CREATE VIEW orders_buys AS
  SELECT ob.id, ob.volume_total, ob.volume_remain, ob.price, ob.duration, ob.issued, ob.range,
   c.id character_id,
   t.id type_id, t.name good, t.packaged_volume,
   li.ss_id location_id, structure_station location,
   li.sys_id system_id, li.system system, ROUND(li.sys_sec, 1) AS security_status,
   li.const_id constellation_id, li.constellation constellation,
   li.region_id region_id, li.region region,
   li.ss_variety source_table
    FROM quantities_helper_buys ob
    INNER JOIN characters c
      ON ob.character_id == c.id
    INNER JOIN locations_indices li
      ON li.sys_sec BETWEEN c.security_minimum and c.security_maximum
      AND li.ss_id == ob.location_id
    INNER JOIN types t
      ON ob.type_id == t.id
    LEFT JOIN all_ignores ai
      ON ai.character_id == ob.character_id
      AND ai.location_id == ob.location_id
    LEFT JOIN ignores_types it
      ON it.character_id == ob.character_id
      AND it.type_id == ob.type_id
  WHERE ai.location_id IS NULL
    AND it.type_id IS NULL
ORDER BY ob.price DESC, ob.volume_remain DESC;

-- Get smallest quantity for every transfer
CREATE VIEW quantities AS
  SELECT c.id character_id,
    t.id type_id,
    os.id sell_id,
    ob.id buy_id,
    os.location_id sell_location,
    ob.location_id buy_location,
    CAST(MIN( os.volume_remain, ob.volume_remain, ROUND(l.money / os.price - 0.5), ROUND(l.cargo / t.packaged_volume - 0.5) ) AS INT) quantity
    FROM characters c
    INNER JOIN types AS "t"
    INNER JOIN quantities_helper_buys ob
      ON ob.character_id == c.id
      AND ob.type_id == t.id
    INNER JOIN quantities_helper_sells os
      ON os.character_id == c.id
      AND os.type_id == t.id
      AND ob.price > os.price
    INNER JOIN leftovers l
      ON l.character_id == c.id
  WHERE quantity > 0
    AND (((ob.price * (1 - c.tax / 100)) - os.price) * quantity) > c.profit_minimum;

CREATE VIEW hauls_routes_helper AS
  SELECT DISTINCT
    rj.origin,
    rj.destination,
    c.id character_id,
    CASE
      WHEN c.route_security == 'high' THEN rj.jumps_high
      WHEN c.route_security == 'low' THEN rj.jumps_low
      ELSE rj.jumps_all
    END jumps
    FROM characters c
    INNER JOIN (
      SELECT DISTINCT
        sli.sys_id sell_sys,
        bli.sys_id buy_sys,
        q.character_id
        FROM quantities q
        INNER JOIN locations_indices bli
          ON q.buy_location == bli.ss_id
        INNER JOIN locations_indices sli
          ON q.sell_location == sli.ss_id
        ) AS tq
      ON tq.character_id == c.id
    INNER JOIN routes_jumps rj
      ON tq.sell_sys == rj.origin
      AND tq.buy_sys == rj. destination ;

CREATE VIEW hauls AS
  SELECT
    os.id AS sell_id,                                              -- identifier
    ob.id AS buy_id,                                               -- identifier
    c.id AS character_id,                                          -- identifier
    os.type_id AS type_id,                                         -- identifier
    c.route_security AS route_security,                            -- high, low or all
    ( os.price * CAST(MIN( os.volume_remain, ob.volume_remain, ROUND(lo.money / os.price - 0.5), ROUND(lo.cargo / os.packaged_volume - 0.5) ) AS INT) ) AS investment,                       -- purchase price total
    ( ob.price * CAST(MIN( os.volume_remain, ob.volume_remain, ROUND(lo.money / os.price - 0.5), ROUND(lo.cargo / os.packaged_volume - 0.5) ) AS INT) * ( 1 - c.tax / 100 ) ) AS revenue,    -- Retail price without investment
    os.good AS good,                                                -- object name
    ( os.packaged_volume * CAST(MIN( os.volume_remain, ob.volume_remain, ROUND(lo.money / os.price - 0.5), ROUND(lo.cargo / os.packaged_volume - 0.5) ) AS INT) ) AS needed_space,            -- summed cargo
    os.packaged_volume,
    ( ( ob.price * CAST(MIN( os.volume_remain, ob.volume_remain, ROUND(lo.money / os.price - 0.5), ROUND(lo.cargo / os.packaged_volume - 0.5) ) AS INT) * ( 1 - c.tax / 100 ) ) - os.price * CAST(MIN( os.volume_remain, ob.volume_remain, ROUND(lo.money / os.price - 0.5), ROUND(lo.cargo / os.packaged_volume - 0.5) ) AS INT) ) AS profit,
    ( ( ( ob.price * ( 1 - c.tax / 100 ) ) - os.price ) / os.packaged_volume ) AS profit_qm,
    ( ( ( ob.price * CAST(MIN( os.volume_remain, ob.volume_remain, ROUND(lo.money / os.price - 0.5), ROUND(lo.cargo / os.packaged_volume - 0.5) ) AS INT) * ( 1 - c.tax / 100 ) ) - os.price * CAST(MIN( os.volume_remain, ob.volume_remain, ROUND(lo.money / os.price - 0.5), ROUND(lo.cargo / os.packaged_volume - 0.5) ) AS INT) ) / rj.jumps ) AS profit_jump,
    ( ( ( ( ob.price * ( 1 - c.tax / 100 ) ) - os.price ) / os.packaged_volume ) / rj.jumps ) AS profit_qm_jump,
    os.region || ' > ' || os.constellation || ' > ' || os.system || ' > ' || os.location AS from_location,         -- sell-location-region/constellation/system
    os.region AS from_region,
    os.region_id AS from_rid,
    os.constellation AS from_constellation,
    os.constellation_id AS from_cid,
    os.system AS from_system,
    os.system_id AS from_sid,
    os.security_status AS from_sys_security,
    os.location AS from_structure_station,
    os.location_id AS from_ssid,
    os.issued AS sell_issued,
    ob.issued AS buy_issued,
    os.source_table AS from_ss_variety,
    os.price AS sell_price,                                        -- sell price for single object
    CAST(MIN( os.volume_remain, ob.volume_remain, ROUND(lo.money / os.price - 0.5), ROUND(lo.cargo / os.packaged_volume - 0.5) ) AS INT) AS quantity,                                        -- quantity to buy
    ob.region || ' > ' || ob.constellation || ' > ' || ob.system || ' > ' || ob.location AS to_location,           -- buy-location-region/constellation/system
    ob.region AS to_region,
    ob.region_id AS to_rid,
    ob.constellation AS to_constellation,
    ob.constellation_id AS to_cid,
    ob.system AS to_system,
    ob.system_id AS to_sid,
    ob.security_status AS to_sys_security,
    ob.location AS to_structure_station,
    ob.location_id AS to_ssid,
    ob.source_table AS to_ss_variety,
    ob.price AS buy_price,                                          -- buy price for single object
    --CASE c.route_security
      --WHEN 'high' THEN rj.jumps_high
      --WHEN 'low' THEN rj.jumps_low
      --ELSE rj.jumps_all
    --END AS jumps
    rj.jumps AS jumps
      FROM characters c
      INNER JOIN leftovers lo
        ON lo.character_id == c.id
      INNER JOIN (
        SELECT 
          (osh.volume_remain - COALESCE(p1.quantity, 0)) volume_remain, 
          osh.id, osh.volume_total, osh.price, osh.duration, osh.issued, osh.range,
          osh.character_id,
          osh.type_id, osh.good, osh.packaged_volume,
          osh.location_id, osh.location,
          osh.system_id, osh.system, osh.security_status,
          osh.constellation_id, osh.constellation,
          osh.region_id, osh.region,
          osh.source_table
        FROM orders_sells osh
        LEFT JOIN purchased p1
          ON osh.character_id == p1.character_id
          AND osh.id == p1.sell_id
        ) os
        ON os.character_id == c.id
        AND os.packaged_volume <= lo.cargo
        AND os.price <= lo.money
      INNER JOIN (
        SELECT 
          (obh.volume_remain - COALESCE(p2.quantity, 0)) volume_remain, 
          obh.id, obh.volume_total, obh.price, obh.duration, obh.issued, obh.range,
          obh.character_id,
          obh.type_id, obh.good, obh.packaged_volume,
          obh.location_id, obh.location,
          obh.system_id, obh.system, obh.security_status,
          obh.constellation_id, obh.constellation,
          obh.region_id, obh.region,
          obh.source_table
        FROM orders_buys obh
        LEFT JOIN purchased p2
          ON obh.character_id == p2.character_id
          AND obh.id == p2.buy_id
        ) ob
        ON ob.character_id == c.id
        AND ob.type_id == os.type_id
        AND ob.price > os.price
        AND (ob.price * (1 - c.tax / 100)) > os.price
      INNER JOIN (
        SELECT
          origin,
          destination,
          c1.id character_id,
          CASE c1.route_security
            WHEN 'high' THEN jumps_high
            WHEN 'low' THEN jumps_low
            ELSE jumps_all
          END jumps
            FROM routes_jumps
            INNER JOIN characters c1
        ) rj
        ON rj.origin == os.system_id
        AND rj.destination == ob.system_id
        AND rj.character_id == c.id
      LEFT JOIN all_ignores ais
        ON ais.character_id == c.id
        AND ais.location_id == os.location_id
      LEFT JOIN all_ignores aib
        ON aib.character_id == c.id
        AND aib.location_id == ob.location_id
      LEFT JOIN ignores_types it
        ON it.character_id == c.id
        AND it.type_id == os.type_id
      WHERE ais.location_id IS NULL
        AND aib.location_id IS NULL
        AND it.type_id      IS NULL
        AND ((ob.price * CAST(MIN( os.volume_remain, ob.volume_remain, ROUND(lo.money / os.price - 0.5), ROUND(lo.cargo / os.packaged_volume - 0.5) ) AS INT) * (1 - c.tax / 100)) - os.price * CAST(MIN( os.volume_remain, ob.volume_remain, ROUND(lo.money / os.price - 0.5), ROUND(lo.cargo / os.packaged_volume - 0.5) ) AS INT)) >= c.profit_minimum ;

-- Temp table for huge data transfer inbetween forks
CREATE TABLE transfer (
  content TEXT NOT NULL,
  character_id INTEGER NOT NULL,
  FOREIGN KEY (character_id) REFERENCES characters(id) ON UPDATE CASCADE ON DELETE CASCADE
  );

------------ INDICIES ------------ 

-- Locations (locations_indices)
CREATE INDEX ix_const_fk_region_id
  ON locations_constellations ( region_id );
CREATE INDEX ix_sys_fk_const_id
  ON locations_systems ( constellation_id );
CREATE INDEX ix_sys_nb_missing_where
  ON locations_stargates ( system_id );
CREATE INDEX ix_sys_nb_missing_select
  ON locations_stargates ( neighbour_id );
CREATE INDEX ix_sta_fk_system_id
  ON locations_stations ( system_id );
CREATE INDEX ix_str_fk_system_id
  ON locations_structures ( solar_system_id );

-- Routes (routes_jumps)
CREATE INDEX ix_routes_select
  ON routes_jumps ( origin, destination, jumps_all, jumps_high, jumps_low );
CREATE INDEX ix_routes_select_missing
  ON routes_jumps ( jumps_high, jumps_low );

-- Orders tables (orders_sells, orders_buys, hauls)
CREATE INDEX ix_sel_ostr_osb
  ON orders_structures ( volume_total, volume_remain, price, duration, issued, range );
CREATE INDEX ix_wh_ostr_osb
  ON orders_structures ( character_id, price, type_id, location_id, is_buy_order );
CREATE INDEX ix_sel_osta_osb
  ON orders_stations ( volume_total, volume_remain, price, duration, issued, range );
CREATE INDEX ix_wh_osta_osb
  ON orders_stations ( price, type_id, location_id, is_buy_order );
CREATE INDEX ix_sys_sec
  ON locations_systems ( security_status );

-- Hauls (hauls)
CREATE INDEX ix_sel_hauls_types
  ON types ( packaged_volume, name );
CREATE INDEX ix_wh_hauls_types
  ON types ( packaged_volume, name );
CREATE INDEX ix_wh_hauls_ostr
  ON orders_structures ( type_id );
CREATE INDEX ix_wh_hauls_osta
  ON orders_stations ( type_id );
CREATE INDEX ix_wh_hauls_ostr_price
  ON orders_structures ( price );
CREATE INDEX ix_wh_hauls_osta_price
  ON orders_stations ( price );
